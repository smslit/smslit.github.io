<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on SMSLIT</title>
		<link>https://www.smslit.top/post/</link>
		<description>Recent content in Posts on SMSLIT</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 22 Oct 2019 16:46:21 +0800</lastBuildDate>
		<atom:link href="https://www.smslit.top/post/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>macOS 开发之菜单栏形式的状态栏小工具</title>
			<link>https://www.smslit.top/2019/10/22/macOS-dev-basic-nsmenu/</link>
			<pubDate>Tue, 22 Oct 2019 16:46:21 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/10/22/macOS-dev-basic-nsmenu/</guid>
			<description>不知道大家有没有用过菜单栏形式的状态栏工具，类似于之前写的 NSPopover 的工具在系统顶栏占用一个图标，不同的是点击之后弹出的不是弹窗而是一个菜单，就像下</description>
			<content type="html"><![CDATA[

<p>不知道大家有没有用过菜单栏形式的状态栏工具，类似于之前写的 NSPopover 的工具在系统顶栏占用一个图标，不同的是点击之后弹出的不是弹窗而是一个菜单，就像下面截图展示的工具，本文就讲一下如何实现。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022165922-Nf83mL.jpg" alt="" /></p>

<!-- more -->

<h2 id="平台">平台</h2>

<ul>
<li>macOS 10.15</li>
<li>Xcode 11.1</li>
<li>Swift 5.1</li>
</ul>

<p>本文使用上述平台实现验证，版本不同可能有些差异，但基本思路一致。</p>

<h2 id="工程新建及配置">工程新建及配置</h2>

<ul>
<li>打开xcode新建工程， <strong>macOS</strong> -&gt; <strong>App</strong> -&gt; <strong>Next</strong>:</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022175405-tIrq9m.png" alt="" /></p>

<ul>
<li>输入工程名称：<code>MenuToolDemo</code>，<strong>language</strong> 选择<code>Swift</code>，<strong>User Interface</strong> 选择 <strong>SwiftUI</strong>(本文不会用到 SwiftUI)点击 Next：</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022175405-tIrq9m.png" alt="" /></p>

<ul>
<li>选择合适的目录，点击 <strong>create</strong> 即可打开创建的新工程；</li>

<li><p>点击运行按钮，可以看到程序运行，出现一个显示 <strong>hello world</strong> 的窗口，同时dock上出现了应用图标，这不是我们想要的，设置一下不显示它们：</p>

<ul>
<li>工程导航栏选中工程<code>MenuToolDemo</code>，打开<code>Info</code>标签页;</li>
<li>可以看到<code>Custom macOS application Target Properties</code>组，添加新的配置<code>Application is agent(UI Element)</code>，布尔属性，值为 <strong>YES</strong>:</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022175506-TsRWW4.png" alt="" /></p></li>

<li><p>重新运行程序，可以看到已经不显示Dock图标；</p></li>

<li><p>删除 <strong>ContentView.swift</strong> 文件；</p></li>

<li><p>打开文件<code>AppDelegate.swift</code>，删掉两个地方代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">var</span> <span class="nv">window</span><span class="p">:</span> <span class="n">NSWindow</span><span class="o">!</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// Create the SwiftUI view that provides the window contents.</span>
<span class="kd">let</span> <span class="nv">contentView</span> <span class="p">=</span> <span class="n">ContentView</span><span class="p">()</span>

<span class="c1">// Create the window and set the content view.</span>
<span class="n">window</span> <span class="p">=</span> <span class="n">NSWindow</span><span class="p">(</span>
    <span class="n">contentRect</span><span class="p">:</span> <span class="n">NSRect</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="mi">480</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">300</span><span class="p">),</span>
    <span class="n">styleMask</span><span class="p">:</span> <span class="p">[.</span><span class="n">titled</span><span class="p">,</span> <span class="p">.</span><span class="n">closable</span><span class="p">,</span> <span class="p">.</span><span class="n">miniaturizable</span><span class="p">,</span> <span class="p">.</span><span class="n">resizable</span><span class="p">,</span> <span class="p">.</span><span class="n">fullSizeContentView</span><span class="p">],</span>
    <span class="n">backing</span><span class="p">:</span> <span class="p">.</span><span class="n">buffered</span><span class="p">,</span> <span class="k">defer</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="n">window</span><span class="p">.</span><span class="n">center</span><span class="p">()</span>
<span class="n">window</span><span class="p">.</span><span class="n">setFrameAutosaveName</span><span class="p">(</span><span class="s">&#34;Main Window&#34;</span><span class="p">)</span>
<span class="n">window</span><span class="p">.</span><span class="n">contentView</span> <span class="p">=</span> <span class="n">NSHostingView</span><span class="p">(</span><span class="n">rootView</span><span class="p">:</span> <span class="n">contentView</span><span class="p">)</span>
<span class="n">window</span><span class="p">.</span><span class="n">makeKeyAndOrderFront</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span></code></pre></div></li>

<li><p>再次运行程序，主窗口也不显示了，连菜单栏也木有了，不要着急，咱继续。</p></li>
</ul>

<h2 id="添加状态栏按钮">添加状态栏按钮</h2>

<p>打开文件<code>AppDelegate.swift</code>，在类中添加属性，这一步是创建一个状态栏按钮，设置宽度属性<code>NSStatusItem.squareLength</code>，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">statusItem</span> <span class="p">=</span> <span class="n">NSStatusBar</span><span class="p">.</span><span class="n">system</span><span class="p">.</span><span class="n">statusItem</span><span class="p">(</span><span class="n">withLength</span><span class="p">:</span> <span class="n">NSStatusItem</span><span class="p">.</span><span class="n">squareLength</span><span class="p">)</span></code></pre></div>
<p>状态栏按钮总该需要一个图标吧！打开<code>Assets.xcassets</code>，右击显示<code>AppIcon</code>下方的空白区，选择<code>New Image Set</code>，重命名为<code>statusIcon</code>，当然这个名字随便定，选中这个图集，会看到右侧有配置区，配置图集按照<code>Template Image</code>渲染。</p>

<p>看到有三个虚线框空白区，这就是图片区，状态栏按钮的图片基本大小为 $18px\times18px$ ，还需2倍和3倍的适用于视网膜屏幕的mac，像素分别是 $36px\times36px$ 和 $54px\times54px$ ，可以使用以下我提供的图标：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20180629153024309821129.png" width="18px"><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/2018062915302434352614.png" width="36px"><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20180629153024344990828.png" width="54px"></p>

<p>分别将图拖到对应位置：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022175555-Ag8b6R.png" alt="" /></p>

<p>找到<code>applicationDidFinishLaunching</code>在其中添加以下代码，为状态栏按钮配置图标和行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="k">if</span> <span class="kd">let</span> <span class="nv">button</span> <span class="p">=</span> <span class="n">statusItem</span><span class="p">.</span><span class="n">button</span> <span class="p">{</span>
    <span class="n">button</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="n">NSImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="s">&#34;StatusIcon&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>此时运行程序会看到状态栏中出现了我们定义的按钮，当然此时鼠标单击没有任何动作发生。</p>

<blockquote>
<p>前面设置图片集渲染方式为<code>Template Image</code>，是为了适配不同的状态栏主题，因为macOS还有个暗黑主题不是？</p>
</blockquote>

<p>两种主题下的效果如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022182946-PD6ygW.png" alt="" /></p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022182916-NRA6ZI.png" alt="" /></p>

<h2 id="添加菜单">添加菜单</h2>

<p>打开 <strong>Main.storyboard</strong> 文件，使用以下两种方式中的任意一种，打开控件库窗口：</p>

<ul>
<li><p>按下快捷键 <code>Command</code> + <code>Shift</code> + <code>L</code></p></li>

<li><p>点击 Xcode 窗口右上角的 ➕ 按钮</p></li>
</ul>

<p>在搜索框中输入 <code>Menu</code>，就会检索到 NSMenu 控件：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022183632-vRDig6.png" alt="" /></p>

<p>鼠标左键在控件单击不松拖放到文件 <code>Main.storyboard</code> 的左边栏 <strong>First Responder</strong> 下面：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022184124-fhMo9C.png" alt="" /></p>

<p>按下快捷键 <code>Ctrl</code> + <code>Option</code> + <code>Command</code> + <code>Enter</code>(⌃⌥⌘⏎) 打开 <strong>Assitant</strong> 编辑器：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022184927-uusDC1.png" alt="" /></p>

<p>按住 <code>Ctrl</code> 键，鼠标左键按住 Menu 控件不松拖动至辅助编辑器的文件 <strong>AppDelegate.swift</strong> 中，在弹出的属性添加弹窗中输入属性名 <code>menu</code>，点击 Connect 就会看到 <strong>AppDelegate.swift</strong> 中出现 menu 属性：</p>

<p><video src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022190313-oUeSVx.mp4" controls="controls" width="100%"></p>

<p>打开文件 <code>AppDelegate.swift</code> ，在上面配置按钮图标的代码上面添加以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="n">statusItem</span><span class="p">.</span><span class="n">menu</span> <span class="p">=</span> <span class="n">menu</span></code></pre></div>
<p>运行程序，鼠标左键和右键单击菜单栏按钮都会弹出我们添加的按钮，包含 item1、item2 和 item3。</p>

<h2 id="配置菜单">配置菜单</h2>

<p>下面我们看一下菜单即菜单项的基本使用。</p>

<h3 id="菜单项基本属性">菜单项基本属性</h3>

<p>打开文件 <strong>main.storyboard</strong>，单击 menu，选中 <strong>Item1</strong>，可以在右侧属性检查器(Attributes Inspector) 中看到各个属性。选中 Item2 和 Item3，按 <code>Delete</code> 键删除，选中 Item1</p>

<h4 id="名称-title">名称 - Title</h4>

<p>修改 Item1 的属性检查器的 <strong>Title</strong> ，比如修改成 <strong>退出</strong>，就会修改此菜单项现实的名称。</p>

<h4 id="状态-state">状态 - State</h4>

<p>State 表示选中状态（check），三种状态：on、off、mixed。当设置为 <strong>on</strong> 的时候会看到菜单项前出现一个对号，这里设置为 <strong>off</strong> 即可。</p>

<h4 id="图标-image">图标 - Image</h4>

<p>可以设置通用的图标 Image，同时也可以设置各种状态的图标。这里我们只设置 <strong>Image</strong> 为 <strong>NSStopProgressFreestandingTemplate</strong>，编译运行：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022193003-HEef84.png" alt="" /></p>

<h4 id="行为-action">行为 - Action</h4>

<p>你会好奇为什么上面运行 <strong>退出</strong> 是灰色的，那是因为我们还没为它指定行为，类似于前面绑定 menu 属性的操作，同样的操作，只不过这次是按住 <code>Ctrl</code> 键的同时，鼠标左键单击 <strong>退出</strong> 菜单项不松拖动到辅助编辑器的 <code>AppDelegate.swift</code> 文件中，绑定一个名叫 <code>quitApp</code> 的 action。</p>

<p>实现 action 的功能为退出应用，最终 <code>quitApp</code> 方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">quitApp</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">Any</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">terminate</span><span class="p">(</span><span class="kc">self</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>编译运行程序，单击菜单栏的按钮可以看到 <strong>退出</strong> 菜单项已经不是灰色的了，可以点击，点击后便退出程序。</p>

<h4 id="快捷键">快捷键</h4>

<p>每个菜单项执行行为可以绑定快捷键的，就是设置在属性检查起中的 <strong>Key Equivalent</strong> 属性，我们这里设置为 <strong>Q</strong>，运行程序，可以看到菜单项名称后面多了一个 Q，当显示菜单时按下 Q 键，等同于点击了 <strong>退出</strong>。</p>

<h3 id="多级菜单">多级菜单</h3>

<p>多级菜单也很容易实现。</p>

<ul>
<li><p>添加新的菜单项</p>

<p>打开文件 <code>main.storyboard</code> ，按下快捷键 <code>Command</code> + <code>Shift</code> + <code>L</code> ，在控件库弹窗输入 <strong>Menu item</strong>，拖动控件 <strong>Menu Item</strong> 到 <strong>退出</strong> 上方添加。</p></li>

<li><p>威刚添加的菜单项添加菜单</p>

<p>打开控件库弹窗，拖动 <strong>Menu</strong> 控件到刚刚添加的新的菜单项 Item 上，此时可以看到 Item 后面出现了新的菜单</p></li>
</ul>

<p>运行程序，点击菜单栏按钮，鼠标放到菜单项 <strong>Item</strong> 便可以看到第二级菜单：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022195239-sZCEwG.png" alt="" /></p>

<h2 id="总结">总结</h2>

<p>本文简单讲了菜单形式菜单栏工具的基本实现，推一反三便可以实现更丰富的小工具了。最终实现的工程文件已经打包在下面：</p>

<p><a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191022195552-l6UN33.zip" target="_blank">MenuToolDemo</a></p>
]]></content>
		</item>
		
		<item>
			<title>macbook pro 换脸成功</title>
			<link>https://www.smslit.top/2019/10/18/mbp-screen/</link>
			<pubDate>Fri, 18 Oct 2019 10:13:52 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/10/18/mbp-screen/</guid>
			<description>关注我的小伙伴应该也知道 long long ago 我因为自己的愚蠢行为让 MBP 的屏幕进水了，导致它的脸 - 屏幕变成了条纹脸，显示出现一些灰色横向条纹分布整个屏幕，底部</description>
			<content type="html"><![CDATA[

<p>关注我的小伙伴应该也知道 long long ago 我因为自己的愚蠢行为让 MBP 的屏幕进水了，导致它的脸 - 屏幕变成了条纹脸，显示出现一些灰色横向条纹分布整个屏幕，底部最密集，造孽呀！没错，它需要得到救赎，就由我来帮它做换脸手术吧！</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191018104714-0v0def.jpg" alt="" /></p>

<!-- more -->

<h2 id="购买新脸">购买新脸</h2>

<p>去过 Apple 实体店，换屏幕需要四千多大洋，我去，有点猛烈，为了节流，十里决定亲自帮 MBP 换脸，木有办法，需要现便宜买张合适的脸，从某宝网上花了不到两千大洋买了一个屏幕总成，整个上盖包含屏幕，A1707 深空灰版本：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191018105601-4XfdSf.jpg" alt="" /></p>

<h2 id="拆屏幕">拆屏幕</h2>

<p>不得不说，小心翼翼，生怕把后盖弄变形，单单后盖拆了很久，不过掌握了诀窍。MBP 做工极佳，看到内部的设计也会明白为什么卖这么贵了！为了拆屏幕，可是动了不少螺丝和结构，还好的是，不需要拆主板！</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191018111142-ggDM4B.jpg" alt="" /></p>

<h2 id="安装屏幕">安装屏幕</h2>

<p>屏幕取下的时候挺费劲的，往上卡屏幕也得小心，再按照倒序还原螺丝和结构的位置就 OK 了：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191018112349-FEAIqy.jpg" alt="" /></p>

<p>最后开机，完美点亮屏幕</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20191018112421-WBnF7U.jpg" alt="" /></p>

<h2 id="总结">总结</h2>

<ul>
<li>拆机过程中发现电池有鼓包现象，这有点恐怖呀，算了先不理会！我好像拆完后盖，没有先把电池电源断开，好险，没有发生什么问题！😅</li>
<li>换完脸之后，第一次开机极慢，据说这是正常现象，我重复重启几次之后就正常了</li>
<li>可以开心地拿着 MBP 出去浪了</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>PlatformIO IDE(VSCode) - stm32cube 框架的工程</title>
			<link>https://www.smslit.top/2019/08/24/platformio-stm32-cubemx/</link>
			<pubDate>Sat, 24 Aug 2019 19:21:06 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/08/24/platformio-stm32-cubemx/</guid>
			<description>前些天知乎网友有问到 PIO 中 stm32 的 cubemx 框架工程中闪灯程序不能正常工作的问题，猜测可能是没有进行系统时钟配置导致的。本文就以 LED 闪烁为例讲一下如何新建一</description>
			<content type="html"><![CDATA[

<p>前些天知乎网友有问到 PIO 中 stm32 的 cubemx 框架工程中闪灯程序不能正常工作的问题，猜测可能是没有进行系统时钟配置导致的。本文就以 LED 闪烁为例讲一下如何新建一个 <strong>stm32cube</strong> 框架的工程，并且将 LED 点亮。</p>

<h2 id="测试平台">测试平台</h2>

<ul>
<li>PlatformIO IDE (VSCode)</li>
<li>stm32f103c8t6 最小系统板，板载 LED 连接在 <strong>PC13</strong> 管脚，低电平点亮</li>
<li>stlink v2 仿真调试器</li>
</ul>

<p>测试目标：创建 <strong>stm32cube</strong> 框架的工程项目，实现 LED 周期闪烁的代码</p>

<h2 id="创建工程项目">创建工程项目</h2>

<p>这一步很简单，注意选择框架 <strong>stm32cube</strong><sup class="footnote-ref" id="fnref:stm32cube-cubemx"><a href="#fn:stm32cube-cubemx">1</a></sup>，开发板选择 <strong>STM32F103C8(20k RAM. 64k Flash)(Generic)</strong>，名称随便，最后点击创建即可：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190824193953-b9xwHn.png" alt="" /></p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190824194009-9G7nyQ.png" alt="" /></p>

<h2 id="添加例程代码">添加例程代码</h2>

<p>按照 <a href="https://docs.platformio.org/en/latest/tutorials/ststm32/stm32cube_debugging_unit_testing.html#adding-code-to-the-generated-project" target="_blank">STM32Cube HAL and Nucleo-F401RE: debugging and unit testing - Adding Code to the Generated Project</a> <sup class="footnote-ref" id="fnref:STM32Cube-HAL-an"><a href="#fn:STM32Cube-HAL-an">2</a></sup> 描述的过程添加适合自己开发板的代码（修改对应的 LED 管脚即可）。</p>

<p>右键 src 文件夹，新建两个文件，一个是 <code>main.h</code> 另一个是 <code>main.c</code>：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190824195932-qoIR8c.png" alt="" /></p>

<p>向 <code>mian.h</code> 中添加以下代码，如果您的板载 LED 连接到其它管脚，请相应修改关于 LED 的三个宏定义：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#ifndef MAIN_H
</span><span class="cp">#define MAIN_H
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;stm32f1xx_hal.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define LED_PIN GPIO_PIN_13
</span><span class="cp">#define LED_GPIO_PORT GPIOC
</span><span class="cp">#define LED_GPIO_CLK_ENABLE() __HAL_RCC_GPIOC_CLK_ENABLE()
</span><span class="cp"></span>
<span class="cp">#endif  </span><span class="c1">// MAIN_H
</span></code></pre></div>
<p>向 <code>mian.c</code> 中添加以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;main.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">LED_Init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">HAL_Init</span><span class="p">();</span>
  <span class="n">LED_Init</span><span class="p">();</span>

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// LED 翻转
</span><span class="c1"></span>    <span class="n">HAL_GPIO_TogglePin</span><span class="p">(</span><span class="n">LED_GPIO_PORT</span><span class="p">,</span> <span class="n">LED_PIN</span><span class="p">);</span>
    <span class="n">HAL_Delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">LED_Init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// LED GPIO 初始化
</span><span class="c1"></span>  <span class="n">LED_GPIO_CLK_ENABLE</span><span class="p">();</span>
  <span class="n">GPIO_InitTypeDef</span> <span class="n">GPIO_InitStruct</span><span class="p">;</span>
  <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pin</span> <span class="o">=</span> <span class="n">LED_PIN</span><span class="p">;</span>
  <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Mode</span> <span class="o">=</span> <span class="n">GPIO_MODE_OUTPUT_PP</span><span class="p">;</span>
  <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Pull</span> <span class="o">=</span> <span class="n">GPIO_PULLUP</span><span class="p">;</span>
  <span class="n">GPIO_InitStruct</span><span class="p">.</span><span class="n">Speed</span> <span class="o">=</span> <span class="n">GPIO_SPEED_FREQ_HIGH</span><span class="p">;</span>
  <span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">LED_GPIO_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GPIO_InitStruct</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">SysTick_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="n">HAL_IncTick</span><span class="p">();</span> <span class="p">}</span></code></pre></div>
<p>确保把 stm32f103c8t6 的最小系统板通过 stlink 连接到电脑 usb，编译并上传程序：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190824222127-q3S1ZX.png" alt="" /></p>

<p><strong>what？</strong> LED 竟然没有如期的闪动起来!</p>

<h2 id="解决问题">解决问题</h2>

<p>代码都正确呀，为什么程序没有正常工作呢?首先怀疑对象是系统时钟，用示波器测试了一下芯片的高速晶振管脚，竟然没有起振，哎呀，我们确实没有添加系统时钟配置的代码，再次对照一下用 <strong>STMCubeMX</strong><sup class="footnote-ref" id="fnref:STM32CubeMX-is-a"><a href="#fn:STM32CubeMX-is-a">3</a></sup> 生成的普通项目的源码，确实我们的工程中缺少了对于时钟的配置。</p>

<p>为了解决这个问题，参考了 STMCubeMX 项目，笔者建议除了添加时钟的配置之外，还要加一些可能以后会用到的处理函数。这里我们添加两个新的文件 <code>sys_basic.h</code> 和 <code>sys_basic.c</code>。</p>

<p>文件 <code>sys_basic.h</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifndef SYS_BASIC_H
</span><span class="cp">#define SYS_BASIC_H
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">_Error_Handler</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="cp">#define Error_Handler() _Error_Handler(__FILE__, __LINE__)
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">SystemClock_Config</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#endif</span></code></pre></div>
<p>文件 <code>sys_basic.c</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&#34;sys_basic.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;stm32f1xx_hal.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/** System Clock Configuration
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">SystemClock_Config</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RCC_OscInitTypeDef</span> <span class="n">RCC_OscInitStruct</span><span class="p">;</span>
  <span class="n">RCC_ClkInitTypeDef</span> <span class="n">RCC_ClkInitStruct</span><span class="p">;</span>

  <span class="cm">/**Initializes the CPU, AHB and APB busses clocks
</span><span class="cm">   */</span>
  <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">OscillatorType</span> <span class="o">=</span> <span class="n">RCC_OSCILLATORTYPE_HSE</span><span class="p">;</span>
  <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">HSEState</span> <span class="o">=</span> <span class="n">RCC_HSE_ON</span><span class="p">;</span>
  <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">HSEPredivValue</span> <span class="o">=</span> <span class="n">RCC_HSE_PREDIV_DIV1</span><span class="p">;</span>
  <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">HSIState</span> <span class="o">=</span> <span class="n">RCC_HSI_ON</span><span class="p">;</span>
  <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLState</span> <span class="o">=</span> <span class="n">RCC_PLL_ON</span><span class="p">;</span>
  <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLSource</span> <span class="o">=</span> <span class="n">RCC_PLLSOURCE_HSE</span><span class="p">;</span>
  <span class="n">RCC_OscInitStruct</span><span class="p">.</span><span class="n">PLL</span><span class="p">.</span><span class="n">PLLMUL</span> <span class="o">=</span> <span class="n">RCC_PLL_MUL9</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">HAL_RCC_OscConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCC_OscInitStruct</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HAL_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Error_Handler</span><span class="p">(</span><span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**Initializes the CPU, AHB and APB busses clocks
</span><span class="cm">   */</span>
  <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">ClockType</span> <span class="o">=</span> <span class="n">RCC_CLOCKTYPE_HCLK</span> <span class="o">|</span> <span class="n">RCC_CLOCKTYPE_SYSCLK</span> <span class="o">|</span>
                                <span class="n">RCC_CLOCKTYPE_PCLK1</span> <span class="o">|</span> <span class="n">RCC_CLOCKTYPE_PCLK2</span><span class="p">;</span>
  <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">SYSCLKSource</span> <span class="o">=</span> <span class="n">RCC_SYSCLKSOURCE_PLLCLK</span><span class="p">;</span>
  <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">AHBCLKDivider</span> <span class="o">=</span> <span class="n">RCC_SYSCLK_DIV1</span><span class="p">;</span>
  <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">APB1CLKDivider</span> <span class="o">=</span> <span class="n">RCC_HCLK_DIV2</span><span class="p">;</span>
  <span class="n">RCC_ClkInitStruct</span><span class="p">.</span><span class="n">APB2CLKDivider</span> <span class="o">=</span> <span class="n">RCC_HCLK_DIV1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">HAL_RCC_ClockConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">RCC_ClkInitStruct</span><span class="p">,</span> <span class="n">FLASH_LATENCY_2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HAL_OK</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_Error_Handler</span><span class="p">(</span><span class="n">__FILE__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**Configure the Systick interrupt time
</span><span class="cm">   */</span>
  <span class="n">HAL_SYSTICK_Config</span><span class="p">(</span><span class="n">HAL_RCC_GetHCLKFreq</span><span class="p">()</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>

  <span class="cm">/**Configure the Systick
</span><span class="cm">   */</span>
  <span class="n">HAL_SYSTICK_CLKSourceConfig</span><span class="p">(</span><span class="n">SYSTICK_CLKSOURCE_HCLK</span><span class="p">);</span>

  <span class="cm">/* SysTick_IRQn interrupt configuration */</span>
  <span class="n">HAL_NVIC_SetPriority</span><span class="p">(</span><span class="n">SysTick_IRQn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * @brief  This function is executed in case of error occurrence.
</span><span class="cm"> * @param  None
</span><span class="cm"> * @retval None
</span><span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">_Error_Handler</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* USER CODE BEGIN Error_Handler_Debug */</span>
  <span class="cm">/* User can add his own implementation to report the HAL error return state */</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="cm">/* USER CODE END Error_Handler_Debug */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">NMI_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">HardFault_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MemManage_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">BusFault_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">UsageFault_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">SVC_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">DebugMon_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">PendSV_Handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span></code></pre></div>
<p>时钟初始化在函数 <code>SystemClock_Config</code> 中实现，这里时钟源选择使用 8M 高速晶振、9倍频等等常用的时钟配置，在 <code>main.c</code> 中包含头文件 <code>sys_basic.h</code> 并在主函数 <code>HAL_Init();</code> 后加入时钟初始化函数调用 <code>SystemClock_Config();</code>。</p>

<p>此时编译上传程序，可以看到 LED 如期灵动了起来！</p>

<h2 id="调试程序">调试程序</h2>

<p>调试程序与使用 Arduino 框架时一致，需要在配置文件中指定调试工具，这里使用的是 stlink ，所以 <code>paltformio.ini</code> 的内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="k">[env:genericSTM32F103C8]</span>
<span class="na">platform</span> <span class="o">=</span> <span class="s">ststm32</span>
<span class="na">board</span> <span class="o">=</span> <span class="s">genericSTM32F103C8</span>
<span class="na">framework</span> <span class="o">=</span> <span class="s">stm32cube</span>
<span class="na">debug_tool</span> <span class="o">=</span> <span class="s">stlink</span></code></pre></div>
<p>点击 F5 按键便可以进行程序调试了！</p>

<h2 id="总结">总结</h2>

<p>本文简单讲解了创建 stm32cube 框架的 PIO 工程的过程、遇到的问题及解决方法，希望对初次使用 PIO 开发 stm32cube 项目的同学有所帮助！</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:stm32cube-cubemx">stm32cube 对应的就是 cubemx 库，详见<a href="https://docs.platformio.org/en/latest/frameworks/stm32cube.html" target="_blank">STM32Cube</a> <a class="footnote-return" href="#fnref:stm32cube-cubemx"><sup>[return]</sup></a></li>
<li id="fn:STM32Cube-HAL-an"><a href="https://docs.platformio.org/en/latest/tutorials/ststm32/stm32cube_debugging_unit_testing.html#tutorial-stm32cube-debugging-unit-testing" target="_blank">STM32Cube HAL and Nucleo-F401RE: debugging and unit testing</a> <a class="footnote-return" href="#fnref:STM32Cube-HAL-an"><sup>[return]</sup></a></li>
<li id="fn:STM32CubeMX-is-a">STM32CubeMX is a graphical tool that allows a very easy configuration of STM32 microcontrollers and microprocessors, as well as the generation of the corresponding initialization C code for the Arm® Cortex®-M core or a partial Linux® Device Tree for Arm® Cortex®-A core), through a step-by-step process.——<a href="https://www.st.com/en/development-tools/stm32cubemx.html" target="_blank">STM32CubeMX</a> <a class="footnote-return" href="#fnref:STM32CubeMX-is-a"><sup>[return]</sup></a></li>
</ol>
</div>
]]></content>
		</item>
		
		<item>
			<title>PlatformIO IDE(VSCode) - 实现 VS1838B 红外接收驱动</title>
			<link>https://www.smslit.top/2019/08/21/platformio-irremote-driver/</link>
			<pubDate>Wed, 21 Aug 2019 10:51:18 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/08/21/platformio-irremote-driver/</guid>
			<description>最近做一个项目需要用到红外接收，项目工程针对的是 STM32F103C8T6 平台，使用的是 Arduino 框架，想着不重复造轮子，结果第三方红外库都没有同时满足 ST STM32 平台 和 Arduino 框架两个</description>
			<content type="html"><![CDATA[

<p>最近做一个项目需要用到红外接收，项目工程针对的是 <code>STM32F103C8T6</code> 平台，使用的是 Arduino 框架，想着不重复造轮子，结果第三方红外库都没有同时满足 ST STM32 平台 和 Arduino 框架两个条件的，索性就自己造个轮子呗，也不难！</p>

<h2 id="硬件连接">硬件连接</h2>

<p>本文的实现驱动的硬件条件如下：</p>

<ul>
<li>STM32F103C8T6 最小系统板</li>
<li>stlink v2 仿真调试器</li>
<li>VS1838B 红外接收头</li>
<li>常规的红外遥控器</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190821125056-eMMm6g.jpg" alt="" /></p>

<p>VS1838B 有三个管脚，VCC 、 GND 和 OUT，搭建的硬件电路很简单，不需要其他的配套电路，直接连接单片机管脚和电源就能正常使用，这里我将管脚连接到 <strong>PA0</strong> 管脚。</p>

<h2 id="红外相关知识">红外相关知识</h2>

<p>要想编写红外驱动需要了解红外接收器输出得信号特点，根据 VS1838B 输出信号有的放矢的设计信号解析驱动。</p>

<p>笔者手头的红外遥控器采用 NEC 编码协议<sup class="footnote-ref" id="fnref:NEC-https-blog-c"><a href="#fn:NEC-https-blog-c">1</a></sup>，其中红外发射芯片会自动扫描矩阵键盘电路，根据不同的键码，生成一串二进制数据，再按每位的二进制数据用相应的红外光信号发出。遥控器上的一个按键按下后的 <strong>bit</strong> 数据:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190821135123-cVuJ0l.png" alt="" /></p>

<p>引导码用于标识一个键码数据的传输开始，将传输 32 位数据，共四个字节，按照先低位后高位传输。第一个字节为用户编码，用于标识遥控器的厂家，第二个字节为用户编吗的反码，用于校验用户编码。第三个字节是按键编码用于区别按下的键，第四个字节为按键编码的反码，用于校验按键编码, 从而确保红外线传输的数据的有效性。</p>

<p>引导码、位数据 0 和位数据 1 信号特征明显，可以参考如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190821143223-HkqRTp.png" alt="" /></p>

<p>上面就是红外要发射数据的格式了，真正发射光信号的时候，其实是将待发射的数据调制到一个 38KHz 的光信号中的，红外接收头比如 VS1838B，接收到这个信号后会对信号进行信号放大、带通滤波、解调、波形整形最终还原出原始的 NEC 协议按键编码，但是要注意的是从 VS1838B 输出的信号是与原始编码反相的<sup class="footnote-ref" id="fnref:35-linux-https-b"><a href="#fn:35-linux-https-b">2</a></sup>，通俗讲就是高低电平是反着的。</p>

<h2 id="驱动设计思路">驱动设计思路</h2>

<p>为了找到解析 VS1838B 输出信号的方法，我们还是得先分析一下引导码、位数据 0 和 位数据 1 的特征，其实我们只要找到能区分这三个信号的方法即可。</p>

<p>观察上一小节信号特征图，可以发现三种信号最明显的区别就是低电平时间：</p>

<table>
<thead>
<tr>
<th>信号</th>
<th>低电平时间(ms)</th>
</tr>
</thead>

<tbody>
<tr>
<td>引导码</td>
<td>4.5ms</td>
</tr>

<tr>
<td>b0</td>
<td>0.56ms</td>
</tr>

<tr>
<td>b1</td>
<td>1.68ms</td>
</tr>
</tbody>
</table>

<p>但是我们知道 VS1838B 输出信号是与图中高低信号相反的，所以针对 VS1838B 的输出信号，我们只需要判断每段高电平的时间就可以区分出引导码、位数据 0 和 位数据 1。</p>

<p>一组红外数据的信号是以引导码开始的，所以正常状态下一旦判断到是引导码，下面就应该通过区分位数据信号来保存位数据生成字节数据了，需要连续分辨 32 位数据是 0 或 1即可。</p>

<p>为了保证及时的判断管脚电平的变化，这里采用 IO 外部中断的方式，在中断子程序中实现解析逻辑，解析数据之前关键的一点还是得到高电平时间，将外部中断触发方式设置为电平变化触发，也就是无论电平下降沿还是上升沿都会触发中断。</p>

<p>中断处理逻辑中，加入状态机的处理形式，可分两种状态：</p>

<ul>
<li><strong>正常状态</strong>：等待引导码</li>
<li><strong>接收数据状态</strong>：解析 0、1 数据</li>
</ul>

<p>最终结果存储在一个 32 位整型数据中，那么整个中断的处理逻辑步骤可参考如下：</p>

<ol>
<li>判断进入中断时管脚电平

<ul>
<li>如果是高电平，记录此刻时间，退出中断</li>
<li>如果是低电平，用此刻时间减去记录的时间就得到了高电平脉冲宽度（单位 us），然后进行第 2 步</li>
</ul></li>
<li>判断此时状态：

<ul>
<li>如果是<strong>正常状态</strong>，脉宽如果大于 4000us 说明是引导码，此时将状态切换为<strong>接收数据状态</strong>，结果置为 0，然后退出中断</li>
<li>如果是<strong>接收数据状态</strong>，判断脉宽如果在 1120us 和 2240us 之间说明是 1 ，将结果的对应位置 1 ，然后判断是否接受完所有位：

<ul>
<li>如果是，对结果进行校验（利用反码），如果正确进行数据处理</li>
<li>如果没有，退出中断</li>
</ul></li>
</ul></li>
</ol>

<h2 id="驱动程序实现">驱动程序实现</h2>

<p>根据上述思路设计了红外接收驱动程序，以库的形式对程序封装，声明对象只需指定管脚和处理回调函数即可，在 PlatformIO IDE 项目工程目录 lib 中新建 IrRemote 目录，目录下放置源代码 irRemote.h 和 irRemote.cpp。理论上只要是使用 Arduino 框架，并且管脚支持 IO 外部中断，均可以正常使用。</p>

<h3 id="irremote-h">irRemote.h</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#ifndef IRREMOTE_H_
</span><span class="cp">#define IRREMOTE_H_
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&#34;Arduino.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">IrRemoteCBPtr</span><span class="p">)(</span><span class="n">uint32_t</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">IrRemoteState</span> <span class="p">{</span> <span class="n">WAITING</span><span class="p">,</span> <span class="n">READING</span> <span class="p">};</span>

<span class="cm">/**
</span><span class="cm"> * @brief 红外接收结果联合体
</span><span class="cm"> *
</span><span class="cm"> * 定义红外接收联合体是为了可以从原生的 32 位数据，轻松获取字节数据
</span><span class="cm"> */</span>
<span class="k">union</span> <span class="n">IrRemoteResult</span> <span class="p">{</span>
  <span class="n">uint32_t</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">uint8_t</span> <span class="n">bytes</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">class</span><span class="err"> </span><span class="nc">IrRemote</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="cm">/**
</span><span class="cm">   * @brief 红外类的构造函数
</span><span class="cm">   *
</span><span class="cm">   * 指定红外的管脚和回调函数
</span><span class="cm">   *
</span><span class="cm">   * @param pin 连接红外数据输出的管脚
</span><span class="cm">   * @param callback
</span><span class="cm">   * 收到数据后要执行的回调函数，回调函数具有一个参数用于传递数据结果
</span><span class="cm">   */</span>
  <span class="n">IrRemote</span><span class="p">(</span><span class="n">uint8_t</span> <span class="n">pin</span><span class="p">,</span> <span class="n">IrRemoteCBPtr</span> <span class="n">callback</span><span class="p">);</span>

  <span class="cm">/**
</span><span class="cm">   * @brief 红外数据接收处理函数
</span><span class="cm">   *
</span><span class="cm">   * 分析红外输出电平及持续时间，解析得到数据
</span><span class="cm">   */</span>
  <span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

  <span class="cm">/**
</span><span class="cm">   * @brief 启动红外接收
</span><span class="cm">   *
</span><span class="cm">   * 开启红外数据解析逻辑
</span><span class="cm">   */</span>
  <span class="kt">void</span> <span class="nf">begin</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

  <span class="cm">/**
</span><span class="cm">   * @brief 关闭红外接收
</span><span class="cm">   *
</span><span class="cm">   * 关闭红外数据解析逻辑
</span><span class="cm">   */</span>
  <span class="kt">void</span> <span class="nf">end</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">uint8_t</span> <span class="n">pin</span><span class="p">;</span>             <span class="c1">// 连接红外输出的管脚
</span><span class="c1"></span>  <span class="n">uint32_t</span> <span class="n">time</span><span class="p">;</span>           <span class="c1">// 上一次 FALLING 的时刻，单位 us
</span><span class="c1"></span>  <span class="n">uint32_t</span> <span class="n">width</span><span class="p">;</span>          <span class="c1">// 脉冲宽度，单位 us
</span><span class="c1"></span>  <span class="n">uint32_t</span> <span class="n">count</span><span class="p">;</span>          <span class="c1">// 数据接收位数计数
</span><span class="c1"></span>  <span class="n">IrRemoteState</span> <span class="n">state</span><span class="p">;</span>     <span class="c1">// 处理状态
</span><span class="c1"></span>  <span class="n">IrRemoteResult</span> <span class="n">result</span><span class="p">;</span>   <span class="c1">// 收到的数据结果
</span><span class="c1"></span>  <span class="n">IrRemoteCBPtr</span> <span class="n">callback</span><span class="p">;</span>  <span class="c1">// 收到数据的回调函数
</span><span class="c1"></span>
  <span class="cm">/**
</span><span class="cm">   * @brief 红外接收结果校验
</span><span class="cm">   *
</span><span class="cm">   * 校验红外接收结果，最后两个字节互为反码即为正确结果
</span><span class="cm">   *
</span><span class="cm">   * @param result 解析得到的红外接收结果
</span><span class="cm">   */</span>
  <span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="n">IrRemoteResult</span> <span class="n">result</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#endif
</span></code></pre></div>
<h3 id="irremote-cpp">irRemote.cpp</h3>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&#34;irRemote.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">nullCB</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">_</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">irRxHandler</span><span class="p">(</span><span class="n">IrRemote</span> <span class="o">*</span><span class="n">ir</span><span class="p">)</span> <span class="p">{</span> <span class="n">ir</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">();</span> <span class="p">}</span>

<span class="n">IrRemote</span><span class="o">::</span><span class="n">IrRemote</span><span class="p">(</span><span class="n">uint8_t</span> <span class="n">pin</span><span class="p">,</span> <span class="n">IrRemoteCBPtr</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">pin</span> <span class="o">=</span> <span class="n">pin</span><span class="p">;</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span><span class="p">;</span>

  <span class="n">pinMode</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">,</span> <span class="n">INPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IrRemote</span><span class="o">::</span><span class="n">handler</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">digitalRead</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">)</span> <span class="o">==</span> <span class="n">HIGH</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">micros</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">micros</span><span class="p">()</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">time</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nl">WAITING</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mi">4000</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">READING</span><span class="p">;</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">READING</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mi">1120</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&lt;</span> <span class="mi">2240</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">.</span><span class="n">value</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x00000001</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">this</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">WAITING</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">detachInterrupt</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
            <span class="n">attachInterrupt</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">,</span> <span class="p">(</span><span class="n">voidArgumentFuncPtr</span><span class="p">)</span><span class="n">irRxHandler</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
                            <span class="n">CHANGE</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IrRemote</span><span class="o">::</span><span class="n">begin</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">WAITING</span><span class="p">;</span>
  <span class="n">attachInterrupt</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">,</span> <span class="p">(</span><span class="n">voidArgumentFuncPtr</span><span class="p">)</span><span class="n">irRxHandler</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">CHANGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IrRemote</span><span class="o">::</span><span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="n">detachInterrupt</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">pin</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">bool</span> <span class="n">IrRemote</span><span class="o">::</span><span class="n">check</span><span class="p">(</span><span class="n">IrRemoteResult</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">result</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">result</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">result</span><span class="p">.</span><span class="n">bytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="测试驱动">测试驱动</h2>

<p>编写一个例程测试一下驱动，当收到数据的时候通过串口把数据打印出来，<code>main.cpp</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;irRemote.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span> <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">HEX</span><span class="p">);</span> <span class="p">}</span>

<span class="n">IrRemote</span> <span class="nf">ir</span><span class="p">(</span><span class="n">PB0</span><span class="p">,</span> <span class="n">test</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 启动红外接收
</span><span class="c1"></span>  <span class="n">ir</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div>
<p>将连接了 VS1838B 的 stm32f103c8t6 最小系统板通过 stlink 连接电脑同时将其 usb 直连到电脑，编译上传程序，待运行以后，打开串口调试助手，对着 VS1838B 按下红外遥控按钮，便可以看到对应的 32 位原数据(从高位到低位四个字节分别是按键编码反码、按键编码、用户编码反码、用户编码)：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190821162128-Mce9i5.png" alt="" /></p>

<h2 id="总结">总结</h2>

<p>本文讲的红外驱动实现思路对于 NEC 协议的红外数据解析应该是通用的，笔者因为使用了 Arduino 框架，所以是以 Arduino 为基础设计的驱动程序，当然不使用 Arduino 框架也可以按照实现思路进行设计对应的驱动，思路可行就可以！希望本文介绍的思路能够帮到您！</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:NEC-https-blog-c"><a href="https://blog.csdn.net/yu__jia/article/details/52912762" target="_blank"> NEC红外线编码协议</a> <a class="footnote-return" href="#fnref:NEC-https-blog-c"><sup>[return]</sup></a></li>
<li id="fn:35-linux-https-b"><a href="https://blog.csdn.net/jklinux/article/details/73498067" target="_blank">35 红外接收头在linux内核里的驱动</a> <a class="footnote-return" href="#fnref:35-linux-https-b"><sup>[return]</sup></a></li>
</ol>
</div>
]]></content>
		</item>
		
		<item>
			<title>PlatformIO IDE(VSCode) 基本使用 - 使用第三方库</title>
			<link>https://www.smslit.top/2019/08/19/platformio-libraries/</link>
			<pubDate>Mon, 19 Aug 2019 10:49:25 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/08/19/platformio-libraries/</guid>
			<description>在实际做一个项目的时候，为了提高效率我们会首选不重复造轮子，所以可能会用到第三方库，而 PlatformIO 为我们整理和提供了一些即装即用的第三方库，本文笔者就</description>
			<content type="html"><![CDATA[

<p>在实际做一个项目的时候，为了提高效率我们会首选不重复造轮子，所以可能会用到第三方库，而 PlatformIO 为我们整理和提供了一些即装即用的第三方库，本文笔者就带大家了解一下在 PlatformIO IDE (VSCode) 中如何使用和管理这些库。</p>

<h2 id="前言">前言</h2>

<p>本文将使用 Arduino Leonardo 讲解，以文章 <a href="/2019/08/18/platformio-newproject/" target="_blank">PlatformIO IDE(VSCode) 基本使用 - 新建项目</a> 中新建的控制 LED 闪烁的工程（blink）为例。</p>

<p>这个工程中 LED 的控制是阻塞式的，因为使用了 <code>delay</code> 方法，就是死等延时这造成了运算资源的浪费，有没有更好的方法控制 LED 按周期闪烁，而不阻塞呢？笔者很自然地想到了用定时器控制 led 就行啦，所以这就有了我们的新的需求，有没有第三方库支持定时器操作呢！</p>

<p>PIO 提供了很好的方式帮助我们查找和管理第三方库，在下一小节跟笔者一起看一下如何找到我们需要的第三方库。</p>

<h2 id="第三方库的管理">第三方库的管理</h2>

<p>首先我们打开 blink 工程，然后打开 PIO Home 页面，点击左侧的 <strong>Libraries</strong> 标签打开库的标签页，我们会看到库的标签页中有四个标签页分别是：</p>

<ul>
<li><strong>Registry</strong>：仓库，在这里我们可以查找我们需要的第三方库，也能看到按照下载量排序的关键词标签，也能看到最近库的下载排名</li>
<li><strong>Installed</strong>：在这里我们能看到曾经安装的库，并对它们进行管理</li>
<li><strong>Build-in</strong>：在这里我们能看到安装的平台和框架中内建的库</li>
<li><strong>Updates</strong>：在这里我们能看到需要更新的库</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190819165858-rZXhxO.png" alt="" /></p>

<h3 id="库的查找">库的查找</h3>

<p>按照上面提到的需求，我们在 <strong>Registry</strong> 标签页中查找库，我们在搜索框中搜索定时器对应的英文 <code>Timer</code>:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190819170522-tktUXt.png" alt="" /></p>

<p>可以看到会列出搜索到的结果，搜索优先会按照框架进行关键词搜索，我们看一下具体的一个条目，比如第一个库 <strong>Ticker</strong>，每个条目包含的信息如下：</p>

<ul>
<li>名称及功能描述</li>
<li>适用的框架</li>
<li>适用的平台</li>
<li>关键词标签</li>
<li>其它：下载量、例程数</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190819171521-GCYNkM.png" alt="" /></p>

<p>根据第一个描述就符合我们的需求呀，我们点击一下进入库的页面：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190819172308-nxocy5.png" alt="" /></p>

<p>可以看到有五个标签页，这里简单说明一下：</p>

<ul>
<li><strong>Examples</strong>：展示库中包含的例程，有的包含多个，可以点击下拉列表选择不同的例程查看代码</li>
<li><strong>Installtion</strong>：展示如何在项目工程中使用库，在 <code>platformio.ini</code> 文件中如何配置</li>
<li><strong>Headers</strong>：库中包含的头文件</li>
<li><strong>Manifest</strong>：这个一般不用关心，展示的是这个库在 PIO 仓库中的配置信息</li>
<li><strong>Changelog</strong>：更新日志</li>
</ul>

<h3 id="库的安装">库的安装</h3>

<p>安装库一般是两种形式，一种是全局安装，其他项目工程也能够使用，另一种是只安装到指定项目工程中。</p>

<p>点击 <strong>Install</strong> 会默认全局安装，这样其它的工程项目也能使用而不用重复安装。</p>

<p>另外，也可以点击 Install 按钮右边的 <code>...</code> 按钮完成指定位置的安装：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190819200737-zYvJxn.png" alt="" /></p>

<p>这里我们采用全局安装，点击 <code>Install</code> 按钮即可，库安装完成后会有弹窗提示。</p>

<h3 id="库的卸载">库的卸载</h3>

<p>有时有些库可能不再会使用，如果想卸载怎么操作？找到 Librairies 的 Installed 标签页，就会看到我们刚才安装的 <strong>Ticker</strong> 库，可以看到 <code>Uninstall</code> 按钮，点击它按照提示操作即可完成卸载，点击 <code>Reveal</code> 按钮会打开安装库的目录：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190819201650-LtB1dT.png" alt="" /></p>

<h3 id="库的更新">库的更新</h3>

<p>PIO Home 启动后会检测库的更新，如果库有新的版本发布，就会在 Libraries - Updates 页面出现待更新的库，点击 <code>Update</code> 按钮即可实现更新！</p>

<h2 id="库的使用">库的使用</h2>

<h3 id="配置">配置</h3>

<p>使用第三方库的方式会在库的页面的 <code>Installtion</code> 标签页展示，比如 <strong>Ticker</strong> 库的：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190819202421-yNf4mA.png" alt="" /></p>

<p>需要在 <code>paltformio.ini</code> 文件中添加 <code>lib_deps</code> 项，指定库即可，主要有三种方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="na">lib_deps</span> <span class="o">=</span>
<span class="c1"># 使用库的名称</span>
    <span class="na">Ticker</span>

<span class="c1"># ... 或者使用库的 ID</span>
    <span class="na">1586</span>

<span class="c1"># ... 或者使用指定版本的库</span>
    <span class="na">Ticker@3.1.5</span>
    
<span class="c1"># Semantic Versioning Rules</span>
<span class="c1"># http://docs.platformio.org/page/userguide/lib/cmd_install.html#description</span>
<span class="c1"># Ticker@^3.1.5</span>
<span class="c1"># Ticker@~3.1.5</span>
<span class="c1"># Ticker@&gt;=3.1.5</span></code></pre></div>
<p>我们这里采用第一种方式，最终 <strong>blink</strong> 项目的 <code>platformio.ini</code> 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="nl">env</span><span class="p">:</span><span class="n">leonardo</span><span class="p">]</span>
<span class="n">platform</span> <span class="o">=</span> <span class="n">atmelavr</span>
<span class="n">board</span> <span class="o">=</span> <span class="n">leonardo</span>
<span class="n">framework</span> <span class="o">=</span> <span class="n">arduino</span>
<span class="n">lib_deps</span> <span class="o">=</span>
  <span class="cp"># Using a library name
</span><span class="cp"></span>  <span class="n">Ticker</span></code></pre></div>
<p>这里要注意的是，一个项目工程极有可能会使用多个库，这是有两种语法配置：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="c1">; one line definition (comma + space)</span>
<span class="k">[env:myenv]</span>
<span class="na">lib_deps</span> <span class="o">=</span> <span class="s">LIBRARY_1, LIBRARY_2, LIBRARY_N</span>

<span class="c1">; multi-line definition</span>
<span class="k">[env:myenv2]</span>
<span class="na">lib_deps</span> <span class="o">=</span><span class="s">
</span><span class="s">  LIBRARY_1
</span><span class="s">  LIBRARY_2
</span><span class="s">  LIBRARY_N</span></code></pre></div>
<h3 id="使用库">使用库</h3>

<p>这样我们就可以在工程中源代码中包含库的头文件然后使用库了，因为毕竟是别人的写的库，所以应该先看一下例程的用法，然后根据自己的需求实现自己需要的功能。</p>

<p>比如还是实现 1s 切换一次 LED 状态实现等的闪烁，只需要编写相应的处理函数，定义新的 Ticker 指定处理函数和时间参数即可，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;Ticker.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">blink</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="n">uint32_t</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">state</span> <span class="o">^=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_BUILTIN</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Ticker</span> <span class="nf">timer</span><span class="p">(</span><span class="n">blink</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MILLIS</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED_BUILTIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">timer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">timer</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>
  <span class="c1">//放置其它处理操作
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
<p>编译上传程序，顺利的话同样实现了 LED 的秒闪烁。</p>

<h2 id="结语">结语</h2>

<p>本文只是简单的说了库管理和使用的基本常用操作，可以满足基本使用需求了，如果需要了解更多内容，可以参考：<a href="https://docs.platformio.org/en/latest/librarymanager/index.html" target="_blank">Library Manager</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>PlatformIO IDE(VSCode) 基本使用 - 新建项目</title>
			<link>https://www.smslit.top/2019/08/18/platformio-newproject/</link>
			<pubDate>Sun, 18 Aug 2019 17:02:01 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/08/18/platformio-newproject/</guid>
			<description>PlatformIO IDE (VSCode) 可以帮助我们更好地使用 PlatforIO，一个 MCU 项目的开始那就是新建，本文就讲解一下如果使用 PlatformIO IDE 新建一个 MCU 的项目。 基本概念 在使用 PlatformIO 的过</description>
			<content type="html"><![CDATA[

<p>PlatformIO IDE (VSCode) 可以帮助我们更好地使用 PlatforIO，一个 MCU 项目的开始那就是新建，本文就讲解一下如果使用 PlatformIO IDE 新建一个 MCU 的项目。</p>

<h2 id="基本概念">基本概念</h2>

<p>在使用 PlatformIO 的过程中经常会遇到一些词，比如 Platform 、 Framworks 以及 Boards，在新建项目之前有必要先说明一下，这些具体都代表了什么！</p>

<h3 id="platform">Platform</h3>

<p>直译的话就是 <strong>平台</strong>，具体就是指的芯片平台，再详细一点那就是各个公司具体的系列芯片的开发平台了。目前为止 PIO<sup class="footnote-ref" id="fnref:PIO-PlatformIO"><a href="#fn:PIO-PlatformIO">1</a></sup> 针对支持的平台都有以下功能支撑：</p>

<ul>
<li>支持指定框架的基于脚本的编译构建系统</li>
<li>针对各公司常规开发板的预配置</li>
<li>提供多架构的构建工具及相关工具链的支持</li>
</ul>

<p>PIO 目前支持的平台分为嵌入式和桌面两大类。</p>

<ul>
<li><p>嵌入式平台</p>

<ul>
<li><a href="https://docs.platformio.org/en/latest/platforms/aceinna_imu.html" target="_blank">Aceinna IMU</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/atmelavr.html" target="_blank">Atmel AVR</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/atmelsam.html" target="_blank">Atmel SAM</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/espressif32.html" target="_blank">Espressif 32</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/espressif8266.html" target="_blank">Espressif 8266</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/freescalekinetis.html" target="_blank">Freescale Kinetis</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/infineonxmc.html" target="_blank">Infineon XMC</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/intel_arc32.html" target="_blank">Intel ARC32</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/intel_mcs51.html" target="_blank">Intel MCS-51 (8051)</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/kendryte210.html" target="_blank">Kendryte K210</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/lattice_ice40.html" target="_blank">Lattice iCE40</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/maxim32.html" target="_blank">Maxim 32</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/microchippic32.html" target="_blank">Microchip PIC32</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/nordicnrf51.html" target="_blank">Nordic nRF51</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/nordicnrf52.html" target="_blank">Nordic nRF52</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/nxplpc.html" target="_blank">NXP LPC</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/riscv_gap.html" target="_blank">RISC-V GAP</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/samsung_artik.html" target="_blank">Samsung ARTIK</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/sifive.html" target="_blank">SiFive</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/siliconlabsefm32.html" target="_blank">Silicon Labs EFM32</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/ststm32.html" target="_blank">ST STM32</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/ststm8.html" target="_blank">ST STM8</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/teensy.html" target="_blank">Teensy</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/timsp430.html" target="_blank">TI MSP430</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/titiva.html" target="_blank">TI TIVA</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/wiznet7500.html" target="_blank">WIZNet W7500</a></li>
</ul></li>

<li><p>桌面平台</p>

<ul>
<li><a href="https://docs.platformio.org/en/latest/platforms/native.html" target="_blank">Native</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/linux_arm.html" target="_blank">Linux ARM</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/linux_i686.html" target="_blank">Linux i686</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/linux_x86_64.html" target="_blank">Linux x86_64</a></li>
<li><a href="https://docs.platformio.org/en/latest/platforms/windows_x86.html" target="_blank">Windows x86</a></li>
</ul></li>
</ul>

<p>上面也有前面文章中使用到的 ST STM32，Atmel AVR 一般指的就是 Arduino 系列开发板使用的芯片，说到 Arduino ，它其实就是一个完整的生态，提供开源的硬件开发板的设计以及 Arduino 统一的软件开发包就是所谓的 Frameworks。</p>

<h3 id="frameworks">Frameworks</h3>

<p>上面已经提到 Frameworks 其实就是类似于 SDK 的一个东西，全世界最有名的 Arduino 有自家的一套 SDK，那就是 Arduino，框架基本特征就是提供一整套一致的 API 的集合，本质是一个官方或第三方提供的软件库。</p>

<p>因为 Arduino 极具影响力，所以很多芯片平台也都有了自己的 Arduino 框架，现在 Arduino 框架平台支持的平台有很多：Atmel AVR、Atmel SAM、Espressif 32、Espressif 8266、Infineon XMC、Intel ARC32、Kendryte K210、Microchip PIC32、Nordic nRF51、Nordic nRF52、T STM32、ST STM8 、Teensy、TI MSP430  、TI TIVA <sup class="footnote-ref" id="fnref:Arduino-https-do"><a href="#fn:Arduino-https-do">2</a></sup>。</p>

<p>反过来讲，一个平台有可能支持多个不同开发框架，比如 <strong>ST STM32</strong> 支持的开发框架有：Arduino、CMSIS、libOpenCM3、mbed、SPL、STM32Cube<sup class="footnote-ref" id="fnref:stm32-https-docs"><a href="#fn:stm32-https-docs">3</a></sup>。</p>

<p>PIO 支持的框架也是有很多，总有适合你的：</p>

<ul>
<li>Arduino</li>
<li>ARTIK SDK</li>
<li>CMSIS</li>
<li>ESP8266 Non-OS SDK</li>
<li>ESP8266 RTOS SDK</li>
<li>ESP-IDF</li>
<li>Freedom E SDK</li>
<li>Kendryte FreeRTOS SDK</li>
<li>Kendryte Standalone SDK</li>
<li>libOpenCM3</li>
<li>mbed</li>
<li>PULP OS</li>
<li>Pumbaa</li>
<li>Simba</li>
<li>SPL</li>
<li>STM32Cube</li>
<li>Tizen RT</li>
<li>WiringPi</li>
</ul>

<p>详见：<a href="https://docs.platformio.org/en/latest/frameworks/index.html" target="_blank">https://docs.platformio.org/en/latest/frameworks/index.html</a></p>

<h3 id="boards">Boards</h3>

<p>PIO 支持绝大部分流行的开发板，比如 Arduino 的全系开发板、STM32 的 Nucleo 和 Discovery 系列评估板。有太多太多了，这里就没必要一一罗列了，可以查看下面的链接了解更多关于开发板的支持列表：</p>

<p><a href="https://docs.platformio.org/en/latest/boards/index.html" target="_blank">https://docs.platformio.org/en/latest/boards/index.html</a></p>

<p>PIO 针对支持的开发板都提供完整的项目生成脚本，新建项目从未如此快捷和简单！</p>

<h2 id="新建项目">新建项目</h2>

<p>这里我们以新建一个 <strong>Arduino Leonardo</strong> 的项目为例。</p>

<ul>
<li><p>打开 PIO Home：打开新的 VSCode 的窗口，点击左下角状态栏的第三个小房子按钮，就能打开 PIO Home 页面了：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190818190630-mBE3x7.jpg" alt="" /></p></li>

<li><p>点击项目操作按钮的 <strong>+ New Project</strong>，在弹窗中分别填入或选择 Name、Board、Framework 点击 Finish：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190818192413-24rRf1.jpg" alt="" /></p></li>

<li><p>稍作等待，PIO 会自动根据选择的 Board 和 Framework 配置工程并且下载需要用到的编译工具，需要的编译依赖什么的 PIO 通通帮我们搞定，一段时间过后项目工程就新建完成了，打开 <code>src</code> 文件夹下的 <code>main.cpp</code> 如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190818193026-lz9O9C.png" alt="" /></p></li>
</ul>

<h2 id="项目文件结构">项目文件结构</h2>

<p>项目文件结构要了解一下，方便后期自己手动管理项目。</p>

<ul>
<li><strong>.pio</strong>，存放工程编译产生的文件</li>
<li><strong>.vscode</strong>, 存放针对工程定制化的 vscode 配置文件</li>
<li><strong>include</strong>，存放统一管理的 h 头文件</li>
<li><strong>lib</strong>，存放自己编写的库文件</li>
<li><strong>src</strong>，存放工程项目的 C/C++ 源文件</li>
<li><strong>test</strong>，存放工程项目的测试文件，一般用不到</li>
<li><strong>.gitignore</strong>，git 仓库的忽略文件，方便 git 进行工程项目的版本控制</li>
<li><strong>travis.yml</strong>，持续集成的配置文件，一般用不到</li>
<li><strong>platformio.ini</strong>，项目的核心配置文件，这个会经常用到，所以得了解其中可用的配置项<sup class="footnote-ref" id="fnref:platformio-ini-P"><a href="#fn:platformio-ini-P">4</a></sup></li>
</ul>

<h2 id="编译和上传">编译和上传</h2>

<p>新建了项目工程之后，就是进行开发了，必然要用到编译代码，要将编译生成的二进制文件上传到开发板的芯片中。</p>

<p>为了看到效果，我们编写一段让板载 LED 闪动的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// put your setup code here, to run once:
</span><span class="c1"></span>  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED_BUILTIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// put your main code here, to run repeatedly:
</span><span class="c1"></span>  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_BUILTIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_BUILTIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>在这之前有必要了解一下 PIO 的工具栏按钮：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190818195923-OYxNoh.jpg" alt="" /></p>

<p><strong>Tip:</strong></p>

<p>如果使用 Arduino 框架代码中，一定要包含头文件 <code>Arduino.h</code>。</p>

<h3 id="编译项目工程">编译项目工程</h3>

<p>将上面的代码录入 <code>src</code> 目录下的 <code>main.cpp</code> 文件中，看文件名就知道使用的是 c++ 编程语言了。多种方式可以触发编译，比如笔者经常用的两种方式：</p>

<ul>
<li>点击上面截图底部中工具栏的第二个对号图标</li>
<li>按下组合键 <code>CTRL</code> + <code>ALT</code> + <code>B</code></li>
</ul>

<p>还有两种方式可以触发编译任务：</p>

<ul>
<li>按下组合键 <code>CTRL</code> + <code>SHIFT</code> + <code>P</code> (macOS 下是 <code>COMMAND</code> + <code>SHIFT</code> + <code>P</code>)，然后输入关键字 <strong>platformio</strong>，选择 <strong>Build</strong></li>
<li>点击窗口左边栏的蚂蚁头的图标会打开 PlatformIO 的工具栏，点击其中的 <strong>Build</strong></li>
</ul>

<p>顺利的话，触发了编译，很快就会在终端窗口提示编译完成：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; Executing task: platformio run &lt;

Processing leonardo <span class="o">(</span>platform: atmelavr<span class="p">;</span> board: leonardo<span class="p">;</span> framework: arduino<span class="o">)</span>
------------------------------------------------------------------------------------
Verbose mode can be enabled via <span class="sb">`</span>-v, --verbose<span class="sb">`</span> option
CONFIGURATION: https://docs.platformio.org/page/boards/atmelavr/leonardo.html
PLATFORM: Atmel AVR <span class="m">1</span>.15.0 &gt; Arduino Leonardo
HARDWARE: ATMEGA32U4 16MHz, <span class="m">2</span>.50KB RAM, 28KB Flash
PACKAGES: toolchain-atmelavr <span class="m">1</span>.50400.190710 <span class="o">(</span><span class="m">5</span>.4.0<span class="o">)</span>, framework-arduinoavr <span class="m">4</span>.1.1
LDF: Library Dependency Finder -&gt; http://bit.ly/configure-pio-ldf
LDF Modes: Finder ~ chain, Compatibility ~ soft
Found <span class="m">7</span> compatible libraries
Scanning dependencies...
No dependencies
Checking size .pio/build/leonardo/firmware.elf
Memory Usage -&gt; http://bit.ly/pio-memory-usage
DATA:    <span class="o">[=</span>         <span class="o">]</span>   <span class="m">5</span>.8% <span class="o">(</span>used <span class="m">149</span> bytes from <span class="m">2560</span> bytes<span class="o">)</span>
PROGRAM: <span class="o">[=</span>         <span class="o">]</span>  <span class="m">14</span>.4% <span class="o">(</span>used <span class="m">4130</span> bytes from <span class="m">28672</span> bytes<span class="o">)</span>
<span class="o">============================</span> <span class="o">[</span>SUCCESS<span class="o">]</span> Took <span class="m">0</span>.66 <span class="nv">seconds</span> <span class="o">============================</span></code></pre></div>
<h3 id="上传">上传</h3>

<p>先把手头的 Arduino Leonardo 开发板与电脑连接，直接触发上传任务即可，甚至不用自己去选择接口，PlatformIO 会自动查找与电脑连接的端口进行判断然后上传程序，笔者经常会用到的触发方式：</p>

<ul>
<li>组合键 <code>CTRL</code> + <code>ALT</code> + <code>U</code></li>
<li>点击窗口状态栏中 PIO 工具栏的第三个按钮<strong>→</strong></li>
</ul>

<p>第一次上传程序的时候，PIO 往往会先根据板子芯片对应的平台选择合适的上传工具包，所以第一次上传可能需要等一会儿，顺利的话也会在终端窗口看到 <strong>Sucess</strong> 的消息，同时会看到 Leonardo 板载 LED 开始闪烁：</p>

<video src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20190818232501-Z84ehL.mp4" controls="controls" width="100%">Blink</video>

<h2 id="总结">总结</h2>

<p>PIO 让新建芯片开发的项目工程变得异常简单，只需几小步就可以完成，另外本文也简单说了一下程序的编译和上传操作，同样简单方便！希望本文能够帮助想要体会 PlatformIO 魅力的朋友！</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:PIO-PlatformIO">PIO 是 PlatformIO 的简称，后面系列文章会经常使用这个简称 <a class="footnote-return" href="#fnref:PIO-PlatformIO"><sup>[return]</sup></a></li>
<li id="fn:Arduino-https-do">更多关于 Arduino 框架的信息参考：<a href="https://docs.platformio.org/en/latest/frameworks/arduino.html" target="_blank">https://docs.platformio.org/en/latest/frameworks/arduino.html</a> <a class="footnote-return" href="#fnref:Arduino-https-do"><sup>[return]</sup></a></li>
<li id="fn:stm32-https-docs">更多关于 stm32 单片机开发平台的信息参考：<a href="https://docs.platformio.org/en/latest/platforms/ststm32.html" target="_blank">https://docs.platformio.org/en/latest/platforms/ststm32.html</a> <a class="footnote-return" href="#fnref:stm32-https-docs"><sup>[return]</sup></a></li>
<li id="fn:platformio-ini-P">详见：<a href="https://docs.platformio.org/en/latest/projectconf.html" target="_blank">“platformio.ini” (Project Configuration File)</a> <a class="footnote-return" href="#fnref:platformio-ini-P"><sup>[return]</sup></a></li>
</ol>
</div>
]]></content>
		</item>
		
		<item>
			<title>PlatformIO IDE(VScode) 下调试 STM32 平台程序</title>
			<link>https://www.smslit.top/2019/08/05/platformio-debug/</link>
			<pubDate>Mon, 05 Aug 2019 17:17:42 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/08/05/platformio-debug/</guid>
			<description>PlatformIO 系列文章 stm32开发新方式-platformio 中最后提到说 PlatformIO 限制了免费用户调试程序的功能，最近发现 PlatformIO 已经免费开发程序调试功能，所以现在</description>
			<content type="html"><![CDATA[

<p><strong>PlatformIO</strong> 系列文章 <a href="/2017/11/08/stm32InPIO-start/#调试配置" target="_blank"><strong>stm32开发新方式-platformio</strong></a> 中最后提到说 PlatformIO 限制了免费用户调试程序的功能，最近发现 PlatformIO 已经免费开发程序调试功能，所以现在我们可以使用内建支持更好的方式调试我们的 ST MCU 的程序了，那今天我们就聊一下这一块内容。</p>

<p>官方称其为 PIO Unified Debugger，很好理解，就是统一的调试器，意思是凡是 PIO 支持的可调式的 MCU 开发平台均可以使用统一功能的调试器，PIO 跨平台的特性仍然支持程序调试，也就是说在 windows、linux和 macOS 下均可以得到相同的开发体验。</p>

<blockquote>
<p>You should have PIO Account to work with PIO Unified Debugger. A registration is FREE.</p>
</blockquote>

<p>官方说明免费使用这个调试功能需要登录一个 PIO 账户，这个很简单嘛，注册一个然后在 VSCode 的 PIO IDE 中登录即可，这可能是唯一的限制了！</p>

<h2 id="功能特性">功能特性</h2>

<p>官方文档中提到 VScode 搭建的 PIO 开发环境可以提供最强大的调试功能特性，包括以下：</p>

<ul>
<li><strong>局部、全局和静态变量的浏览器</strong> (Local, Global, and Static Variable Explorer)</li>
<li><strong>条件断点</strong> (Conditional Breakpoints)</li>
<li><strong>表达式监控</strong> (Expressions and Watchpoints)</li>
<li><strong>通用寄存器检阅</strong> (Generic Registers)</li>
<li><strong>外设寄存器检阅</strong> (Peripheral Registers)</li>
<li><strong>内存数据检阅器</strong> (Memory Viewer)</li>
<li><strong>汇编检阅</strong> (Disassembly)</li>
<li><strong>多线程支持</strong> (Multi-thread support)</li>
<li><strong>调试会话的热重启和激活</strong> (A hot restart of an active debugging session)</li>
</ul>

<p>以下为 <strong>genericSTM32F103C8</strong> 开发板使用 Arduino 开发框架时调试程序时的界面：</p>

<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5ukpd0n9wj31hc0u0q80.jpg" alt="" /></p>

<h2 id="实践">实践</h2>

<p>下面我们就以 <strong>genericSTM32F103C8</strong> 开发板使用 Arduino 开发框架为例讲解一下，调试程序是多么的简单。</p>

<h3 id="前提条件">前提条件</h3>

<h4 id="开发环境">开发环境</h4>

<ul>
<li>已经安装 vscode</li>
<li>vscode 已经安装 PlatformIO IDE 插件</li>
</ul>

<p>上述条件满足后，打开 vscode 新的窗口，会如下图中所示，左边栏多出 PlatformIO 的logo，以及最下边状态栏左边有个小房子的图标：</p>

<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5ul9bsjubj31hc0u0go1.jpg" alt="" /></p>

<h4 id="硬件">硬件</h4>

<ul>
<li>一个 stm32f103c8t6 的最小系统板</li>
<li>stlink v2 调试器</li>
</ul>

<h4 id="pio-账户">PIO 账户</h4>

<p>如果没有 PIO 账户那就先注册一个，打开 vscode 点击上图中提到的小房子的图标就会打开 PlatformIO 的管理页面，点击右上角的 PIO Account 图标</p>

<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5uliezdtej302i02c0hn.jpg" alt="" /></p>

<p>此时会跳转到 PIO 账户登录页面，登录按钮下面有一个链接 <strong>create a new one</strong> ，点击一下即可进入注册页面：</p>

<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5ulnmveigj316i0u0wfn.jpg" alt="" /></p>

<p>输入自己的邮箱，点击注册按钮即可完成注册， PlatformIO 会自动生成一个密码发到你的邮箱，返回到登录页面输入邮箱和密码登录即可。</p>

<h3 id="新建项目">新建项目</h3>

<p>返回到 Home 页面，点击 New Project 按钮开始新建项目，这里项目名称定义为 <strong>c8t6Blink</strong>，一个控制 LED 闪烁的简单例子，Board 就选 <strong>STM32F103C8(20k RAM. 64k Flash)(Generic)</strong> ，然后使用 <strong>Arduino</strong> 框架，最后点击 Finish 即可创建项目：</p>

<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5um2h72phj316i0u0q4y.jpg" alt="" /></p>

<p>初次创建可能需要时间会长一点，会下载编译需要的一些依赖工具包，以后再创建相同平台项目的时候就很快了。</p>

<h3 id="编写程序">编写程序</h3>

<p>手头上这个最小系统板上的 LED 是 PB0 管脚控制的，硬件设计是低电平 LED 点亮，所以一个简单的闪灯程序如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define LED_PIN PB0
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// put your setup code here, to run once:
</span><span class="c1"></span>  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// put your main code here, to run repeatedly:
</span><span class="c1"></span>  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">900</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>点击底部状态栏左边的小对号图标就可以进行编译，编译完成后点击右边向右的箭头图标就可以烧写程序，初次上传烧写需要时间长一些，PIO 需要下载一些相关工具包，以后就是正常上传程序了，完成后就能看到程序正常运行，LED 闪了起来。</p>

<h3 id="调试程序">调试程序</h3>

<p>按下 <strong>F5</strong> 按键即可触发程序调试，本以为会出现类似本篇文章第一张图的样子，结果会出现以下错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">&gt; Executing task: platformio debug &lt;

Error: Please specify <span class="sb">`</span>debug_port<span class="sb">`</span> <span class="k">for</span> environment
终端进程已终止，退出代码: <span class="m">1</span>

终端将被任务重用，按任意键关闭。</code></pre></div>
<p>为什么会出现这个错误？原因很简单，PIO 不知道我们是用什么调试工具进行程序调试，所以需要在项目配置文件 <code>platformio.ini</code> 中指明一下我们使用 stlink 进行调试：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="k">[env:genericSTM32F103C8]</span>
<span class="na">platform</span> <span class="o">=</span> <span class="s">ststm32</span>
<span class="na">board</span> <span class="o">=</span> <span class="s">genericSTM32F103C8</span>
<span class="na">framework</span> <span class="o">=</span> <span class="s">arduino</span>
<span class="na">debug_tool</span> <span class="o">=</span> <span class="s">stlink</span></code></pre></div>
<p>此时点击 <strong>F5</strong> 就可以正常触发调试了，可以看到启动调试程序默认停到 main 中第一句。</p>

<ul>
<li>顶部会看到调试工具栏，可以实现调试会话的重启、程序启停、执行等操作按钮</li>
<li>可以在代码编辑器行号前面单击添加或删除断点</li>
<li>左侧调试工具区点击 <strong>PERIPHERALS</strong> 栏，可以查看所有外设寄存器配置，方便验证寄存器配置正确与否</li>
<li><strong>MEMORY</strong> 栏可以添加内存地址来查看指定字节的数据，方便验证指针数据</li>
<li><strong>监视</strong> 中可以添加监测变量，随时查看变量变化</li>
<li><strong>变量</strong> 中展示了所有当前断点可检阅的全局、局部以及静态变量</li>
<li><strong>调用堆栈</strong> 中展示了函数的调用层次</li>
<li>调试控制台的最下方可以输入 <strong>adb</strong> 命令，从而实现更强大的调试操作</li>
<li><strong>DISASSEMBLY</strong> 栏可以控制切换汇编窗口方便查看汇编代码</li>
</ul>

<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5ung40o74j31hc0u0wkt.jpg" alt="" /></p>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之 Windows 和 WindowController</title>
			<link>https://www.smslit.top/2019/04/01/macOS-dev-windows-and-windowcontroller/</link>
			<pubDate>Mon, 01 Apr 2019 08:20:10 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/04/01/macOS-dev-windows-and-windowcontroller/</guid>
			<description>本文带大家一起简单学习如何开发一个基于文档的 Cocoa 应用(document based Cocoa App)，并学习如何使用模态窗口(Modal Windows) 以及 macOS Sierra 支持的标签窗口</description>
			<content type="html"><![CDATA[

<p>本文带大家一起简单学习如何开发一个基于文档的 Cocoa 应用(document based Cocoa App)，并学习如何使用模态窗口(Modal Windows) 以及 macOS Sierra 支持的标签窗口(tabbed interface)。</p>

<h1 id="开发平台">开发平台</h1>

<ul>
<li>macOS 10.14.4</li>
<li>Swift 5</li>
<li>xcode 10.2</li>
</ul>

<h1 id="概述">概述</h1>

<p>所有 macOS 程序要呈现用户界面都是以 Windows 作为容器的，当然除了纯粹的命令行工具和菜单栏小工具。Windows 定义了 App 在屏幕中的活动区域，在这个区域内允许用户进行易于理解的多任务交互操作。macOS 应用最终可分为以下几种：</p>

<ul>
<li><p>单窗口的工具，比如计算器</p>

<figure>
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-single-Window.png" width="210px"/> 
</figure>
</li>

<li><p>单窗口的 library-style 应用，比如照片应用(Photos.app)</p>

<figure>
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-library-Style1.png" width="560px"/> 
</figure>
</li>

<li><p>基于文档的多窗口应用，比如文本编辑应用(TextEdit.app)</p>

<figure>
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-document-based1.png" width="640px"/> 
</figure>
</li>
</ul>

<p>不管属于哪一类的应用，几乎每一个 macOS 应用都是使用 MVC (Model-View-Controller) 构建的，这是 macOS 开发中核心的开发模式。</p>

<p>Cocoa 应用中，一个窗口是 <code>NSWindow</code> 类的一个实例(window 就是 view 的容器)，其与控制器紧密配合工作，而控制器是 <code>NSWIndowController</code> 的一个实例。在一个设计良好的应用中会发现通常窗口和控制器是一一对应的，而 MVC 模式中的第三个组成部分——模型(model)的使用会根据应用的类型和设计而不同。</p>

<p>在本文中我们会创建一个有点像 TextEdit 的应用，是 document based 的，我管它叫 <strong>5kmEditor</strong>，这个名字随便，只要您喜欢啥都行！在我们开发过程中，将会涉及到以下内容：</p>

<ul>
<li>窗口 和 窗口控制器</li>
<li>document 架构</li>
<li>NSTextView</li>
<li>模态窗口</li>
<li>菜单栏和菜单项</li>
</ul>

<h1 id="搞起">搞起</h1>

<p>启动 Xcode，按快捷键 <code>Shift</code> + <code>Command</code> + <code>n</code> ，新建工程，选择 macOS -&gt; Cocoa App，点击 Next：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2012.48.44.png" alt="" /></p>

<p>新出现的窗口中，勾选 <code>Create Document-Based Application</code>，应用的名称随意取，比如 <strong>5kmEditor</strong>，然后 <code>Document Extention</code> 这一项指定文件的扩展名，其决定以后应用保存文件的扩展名，比如十里指定的是 <code>5km</code>，可以不勾选包含测试，点击 Next：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2020.56.55.png" alt="" /></p>

<p>选择合适的目录，点击 <code>Create</code> 创建即可，创建成功后编译运行，你会看到类似下面的窗口：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2020.59.52.png" alt="" /></p>

<p>此时，按快捷键 <code>Command</code> + <code>n</code> 或者菜单栏点击 File -&gt; New，可以创建新的窗口如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-multi-windwos.png" alt="" /></p>

<h1 id="document-based-应用如何工作">Document-Based 应用如何工作</h1>

<p>上面也看到了这类应用的样子，下面花几分钟一起看一下 Document-Based 应用如何工作的。</p>

<h2 id="document-的结构">Document 的结构</h2>

<p>一个 Document 其实就是 <code>NSDocument</code> 的一个实例对象，文档模型 <code>NSDocument</code> 作为模型保存了文档的数据，同时负责文档窗口控制器 <code>NSWindowController</code> 的创建管理，它管理文档数据，负责文档打开时数据读取的管理和文档对象管理的数据保存到文件的处理，而文件有可能是在硬盘也有可能在 iCloud，均支持。</p>

<p>创建关联的 <code>NSWindowController</code> 负责展示文档的内容，内容视图最终相应处理用户对文档操作的各种交互事件。</p>

<p><code>NSDocumentController</code> 是一个单例对象，主要负责文档模型 <code>NSDocument</code> 的管理工作，维护系统中所有的文档模型 <code>NSDocument</code> 列表，控制多个文档窗口的激活切换，同时跟踪当前活动文档对象，最终结构图如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-document-arch.png" alt="" /></p>

<h2 id="禁用-document-的保存和打开">禁用 Document 的保存和打开</h2>

<p>Document-Based 应用的 Documnent 架构支持文件的保存和打开，但是需要定义 <code>Document</code> 类中自己具体实现，本文暂不涉及这部分内容，所以先禁用 Document 的保存和打开。</p>

<p>打开文件 <code>Document.swift</code>，会发现有两个函数是空的：</p>

<ul>
<li><code>data(ofType:)</code>: 用于写文件</li>
<li><code>read(from:ofType:)</code>: 用于读取文件</li>
</ul>

<p>同时还有一个函数是 <code>autosavesInPlace()-&gt;Bool</code>，更改返回值为 <code>false</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">override</span> <span class="kd">class</span> <span class="nc">var</span> <span class="n">autosavesInPlace</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span></code></pre></div>
<p>这样我们首先禁用了自动保存功能，下面我们需要禁用菜单栏 File 中的保存和打开菜单项。在这之前，我们运行程序，点击 File -&gt; Open ，竟然会弹出打开文件的窗口，很神奇，我们并没有实现打开呀，为什么会出现文件打开窗口呢？</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.23.37.png" alt="" /></p>

<p>其实是因为 Open 的菜单项绑定了具体的 Action，Action中实现了这些，所以我们只需要断开菜单项与 Action 的链接就可以禁用掉菜单项，视觉上的表现就是菜单栏相应菜单项会变灰色不可用。</p>

<p>打开 <code>Main.storyboard</code> ，找到 <code>Application Scene</code>，点击菜单栏中 File，选择其中的 <code>Open</code>，右击会看到所有的连接，点击 Sent Action 中连接右侧的 <code>x</code> 号，即可断开连接：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.34.42-1.png" alt="" /></p>

<p>同样的操作，分别将 <code>Save...</code>、<code>Save As...</code> 和 <code>Reverrt to Saved</code> 与相应的 Action 断开连接。</p>

<p>然后删除 <code>Open Recent</code> 菜单项，最后我们重写一下 <code>save(withDelegate:didSave:contexInfo:)</code> 方法，后面我们会用到，主要是添加一个错误🙅‍提醒窗口，打开 <code>Document.swift</code> 文件，在 <code>Document</code> 类中添加重写方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">override</span> <span class="kd">func</span> <span class="nf">save</span><span class="p">(</span><span class="n">withDelegate</span> <span class="n">delegate</span><span class="p">:</span> <span class="nb">Any</span><span class="p">?,</span> <span class="n">didSave</span> <span class="n">didSaveSelector</span><span class="p">:</span> <span class="nb">Selector</span><span class="p">?,</span> <span class="n">contextInfo</span><span class="p">:</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">userInfo</span> <span class="p">=</span> <span class="p">[</span><span class="n">NSLocalizedDescriptionKey</span><span class="p">:</span> <span class="s">&#34;Sorry, no saving implemented in this post. Click &#39;Do not save&#39; to quit!&#34;</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">error</span> <span class="p">=</span> <span class="n">NSError</span><span class="p">(</span><span class="n">domain</span><span class="p">:</span> <span class="n">NSOSStatusErrorDomain</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">unimpErr</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">:</span> <span class="n">userInfo</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">alert</span> <span class="p">=</span> <span class="n">NSAlert</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">alert</span><span class="p">.</span><span class="n">runModal</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p>运行程序，此时会看到菜单栏的相应菜单项已经禁用：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.41.27.png" alt="" /></p>

<h1 id="窗口显示">窗口显示</h1>

<p>上面新建文件的时候，我们发现新建文档的窗口完全覆盖了之前的文档窗口，然而这不是我们想要的结果，本节就聊一下怎么合理布局窗口的位置。进行改造前，我们需要新建一个 <code>NSWindowController</code> 的子类，然后添加相应的代码实现我们预期的功能。</p>

<h2 id="新建-nswindowcontroller-的子类">新建 NSWindowController 的子类</h2>

<p>工程导航栏选择 <code>5kmEditor</code>，按下快捷键 <code>Command</code> + <code>n</code>，就会弹出新建文件的导航窗口，选择 macOS -&gt; Source -&gt; Cocoa Class，点击 Next</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.58.08.png" alt="" /></p>

<p>取名为 <code>WindowController</code>，选择继承自 <code>NSWindowController</code>，不要勾选 <code>Also Create XIB file for user interface</code>，语言选择 <code>Swift</code> ，点击 Next，之后默认然后点击 Create 即可创建。</p>

<p>下一步需要确保 storyboard 中的 window 的控制器是我们刚定义的 <code>WindowController</code> 的实例，打开 <code>Main.storyboard</code> 点击 <code>Window Controller Scene</code> 中的 <code>Window Controller</code>，按快捷键 <code>Option</code> + <code>Command</code> + <code>3</code> ，在右侧显示的 <code>Identity Inspector</code> 中配置 Custom Class 为 <code>WindowController</code>，也就是刚刚创建的类：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2000.08.04.png" alt="" /></p>

<h2 id="层叠窗口">层叠窗口</h2>

<p>现在我们可以使新建的窗口层叠显示而不是覆盖显示，打开新建的 <code>WindowController.swift</code> 文件，添加以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">required</span> <span class="kd">init</span><span class="p">?(</span><span class="n">coder</span><span class="p">:</span> <span class="n">NSCoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">coder</span><span class="p">:</span> <span class="n">coder</span><span class="p">)</span>
    <span class="n">shouldCascadeWindows</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span></code></pre></div>
<p>只需要设置 <code>shouldCascadeWindows</code> 为 true 就可以实现层叠效果，运行程序测试一下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-cascade_windows.png" alt="" /></p>

<h2 id="以标签页显示">以标签页显示</h2>

<p>层叠效果很不错，但我们可以尝试一下其它的方式，比如从 macOS Sierra 开始新增加的 tabbed Windows，简单说就是新建的窗口以标签页显示。</p>

<p>打开 <code>Main.storyboard</code>，选中 <code>Window Controller scene</code> 下的 <code>Window</code> ，然后打开 Inspector 栏的 <code>Attributes Inspector</code> (可以按快捷键 <code>Option</code> + <code>Command</code> + <code>4</code>)，找到 <code>Tabbing Mode</code>，更改它的值为 <code>Preferred</code>:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2006.59.56.png" alt="" /></p>

<p>运行程序，然后按快捷键 <code>Command</code> + <code>n</code> 新建窗口，可以看到新的窗口以标签页的方式显示了：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2007.04.58.png" alt="" /></p>

<p>当我们运行程序的时候，macOS 会根据当前屏幕大小和应用请求窗口的大来决定应用窗口的显示位置和实际的大小，下面我们将学习两种方式控制应用窗口的显示位置和实际大小。</p>

<h2 id="使用-interface-builder-设置窗口显示位置">使用 Interface Builder 设置窗口显示位置</h2>

<p>首先我们需要先使用 Interface Builder 设置窗口的初始位置。</p>

<p>打开 <code>Main.storyboard</code>，选中 <code>Window Controller scene</code> 下的 <code>Window</code> ，然后打开 Inspector 栏的 <code>Size Inspector</code> (可以按快捷键 <code>Option</code> + <code>Command</code> + <code>5</code>)，找到 Initial Position，运行程序后的窗口就是按照这个设置初始位置的：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2007.28.32.jpg" alt="" /></p>

<p>其中 x 代表窗口到屏幕左边缘的距离，y 代表窗口到屏幕底边的距离，单位是 px，在 macOS 中应用的坐标原点在左下角，这与 iOS 中是不同的（iOS 使用的是 flipped 坐标系，其原点在左上角）。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-Window-position-1.png" alt="" /></p>

<p>我们可以点击上面 Size Inspector 中的窗口位置预览图中的红色 constrains，这会决定 macOS 显示应用窗口位置的设定，点击红色 Constrains 可以打开或关闭相关限制，同时会看到下面两个下拉框得值会改变，比如这里：</p>

<ul>
<li>取消上边和右边的红色限制，此时会看到下面两个下拉框的值分别变成 <code>Fixed From Left</code> 和 <code>Fixed From Bottom</code></li>
<li>设置初始的位置：x -&gt; 200, y -&gt; 200</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2009.45.16.png" alt="" /></p>

<p>此时重新编译运行应用，你会发现不管屏幕多大，只要尺寸允许范围内，应用的窗口会显示在离屏幕左边和底边均为 200 px 的位置。</p>

<p>⚠️: macOS 会记住 app 的窗口显示位置，所以需要先把应用完全退出，然后再编译运行就能看到修改的效果！</p>

<h2 id="代码实现对窗口显示位置的设置">代码实现对窗口显示位置的设置</h2>

<p>代码实现的话，需要在 window 加载之后进行设置，在 WindowsController 中重写的 windowDidLoad 方法中添加相关代码。</p>

<p>这次我们来点特别的，我们设置窗口显示在离屏幕顶边和左边均为 150px 的位置，打开 <code>WindowController.swift</code> 文件，在 <code>WindowController</code> 类中修改 windowDidLoad 方法内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">override</span> <span class="kd">func</span> <span class="nf">windowDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">windowDidLoad</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">window</span> <span class="p">=</span> <span class="n">window</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">screen</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">screen</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">offsetFromLeftOfScreen</span> <span class="p">=</span> <span class="n">CGFloat</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">offsetFromTopOFScreen</span> <span class="p">=</span> <span class="n">CGFloat</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">screenFrame</span> <span class="p">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">visibleFrame</span>
        <span class="kd">let</span> <span class="nv">offsetFromBottomOfScreen</span> <span class="p">=</span> <span class="n">screenFrame</span><span class="p">.</span><span class="n">maxY</span> <span class="o">-</span> <span class="n">window</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">offsetFromTopOFScreen</span>
        <span class="n">window</span><span class="p">.</span><span class="n">setFrameOrigin</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">offsetFromLeftOfScreen</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">offsetFromBottomOfScreen</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>上面代码主要完成以下工作：</p>

<ul>
<li>获取需要用到的 <code>NSWindow</code> 和 <code>NSScreen</code> 的实例</li>
<li>得到 screen 的 <code>visibleFrame</code></li>
<li>通过离顶边的距离计算得到离底边距离</li>
<li>设置 window 的远点坐标为 (offsetFromLeftOfScreen, offsetFromBottomOfScreen)</li>
</ul>

<p>选中之前显示的应用窗口，<code>Command</code> + <code>q</code> 完全退出应用，然后回到 Xcode 编译运行应用，会看到应用的窗口如期显示在指定的位置：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-positionDemo-1.png" alt="" /></p>

<h1 id="变身超-mini-富文本处理工具">变身超 mini 富文本处理工具</h1>

<p>Cocoa 有很多可以添加到 window 中的牛🐂的功能性 UI 控件，在本节我们将会用到 <code>NSTextView</code>，在这之前，我们需要了解 <code>NSWindow</code> 的 content view。</p>

<h2 id="content-view">content view</h2>

<p><code>contentView</code> 位于 window 中视图层次的根级，在这个视图中我们可以放置所有界面元素。另外，我们还能替换默认的 <code>contentView</code> 为我们自定义的视图，在这里我们就不做相关操作了，以后我们可能会用到！</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2010.58.22.png" alt="" /></p>

<h2 id="添加-text-view">添加 Text View</h2>

<p>打开 <code>Main.storyboard</code> 文件，找到 View Contorller Scene 下的 View Controller，其下的 View 中有个控价 <code>Your document contents here</code> ，将其删除，然后我们添加 Text View:</p>

<ul>
<li>按快捷键 <code>Shift</code> + <code>Command</code> + <code>l</code> 打开 <code>Object Library</code></li>

<li><p>搜索 Text View</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2019.34.32.png" alt="" /></p></li>

<li><p>将 <code>Rich Document Content Text View</code> 拖入 Content View 中</p></li>

<li><p>调整 <code>Rich Document Content Text View</code> 的大小和位置，最终使其四边分别与 <code>contentView</code> 的边缘贴齐</p></li>

<li><p>选中刚添加的 Text View 控件，然后点击底边的 <code>Resolve Auto Layout Issues</code> 按钮，选中 <code>Reset To Suggested Constrains</code></p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.38.53.png" alt="" /></p></li>

<li><p>添加限制之后的样子如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.39.14.png" alt="" /></p></li>
</ul>

<p>编译运行，可以看到刚添加的 Text View 了：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.39.25.png" alt="" /></p>

<p>在窗口的 Text View 中可以添加进行文本编辑了，也支持常用的快捷键，比如复制、粘贴、剪切、撤销、重做等。窗口中也出现了一组工具栏，支持字体设置、简单的段落设置等，同时菜单栏的 Format 的菜单项功能也是可用的，还支持查找替换。这一小节我们没有添加任何代码，就完成了一个简单的富文本编辑工具了，是不是炒🐔煎🍳！</p>

<h2 id="撤销和重做">撤销和重做</h2>

<p>在窗口中添加部分文本，已经可以完成基本的富文本编辑功能了，但是此时还不支持撤销和重做，我们需要添加支持。</p>

<ul>
<li>打开 <code>Main.storyboard</code> 文件，依次找到 <code>View Controller</code> -&gt; <code>View</code> -&gt; <code>Scroll View - Text View</code> -&gt; <code>Clip View</code>  -&gt; <code>Text View</code>，选中 <code>Text View</code></li>
<li>按下快捷键 <code>Option</code> + <code>Command</code> + <code>4</code> 打开 Attribute Inspector，勾选 <code>Undo</code> 复选框</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.45.04.png" alt="" /></p>

<p>此时运行程序，就支持 Undo 和 Redo 了！</p>

<p>在文本框添加文本以后，我们点击窗口关闭按钮，此时会提醒要不要保存文档：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.40.49.png" alt="" /></p>

<p>点击 save 按钮，会弹出一个警告窗口：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.02.36.png" alt="" /></p>

<p>是不是对里面的内容很熟悉，这就是前面添加的 save 方法中的错误信息。</p>

<h1 id="模态窗口-modal-window">模态窗口(Modal Window)</h1>

<p>模态窗口是一种特殊的窗口，一旦显示就会独占用户的所有操作事件，一直到它被关闭，其它窗口才能响应用户的操作。</p>

<p>显示模态窗口有三种方法：</p>

<ul>
<li>以一个普通窗口的形式显示，使用 <code>NSApplication.runModal(for:)</code> 触发显示</li>
<li>以 Modal sheet 的形式显示， 调用 <code>NSWindow.beginSheet(_:completionHandler:)</code> 显示窗口</li>
<li>通过模态会话的形式，本文暂不涉及这种高级的方法</li>
</ul>

<p>其实，文档的保存和打开窗口就是模态窗帘的好例子，就像上面关闭窗口时弹出的提示保存的窗口，它出现在窗口的顶部，这就是 Modal Sheet，在本文也不讲这种模态窗口，下面我们一起实现一个显示字数和段落统计的模态窗口，它是以一个正常窗口形式显示的。</p>

<h2 id="添加一个新的窗口">添加一个新的窗口</h2>

<p>打开 <code>Main.storyboard</code> 文件，按快捷键 <code>Shift</code> + <code>Command</code> + <code>l</code> 打开 Object Library，搜索 Window Controller，拖拽 <code>Window Controller</code> 进入画布，这会生成两个场景：Window Controller Scene 和 View Controller Scene。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2008.46.15.jpg" alt="" /></p>

<p>选中刚添加的 WIndow Controller Scene 中的 Window，按快捷键 <code>Option</code> + <code>Command</code> + <code>5</code>，打开 Size Inspector，调整其宽为 300，高为 150。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2008.54.23.png" alt="" /></p>

<p>继续选中 Window，按快捷键 <code>Option</code> + <code>Command</code> + <code>4</code> 打开 Atrribute Inspector，取消 Close、Resize 和 Minimise 控件复选框的勾选，设置标题为 <code>Word Count</code>。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.02.30.png" alt="" /></p>

<p>窗口 Close 按钮会造成一个 bug：当点击这个按钮后虽然窗口已经关闭，但是应用因为没有调用 <code>stopModal</code> 方法而一直保留在模态状态，这就很尴尬了！</p>

<p>另外，不保留 Minimise 和 Resize 按钮是为了遵循 Apple 的 <a href="https://developer.apple.com/design/human-interface-guidelines/macos/overview/themes/" target="_blank">Human Interface Guidelines (HIG)</a>。</p>

<p>选中新添加的 View Controller Scene 中的 View，按下快捷键 <code>Option</code> + <code>Command</code> + <code>5</code> 打开 Size Inspector，设置宽为 300 高为 150。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.10.18.png" alt="" /></p>

<h2 id="配置-word-count-窗口">配置 Word Count 窗口</h2>

<p><code>Shift</code> + <code>Command</code> + <code>l</code> 打开 Object Library 拖拽 4 个 label 到 View 中。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.18.39.png" alt="" /></p>

<p>改变四个 label 的标题分别为：<strong>Word Count</strong>、<strong>Paragraph Count</strong>、<strong>0</strong> 和 <strong>0</strong>，同时设置它们都是右对齐，调整它们的宽为 120，这里我们不涉及自动布局，可能会出现几个警告，先不管它们。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.37.07.png" alt="" /></p>

<p>从 Object Library 推拽一个 Push Button 到 View 中，更改其标题为 OK，手动调整所有控件布局到合适的位置。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.41.34.png" alt="" /></p>

<h2 id="创建-word-count-的-view-controller-的类">创建 Word Count 的 View Controller 的类</h2>

<p><code>Command</code> + <code>n</code> 会打开一个文件新建的导航窗口，我们选择 macOS -&gt; Source -&gt; Cocoa Class，新出现的窗口中输入类的名称为 <code>WordCountViewController</code>，<strong>Subclass of</strong> 设置为 <code>NSViewController</code>，取消勾选 <code>Also create XIB for user interface</code></p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.49.32.png" alt="" /></p>

<p>点击 Next 创建新的文件。</p>

<p>打开 <code>Main.storyboard</code>，选中新添加的 View Controller，按快捷键 <code>Option</code> + <code>Command</code> + <code>3</code> 打开 Identity Inspector，选择 class 为刚添加的 <code>WordCountViewController</code> 类。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.52.17.png" alt="" /></p>

<h2 id="绑定计数-label-与-view-controller">绑定计数 label 与 View Controller</h2>

<p>打开新建的 <code>WordCountViewController.swift</code> 文件，在 WordCountViewCOntroller 中添加属性如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@objc</span> <span class="kr">dynamic</span> <span class="kd">var</span> <span class="nv">wordCount</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kr">@objc</span> <span class="kr">dynamic</span> <span class="kd">var</span> <span class="nv">paragraphCount</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span></code></pre></div>
<p>⚠️：两个属性添加了 <code>@objc dynamic</code> 修饰符是为了有效实现 <code>Cocoa Bindings</code><sup class="footnote-ref" id="fnref:Cocoa-Bindings-U"><a href="#fn:Cocoa-Bindings-U">1</a></sup>，否则绑定无效运行时会报错。</p>

<p>打开 <code>Main.storyboard</code> 选中与 Word Count 的 label 相对应的数字 label，按下快捷键 <code>Option</code> + <code>Command</code> + <code>7</code> 打开 Bindings Inspector:</p>

<ul>
<li>点击 <strong>Value</strong> 左边的小三角，展开 <strong>Value</strong></li>
<li><strong>Bind to</strong> 的下拉框选择 <code>Word Count View Controller</code></li>
<li>勾选 <strong>Bind to</strong></li>
<li><strong>Model Key Path</strong> 输入 <code>wordCount</code></li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.11.47.png" alt="" /></p>

<p>同样的步骤，与 Paragraph Count 的 label 相对应的数字 label 绑定到 <code>paragraphCount</code>:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.17.58.png" alt="" /></p>

<p>下一步设置 Window Controller 的 <strong>Storyboard ID</strong>。</p>

<p>选择 <strong>Word Count Window</strong> 的 <strong>Window Controller</strong>，然后按快捷键 <code>Option</code> + <code>Command</code> + <code>3</code> 打开 Identity Inspector，更改 <strong>Storyboard ID</strong> 的值为 <code>Word Count Window Controller</code>。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.20.24.png" alt="" /></p>

<h2 id="显示和关闭模态窗口">显示和关闭模态窗口</h2>

<p>前面的准备工作做足了，那本节讲讲如何召唤和轰走模态窗口。</p>

<h3 id="出来吧-模态窗口">出来吧，模态窗口</h3>

<p>打开 <strong>ViewController.swift</strong> 文件，在类中添加以下属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBOutlet</span> <span class="kd">var</span> <span class="nv">text</span><span class="p">:</span> <span class="n">NSTextView</span><span class="o">!</span></code></pre></div>
<p>同时添加以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">showWordCountWindow</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">AnyObject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1</span>
    <span class="kd">let</span> <span class="nv">storyboard</span> <span class="p">=</span> <span class="n">NSStoryboard</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&#34;Main&#34;</span><span class="p">,</span> <span class="n">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">wordCountWindowController</span> <span class="p">=</span> <span class="n">storyboard</span><span class="p">.</span><span class="n">instantiateController</span><span class="p">(</span><span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&#34;Word Count Window Controller&#34;</span><span class="p">)</span> <span class="k">as</span><span class="o">!</span> <span class="n">NSWindowController</span>

    <span class="k">if</span> <span class="kd">let</span> <span class="nv">wordCountWindow</span> <span class="p">=</span> <span class="n">wordCountWindowController</span><span class="p">.</span><span class="n">window</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">textStorage</span> <span class="p">=</span> <span class="n">text</span><span class="p">.</span><span class="n">textStorage</span> <span class="p">{</span>

        <span class="c1">// 2</span>
        <span class="kd">let</span> <span class="nv">wordCountViewController</span> <span class="p">=</span> <span class="n">wordCountWindow</span><span class="p">.</span><span class="n">contentViewController</span> <span class="k">as</span><span class="o">!</span> <span class="n">WordCountViewController</span>
        <span class="n">wordCountViewController</span><span class="p">.</span><span class="n">wordCount</span> <span class="p">=</span> <span class="n">textStorage</span><span class="p">.</span><span class="n">words</span><span class="p">.</span><span class="bp">count</span>
        <span class="n">wordCountViewController</span><span class="p">.</span><span class="n">paragraphCount</span> <span class="p">=</span> <span class="n">textStorage</span><span class="p">.</span><span class="n">paragraphs</span><span class="p">.</span><span class="bp">count</span>

        <span class="c1">// 3</span>
        <span class="n">NSApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">runModal</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="n">wordCountWindow</span><span class="p">)</span>
        <span class="c1">// 4</span>
        <span class="n">wordCountWindow</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>打开 <strong>Main.storyboard</strong> 文件，选中添加 Text View 的 View Controller，按住 <code>Ctrl</code> 键，点击 View Controller 按钮，不松手拖动至 Text View 上松手，此时会弹出一个绑定选择框，里面就包含了我们刚添加的 text 属性，点击它，这就完成了 Text View 控件与 text 属性的绑定</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.34.58.png" alt="" /></p>

<p>上面添加的方法，这里一步一步的说明一下：</p>

<ol>
<li>使用之前配置的 <strong>Storyboard ID</strong> 实例化一个 <strong>Word Count Window Controller</strong> 对象</li>
<li>从 text view 的 storage 对象中获取字数统计和段落统计，将值设置到 <strong>wordCountViewController</strong> 的两个属性 <code>wordCount</code> 和 <code>paragraphCount</code></li>
<li>模态方式显示 word count 窗口</li>
<li>一旦模态状态结束就关闭模态窗口，这里需要注意，只要模态不结束这一句就不会执行</li>
</ol>

<h3 id="消失吧-模态窗口">消失吧，模态窗口</h3>

<p>这里我们需要添加结束模态的实现，打开文件 <strong>WordCountViewController.swift</strong>，添加以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">dismissWordCountWindow</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="n">NSButton</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">stopModal</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p>下面我们将此方法与上面添加的 OK 按钮进行绑定。</p>

<p>打开 <code>Main.storyboard</code>，选中 OK 按钮，点击它，同时按住 <code>Ctrl</code> 键，拖动鼠标至 <strong>Word Count View Controller</strong> 的按钮上，在弹出的绑定窗口上选择刚添加的方法 <code>dismissWordCountWindow</code> 即可完成绑定。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2011.01.15.png" alt="" /></p>

<h3 id="添加召唤模态的符咒">添加召唤模态的符咒</h3>

<p>这里我们以菜单栏的菜单项的方式触发模态窗口。</p>

<p>打开 <strong>Main.storyboard</strong> 文件，找到 <strong>Main Menu</strong>，点击展开 <strong>Edit</strong>，然后进行以下操作：</p>

<ol>
<li><code>Shift</code> + <code>Command</code> + <code>l</code> 打开 Object Library，搜索 <code>Menu Item</code>，拖动到最下面的位置，添加一个新的菜单项，选中它</li>
<li><code>Option</code> + <code>Command</code> + <code>4</code> 打开它的 <strong>Attribute Inspector</strong>，更改标题为 <strong>Word Count</strong>，同时配置快捷键为 <strong>⌘K</strong></li>
</ol>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2011.20.01.png" alt="" /></p>

<p>下面我们需要为其绑定上面定义的方法 <code>showWordCountWindow</code>，点击菜单项 <strong>Word Count</strong>，同时按住 <code>Ctrl</code> 键，拖动至 <strong>Application Scene</strong> 下的 <strong>First Responder</strong> 上松手，在弹出的列表中找到方法 <code>showWordCountWindow</code>，选择它，这就完成了触发模态的绑定：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2011.30.40-1.png" alt="" /></p>

<h3 id="召唤模态">召唤模态</h3>

<p>编译运行程序，在窗口中输入一些内容，比如：</p>

<blockquote>
<p>望岳</p>

<p>唐代：杜甫</p>

<p>岱宗夫如何？齐鲁青未了。</p>

<p>造化钟神秀，阴阳割昏晓。</p>

<p>荡胸生曾云，决眦入归鸟。</p>

<p>会当凌绝顶，一览众山小。</p>
</blockquote>

<p>菜单栏 Edit -&gt; Word Count (或者按快捷键 <code>Command</code> + <code>k</code>) 就能打开统计字数的模态窗口。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2013.13.18.png" alt="" /></p>

<p>点击 OK 就可以“轰走”模态窗口了。</p>

<h1 id="总结">总结</h1>

<p><a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-5kmEditor.zip" target="_blank">点我</a>可以下载本文中的工程。本文涉及到了以下内容：</p>

<ul>
<li>MVC 的设计模式</li>
<li>多窗口应用的实现</li>
<li>Interface Builder 和 代码 两种方式控制窗口位置</li>
<li>控件与类属性的绑定，控件 Action 与类方法的绑定</li>
<li>窗口形式的 macOS 的常规开发姿势</li>
<li>如何代码控制显示模态窗口</li>
<li>富文本编辑的简单实现</li>
</ul>

<p>希望对大家学习 macOS 开发有所帮助！感谢您的阅读！</p>

<h1 id="参考">参考</h1>

<p><a href="https://www.raywenderlich.com/613-windows-and-windowcontroller-tutorial-for-macos" target="_blank">Windows and WindowController Tutorial for macOS</a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:Cocoa-Bindings-U">Cocoa Bindings 是 UI 开发中一个强大的技术，主要用于数据与 UI 的绑定，可以阅读 <a href="https://www.raywenderlich.com/141297/cocoa-bindings-macos" target="_blank"> Cocoa Bindings on macOS </a> 了解更多相关内容，后面有时间十里会专门写一篇相关的文章与大家一起学习！ <a class="footnote-return" href="#fnref:Cocoa-Bindings-U"><sup>[return]</sup></a></li>
</ol>
</div>
]]></content>
		</item>
		
		<item>
			<title>PlatformIO 是什么</title>
			<link>https://www.smslit.top/2019/03/30/what-is-pio/</link>
			<pubDate>Sat, 30 Mar 2019 17:45:14 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/30/what-is-pio/</guid>
			<description>PlatformIO is an open source ecosystem for IoT development. Cross-platform IDE and unified debugger. Remote unit testing and firmware updates. PlatformIO 是一个用于物联网开发的开源生态系统。它提供跨平台的开发环境和统一的调试器，还支持远程单元测试和固件</description>
			<content type="html"><![CDATA[

<blockquote>
<p>PlatformIO is an open source ecosystem for IoT development.</p>

<p>Cross-platform IDE and unified debugger.</p>

<p>Remote unit testing and firmware updates.</p>
</blockquote>

<p><a href="https://platformio.org" target="_blank">PlatformIO</a> 是一个用于物联网开发的开源生态系统。它提供跨平台的开发环境和统一的调试器，还支持远程单元测试和固件更新&hellip;</p>

<h1 id="platformio-简介">PlatformIO 简介</h1>

<figure class="right">
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-30-platformio-ide-vscode.png"/> 
</figure>


<p>PlatformIO 是独立于平台运行的，实际上它只依赖于 python，然而 python 在 macOS、linux 和 windows 都能完美适配. 也就是说 PlatformIO 的工程从一个电脑很容易迁移到另一个电脑，只需要拷贝再使用 PlatformIO 就能完美打开，不管团队中的成员使用什么操作系统 PlatformIO 可以让工程共享变得异常简单. 除此之外, PlatformIO 不仅可以在笔记本和台式机上运行，同样可以运行在没有显示桌面的服务器。PlatformIO 的核心(PlatformIO Core) 就是一个终端程序, 它能配合您喜欢的多款云 IDE、桌面 IDE 或者 通用代码编辑器构建 PlatformIO 的 IDE，比如 Atom, CLion, Eclipse, Emacs, NetBeans, Qt Creator, Sublime Text, VIM, Visual Studio, VSCode, etc.</p>

<p>目前官方推荐的 IDE 使用方案就是 VSCode + PlatformIO IDE 插件，界面如右图：</p>

<ul>
<li>PIO 统一的调试器，可以零配置的对支持硬件调试的的嵌入式开发板进行调试工作，调试器支持很多的架构和开发平台</li>
<li>跨平台的代码构建系统对系统软件没有额外的依赖: 600+ 嵌入式开发板, 30+ 开发平台, 15+ 框架</li>
<li>C/C++ 智能代码补全，语法检查，快速重构以及代码跳转满足快速专业的开发需求</li>
<li>VSCode 提供多工程和文件管理的支持和统一而流畅的使用体验，并且支持多种色彩主题，总有您喜欢和适合您的</li>
<li>内建的终端支持 PlatformIO Core 命令行工具，并且支持强大的串口调试器</li>
</ul>

<p>尽管 PlatformIO 可以运行在不同的操作系统中，但从开发的角度看更重要的是它支持多少开发板和单片机。概括来说: PlatformIO 支持大约 600+ 个<a href="https://docs.platformio.org/en/latest/boards/index.html" target="_blank">开发板</a>和市面上流行的支持跨平台的 30 个<a href="https://docs.platformio.org/en/latest/platforms/index.html#" target="_blank">开发平台</a>。</p>

<ul>
<li>支持的嵌入式开发板列表: <a href="https://docs.platformio.org/en/latest/boards/index.html" target="_blank">Boards</a></li>
<li>支持的单片机平台和桌面平台: <a href="https://docs.platformio.org/en/latest/platforms/index.html#" target="_blank">Platforms</a></li>
</ul>

<p>同时，PlatformIO 还提供大量的开发库，目前超过了 6000 个，为了方便新手入门开发，他们也同样提供代码例程。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-30-support.png" alt="" /></p>

<h1 id="platformio-解决的问题">PlatformIO 解决的问题</h1>

<ul>
<li>嵌入式开发的世界让很多人望而却步的主要原因是针对某一个单片机或开发板开发环境复杂的配置过程：交叉编译链工具下载、安装和配置，另外还得使用厂商独有的 IDE (有时还不是免费的) ，还有有时还不得不使用 IDE 只支持的 Windows</li>
<li>多个硬件平台 (单片机, 开发板) 需要不同交叉编译链工具和开发环境, 所有相应的开发人员需要花费大量精力在配置新的开发环境上</li>
<li>为了学习如何使用常规的传感器或执行器件等外设，需要花时间查找合适的库和例程</li>
<li>每个团队成员可能会使用不用的操作系统，这就为他们之间共享成果形成阻碍（当然国内现状是公司逼着员工使用统一的操作系统，哈哈🤣）</li>
</ul>

<h1 id="platformio-如何工作">PlatformIO 如何工作</h1>

<p>这里不深入说 PlatformIO 的实现细节, 使用 PlatformIO 时工程的工作流程如下：</p>

<ul>
<li>用户在 “platformio.ini” (工程配置文件) 中指定开发平台（开发板）</li>
<li>根据配置文件中的开发板（一个工程可以配置多个开发板），PlatformIO 会自动下载并安装对应的交叉编译链工具以及调试工具.</li>
<li>用户编写代码，PlatformIO 来保证所有指定开发板的编译、调试和上传工作</li>
</ul>

<h1 id="platformio-需要用户进行的选择">PlatformIO 需要用户进行的选择</h1>

<ul>
<li>决定使用什么系统运行 PlatformIO 来进行单片机开发，需要进行相应系统的安装工作</li>
<li>选择使用什么编辑器进行代码编写，可以是极简通用的代码编辑器，也可以您喜欢的桌面 IDE</li>
<li>专注于代码开发，显著简化使用开发平台和单片机的过程</li>
</ul>

<h1 id="platformio-的相关报道">PlatformIO 的相关报道</h1>

<blockquote>
<p>通常情况下不同的单片机需要不同的开发工具，比如 Arduino 使用的是 <strong>Arduino IDE</strong>，有些高级用户为了更好的进行代码工程管理，也会配置基于 Eclipse 的图形界面的开发环境。有时同步支持不同的单片机比较困难，您可能觉得如果有一个统一的开发工具那该多好呀！ PlatformIO 就是这么一个开源的进行单片机嵌入式开发的生态工具。</p>

<p>PlatformIO 是一个跨平台的代码构建工具和库管理工具，并且支持像 Arduino 和 MBED 这样的平台。他们关心可以跨 macOS、windows 和 linux 三个平台工作的工具链、调试器和开发平台，它支持超过 200 个的开发板和超过 15 种的开发平台以及 10 中开发框架，所以绝大多数流行的开发板都是包含其中的。他们在收集整理开发库上倾注了大量精力，以至于您的工程可以使用上百种开发库。另外，也有很多代码例程提供方便您入门单片机开发。PlatformIO 最初以命令行的形态进行开发，现如今它可以完美配合其它的 IDE 进行使用，比如 Eclipse、Visual Studio，最近他们最新发布了基于 Atom 的 PlatformIO 开发环境。</p>
</blockquote>

<h1 id="platformio-的荣誉">PlatformIO 的荣誉</h1>

<p>PlatformIO 曾提名 <a href="https://www.postscapes.com/internet-of-things-software-guide/" target="_blank"><sup>2015</sup>&frasl;<sub>16</sub> IOT 年度最佳开发软件和工具奖</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之 Swift 的 Codable</title>
			<link>https://www.smslit.top/2019/03/24/macOS-dev-swift-codable/</link>
			<pubDate>Sun, 24 Mar 2019 16:49:16 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/24/macOS-dev-swift-codable/</guid>
			<description>近日研究了一下如何将自定义类型数据持久化，在研究过程中发现 Swift 的 Codable 真的很方便，觉得有必要写一写这个 Codable，在本文一起探讨一下以下三个方</description>
			<content type="html"><![CDATA[

<p>近日研究了一下如何将自定义类型数据持久化，在研究过程中发现 Swift 的 Codable 真的很方便，觉得有必要写一写这个 <strong>Codable</strong>，在本文一起探讨一下以下三个方面：</p>

<ul>
<li>什么是 Swift 的 Codable</li>
<li>怎么使用 Codable</li>
<li>Codable 给我们带来什么便利</li>
</ul>

<h1 id="开发平台">开发平台</h1>

<ul>
<li>macOS 10.14.4</li>
<li>Swift 5</li>
<li>xcode 10.2</li>
</ul>

<h1 id="swift-的-codable">Swift 的 Codable</h1>

<blockquote>
<p>In a nutshell, Encoding is the process of transforming your own custom type, class or struct to external data representation type like JSON or plist or something else &amp; Decoding is the process of transforming external data representation type like JSON or plist to your own custom type, class or struct.</p>
</blockquote>

<h2 id="可以使用的协议">可以使用的协议</h2>

<p>Swift 的标准库中包含了用于自定义类型(结构体、类)与其它表示形式(JSON、Property List 或 二进制)的数据之间相互转换的协议：</p>

<ul>
<li><p><strong>Encodable</strong>: 用于自定义类型向 JSON 或 Property List 的转换，协议包含一个方法</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">encode</span><span class="p">(</span><span class="n">to</span><span class="p">:)</span> </code></pre></div></li>

<li><p><strong>Decodable</strong>: 用于自 JSON 或 Property List 数据向自定义类型的转换，协议包含一个方法</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">init</span><span class="p">(</span><span class="n">from</span><span class="p">:)</span></code></pre></div></li>

<li><p><strong>Codable</strong>: 包含 Encodable 和 Decodable 两方面的转换，其定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">typealias</span> <span class="n">Codable</span> <span class="p">=</span> <span class="n">Decodable</span> <span class="o">&amp;</span> <span class="n">Encodable</span></code></pre></div></li>
</ul>

<p>使用 Codable 协议 的 Encodable 和 Decodable，可以让我们轻松实现自定义数据类型的序列化以及得到相应数据类型的实例对象。按照字面意思，我们后面将数据类型实例向 JSON 或 Property List 转换的过程称为编码，反之，称为解码！</p>

<h2 id="遵循协议的类型">遵循协议的类型</h2>

<p>如果我们想要实现自定义类型或数据模型的编码和解码，必须遵循 Codable 协议！Swift 基本的内建类型已经是 Codable 的了，比如 <code>String</code>、<code>Int</code>、<code>Double</code>、<code>Date</code> 和 <code>Data</code>。另外像 <code>Array</code>、<code>Dictionary</code> 和 <code>Optional</code> 也都是遵循 Codable 协议的，可以进行编码和解码。</p>

<p>如下自定义的结构体 Person 和 Team，遵循 Codable 协议，同时结构体的所有属性要么是标准的 Codable 类型，要么包含 Codable 类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Person</span> <span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">id</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">name</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">age</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">isMale</span><span class="p">:</span> <span class="nb">Bool</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Team</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">master</span><span class="p">:</span> <span class="n">Person</span>
    <span class="kd">var</span> <span class="nv">memebers</span><span class="p">:</span> <span class="p">[</span><span class="n">Person</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>
<h2 id="codable-类型的编解码">Codable 类型的编解码</h2>

<p>对于 Codable 的类型，需要使用相应的编码器对我们的数据进行编码和解码，具体细节可以参考后面的小节，有两种编码器可用：</p>

<ul>
<li><strong>JSON</strong>

<ul>
<li><code>JSONEncoder</code>: 将 Codable 类型数据编码为 JSON 数据</li>
<li><code>JSONDecoder</code>: 将 JSON 数据解码为指定的 Codable 类型数据</li>
</ul></li>
<li><strong>Property List</strong>

<ul>
<li><code>PropertyListEncoder</code>: 将 Codable 类型数据编码为 plist 数据</li>
<li><code>PropertyListDecoder</code>: 将 plist 数据解码为指定的 Codable 类型数据</li>
</ul></li>
</ul>

<h1 id="codable-的使用">Codable 的使用</h1>

<p>下面我们就一起研究一下 Codable 的使用，这里我们只尝试 Codable 类型数据与 JSON 数据的编码解码的实现。</p>

<h2 id="编码和解码">编码和解码</h2>

<h3 id="使用-jsonencoder-编码">使用 <code>JSONEncoder</code> 编码</h3>

<p>非常简单，只需调用 <code>JSONEncoder</code> 的 <code>encode(_:)</code> 方法就能将 Codable 类型转换为 JSON 数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">jack</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&#34;Jack&#34;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">isMale</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">jackData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">jack</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">jackData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>可以看到打印出转换得到的 JSON 字符串数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;age&#34;</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span><span class="nt">&#34;id&#34;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="nt">&#34;isMale&#34;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;Jack&#34;</span><span class="p">}</span></code></pre></div>
<p>是不是很方便，解码同样如此简单！</p>

<h3 id="使用-jsondecoder-解码">使用 <code>JSONDecoder</code> 解码</h3>

<p>只需要调用 <code>JSONDecoder</code> 实例的 <code>decode(_:from:)</code> 方法就能将 JSON 对象转换得到指定类型的实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">jsonString</span> <span class="p">=</span> <span class="s">&#34;&#34;&#34;
</span><span class="s">{
</span><span class="s">    &#34;</span><span class="n">id</span><span class="s">&#34;: 2,
</span><span class="s">    &#34;</span><span class="n">name</span><span class="s">&#34;: &#34;</span><span class="n">lucy</span><span class="s">&#34;,
</span><span class="s">    &#34;</span><span class="n">age</span><span class="s">&#34;: 11,
</span><span class="s">    &#34;</span><span class="n">isMale</span><span class="s">&#34;: false
</span><span class="s">}
</span><span class="s">&#34;&#34;&#34;</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">json</span> <span class="p">=</span> <span class="n">jsonString</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">lucy</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">lucy</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>打印结果，如您所料，将 JSON 字符串成功的解码为了 Person 实例对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">Person</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&#34;lucy&#34;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">isMale</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span></code></pre></div>
<h3 id="codable-使用的基本步骤">Codable 使用的基本步骤</h3>

<p>综上过程，我们可以总结一下，要使用 Swift 的特性其实很简单，分两步：</p>

<ul>
<li>自定义类型遵循 Codable 协议</li>
<li>使用编码器实现自定义类型数据的编码和解码</li>
</ul>

<h2 id="使用-codingkeys-来选择部分属性是-codable-的">使用 CodingKeys 来选择部分属性是 Codable 的</h2>

<p>也许此时此刻您可能会想：</p>

<ul>
<li>如果不想把自定义数据所有的属性编码到 JSON 该怎么办？</li>
<li>如果 JSON 数据中的键名与自定义类型中的属性名不一致怎么办？</li>
</ul>

<p>请放心，您想到的，Apple 同样照顾到了！就是本节要讲的 <code>CodingKeys</code></p>

<blockquote>
<p>Codable types can declare a special nested enumeration named CodingKeys that conforms to the CodingKey protocol. When this enumeration is present, its cases serve as the authoritative list of properties that must be included when instances of a codable type are encoded or decoded. The names of the enumeration cases should match the names you&rsquo;ve given to the corresponding properties in your type.</p>
</blockquote>

<p><code>CodingKeys</code> 是我们在自定义数据类型中定义的枚举，有以下两点要求：</p>

<ul>
<li>枚举元素类型是 String，并且遵循 CodingKey 协议、</li>
<li>枚举元素的名称必须与自定义类型中的属性名称保持一致</li>
</ul>

<p>那么我们回过头来看一下前面的两个问题怎么解决：</p>

<ul>
<li>CodingKeys 中的元素与自定义数据类型中的属性名称对应，只要删除对应属性的枚举元素就可以实现编码时对应属性的忽略，这样就解决了第一个问题，但是要注意，不编码的属性必须赋予默认值</li>
<li>为 CodingKeys 中枚举元素自定义 String 值与 JSON 数据中的键名对应起来，就能解决第二个问题。</li>
</ul>

<p>假如想为 Person 结构体添加一个 <code>description</code> 的属性，同时不想让它参与编码和解码，另外 JSON 数据中的键名是中文的，我们可以重构 Person 类：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Person</span> <span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">id</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">name</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">age</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">isMale</span><span class="p">:</span> <span class="nb">Bool</span>
    <span class="kd">var</span> <span class="nv">description</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&#34;person&#34;</span>
    
    <span class="kd">enum</span> <span class="nc">CodingKeys</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">id</span> <span class="p">=</span> <span class="s">&#34;身份证号&#34;</span>
        <span class="k">case</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&#34;姓名&#34;</span>
        <span class="k">case</span> <span class="n">age</span> <span class="p">=</span> <span class="s">&#34;年龄&#34;</span>
        <span class="k">case</span> <span class="n">isMale</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>我们看一下将自定义数据转换为 JSON 会是怎样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">tim</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&#34;tim&#34;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">isMale</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">timData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">tim</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">timData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>编码得到的 JSON 数据如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;姓名&#34;</span><span class="p">:</span><span class="s2">&#34;tim&#34;</span><span class="p">,</span><span class="nt">&#34;isMale&#34;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="nt">&#34;年龄&#34;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="nt">&#34;身份证号&#34;</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span></code></pre></div>
<h2 id="自定义-encode-和-decode">自定义 encode 和 decode</h2>

<p>我们定义一个 Size 结构体、Point 结构体和 Rect 结构体如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Size</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Double</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Point</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">var</span> <span class="nv">y</span><span class="p">:</span> <span class="nb">Double</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Rect</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">position</span><span class="p">:</span> <span class="n">Point</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="n">Size</span>
<span class="p">}</span></code></pre></div>
<p>我们利用一开始定义的 Rect 结构体声明一个 rect，坐标在原点，宽高都为 2.0，并将其转换为 JSON 数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rect</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">rectData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">rectData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>team 对应的 JSON 字符串如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;position&#34;</span><span class="p">:{</span><span class="nt">&#34;x&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nt">&#34;y&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span><span class="nt">&#34;size&#34;</span><span class="p">:{</span><span class="nt">&#34;width&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="nt">&#34;height&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">}}</span></code></pre></div>
<p>但是呢，十里不想让 JSON 数据中 x 和 y 嵌套在 positon 中，也不想 width 和 height 嵌套在 size 中，而是像下面的样子：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span>
    <span class="nt">&#34;x&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;y&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;width&#34;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="nt">&#34;height&#34;</span><span class="p">:</span> <span class="mf">2.0</span>
<span class="p">}</span></code></pre></div>
<p>要实现这种需求，我们必须自定义 <code>Encodable</code> 协议的 <code>encode(_:)</code> 方法 和 <code>Decodable</code> 协议的 <code>init(from:)</code> 方法，实现自定义的编码解码逻辑，大体分下面几步：</p>

<ul>
<li>定义 CodingKeys 枚举，元素与目标 JSON 数据的键名对应，定义 x 和 y 而不是 position，定义 width 和 height 而不是 size</li>
<li>删除 Rect 定义中的 Codable</li>
<li>扩展 Rect 遵循 Encodable 协议，并实现 <code>encode(_:)</code> 方法</li>
<li>扩展 Rect 遵循 Decodable 协议，并实现 <code>init(from:)</code> 方法</li>
</ul>

<p>最终 Rect 定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Rect</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">position</span><span class="p">:</span> <span class="n">Point</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="n">Size</span>
    
    <span class="kd">enum</span> <span class="nc">CodingKeys</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">x</span>
        <span class="k">case</span> <span class="n">y</span>
        <span class="k">case</span> <span class="n">width</span>
        <span class="k">case</span> <span class="n">height</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Rect</span><span class="p">:</span> <span class="n">Encodable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="n">encoder</span><span class="p">:</span> <span class="n">Encoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">container</span> <span class="p">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">CodingKeys</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Rect</span><span class="p">:</span> <span class="n">Decodable</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">from</span> <span class="n">decoder</span><span class="p">:</span> <span class="n">Decoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">CodingKeys</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">position</span> <span class="p">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">width</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">width</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">height</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">height</span><span class="p">)</span>
        <span class="n">size</span> <span class="p">=</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">height</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>测试一下编码实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rect</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">rectData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">rectData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>得到的 JSON 数据的打印结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;y&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nt">&#34;x&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nt">&#34;width&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="nt">&#34;height&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span></code></pre></div>
<p>测试一下解码的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rectString</span> <span class="p">=</span> <span class="s">&#34;&#34;&#34;
</span><span class="s">{
</span><span class="s">    &#34;</span><span class="n">x</span><span class="s">&#34;: 3,
</span><span class="s">    &#34;</span><span class="n">y</span><span class="s">&#34;: 3,
</span><span class="s">    &#34;</span><span class="n">width</span><span class="s">&#34;: 2.5,
</span><span class="s">    &#34;</span><span class="n">height</span><span class="s">&#34;: 2.5
</span><span class="s">}
</span><span class="s">&#34;&#34;&#34;</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">json</span> <span class="p">=</span> <span class="n">rectString</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">newRect</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">Rect</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">newRect</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>得到的 newRect 实例对象打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">__lldb_expr_21</span><span class="p">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">__lldb_expr_21</span><span class="p">.</span><span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">))</span></code></pre></div>
<h1 id="codable-带来的福利">Codable 带来的福利</h1>

<p>上面说了这么多的 Codable ，到底我们能用它来干什么呢，最主要的两个应用方向就是自定义类型数据持久化和网络通信。</p>

<h2 id="数据持久化">数据持久化</h2>

<p>其中一种常用的数据持久化方式就是属性列表(Property List)，<code>UserDefaults.standard</code> 适合存储轻量级的本地数据，其提供了与默认数据库相交互的编程接口。其实它存储在应用程序的一个plist文件里，路径为应用沙盒Document目录平级的 <code>/Library/Prefereces</code> 里。另外，其只能存储可以序列化的数据类型，比如我们一开始说的那些基本类型，也就是 Codable 的，所以一旦我们自定义的数据类型遵循了 Codable 协议，即可序列化了，那我们的自定义类型的数据可以自由存取了。</p>

<p><strong>注意：</strong></p>

<ul>
<li>使用这种方式一般用于存储应用程序的配置信息</li>
<li>手动调用 <code>synchronize</code> 方法可以立马将数据持久化存储</li>
</ul>

<p>这里只是以这种数据持久化为例，讲一下如何持久化自定义数据类型的数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rectDemo</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">demoData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">rectDemo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="kr">set</span><span class="p">(</span><span class="n">demoData</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="s">&#34;rect-test&#34;</span><span class="p">)</span>
    <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;saved successfully!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">rectJson</span> <span class="p">=</span> <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="s">&#34;rect-test&#34;</span><span class="p">)</span> <span class="k">as</span><span class="p">?</span> <span class="n">Data</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">newRect</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">Rect</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">rectJson</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">newRect</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>可以看到打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">saved</span> <span class="n">successfully</span><span class="o">!</span>
<span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">__lldb_expr_29</span><span class="p">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">__lldb_expr_29</span><span class="p">.</span><span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span></code></pre></div>
<h2 id="网络通信">网络通信</h2>

<p>HTTP/HTTPS 网络通信中 JSON 是常用的交互数据类型，假如我们编写一个网络接口，当外部请求的时候，我们为其返回一个响应，如果我们定义一个 Codable 的 Response 类型，可以方便生成响应数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Response</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ststus</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">message</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">res</span> <span class="p">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">ststus</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="s">&#34;OK&#34;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">resData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></code></pre></div>
<h1 id="总结">总结</h1>

<p>Swift 4 开始支持的 Codable 大大简化了对自定义类型数据序列化的实现，相信您会用得到！</p>
]]></content>
		</item>
		
	</channel>
</rss>
