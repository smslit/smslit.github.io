<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on SMSLIT</title>
		<link>https://www.smslit.top/post/</link>
		<description>Recent content in Posts on SMSLIT</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 05 Aug 2019 17:17:42 +0800</lastBuildDate>
		<atom:link href="https://www.smslit.top/post/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>PlatformIO IDE(VScode) 下调试 STM32 平台程序</title>
			<link>https://www.smslit.top/2019/08/05/platformio-debug/</link>
			<pubDate>Mon, 05 Aug 2019 17:17:42 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/08/05/platformio-debug/</guid>
			<description>PlatformIO 系列文章 stm32开发新方式-platformio 中最后提到说 PlatformIO 限制了免费用户调试程序的功能，最近发现 PlatformIO 已经免费开发程序调试功能，所以现在</description>
			<content type="html"><![CDATA[

<p><strong>PlatformIO</strong> 系列文章 <a href="/2017/11/08/stm32InPIO-start/#调试配置" target="_blank"><strong>stm32开发新方式-platformio</strong></a> 中最后提到说 PlatformIO 限制了免费用户调试程序的功能，最近发现 PlatformIO 已经免费开发程序调试功能，所以现在我们可以使用内建支持更好的方式调试我们的 ST MCU 的程序了，那今天我们就聊一下这一块内容。</p>

<p>官方称其为 PIO Unified Debugger，很好理解，就是统一的调试器，意思是凡是 PIO 支持的可调式的 MCU 开发平台均可以使用统一功能的调试器，PIO 跨平台的特性仍然支持程序调试，也就是说在 windows、linux和 macOS 下均可以得到相同的开发体验。</p>

<blockquote>
<p>You should have PIO Account to work with PIO Unified Debugger. A registration is FREE.</p>
</blockquote>

<p>官方说明免费使用这个调试功能需要登录一个 PIO 账户，这个很简单嘛，注册一个然后在 VSCode 的 PIO IDE 中登录即可，这可能是唯一的限制了！</p>

<h2 id="功能特性">功能特性</h2>

<p>官方文档中提到 VScode 搭建的 PIO 开发环境可以提供最强大的调试功能特性，包括以下：</p>

<ul>
<li><strong>局部、全局和静态变量的浏览器</strong> (Local, Global, and Static Variable Explorer)</li>
<li><strong>条件断点</strong> (Conditional Breakpoints)</li>
<li><strong>表达式监控</strong> (Expressions and Watchpoints)</li>
<li><strong>通用寄存器检阅</strong> (Generic Registers)</li>
<li><strong>外设寄存器检阅</strong> (Peripheral Registers)</li>
<li><strong>内存数据检阅器</strong> (Memory Viewer)</li>
<li><strong>汇编检阅</strong> (Disassembly)</li>
<li><strong>多线程支持</strong> (Multi-thread support)</li>
<li><strong>调试会话的热重启和激活</strong> (A hot restart of an active debugging session)</li>
</ul>

<p>以下为 <strong>genericSTM32F103C8</strong> 开发板使用 Arduino 开发框架时调试程序时的界面：</p>

<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5ukpd0n9wj31hc0u0q80.jpg" alt="" /></p>

<h2 id="实践">实践</h2>

<p>下面我们就以 <strong>genericSTM32F103C8</strong> 开发板使用 Arduino 开发框架为例讲解一下，调试程序是多么的简单。</p>

<h3 id="前提条件">前提条件</h3>

<h4 id="开发环境">开发环境</h4>

<ul>
<li>已经安装 vscode</li>
<li>vscode 已经安装 PlatformIO IDE 插件</li>
</ul>

<p>上述条件满足后，打开 vscode 新的窗口，会如下图中所示，左边栏多出 PlatformIO 的logo，以及最下边状态栏左边有个小房子的图标：</p>

<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g5ul9bsjubj31hc0u0go1.jpg" alt="" /></p>

<h4 id="硬件">硬件</h4>

<ul>
<li>一个 stm32f103c8t6 的最小系统板</li>
<li>stlink v2 调试器</li>
</ul>

<h4 id="pio-账户">PIO 账户</h4>

<p>如果没有 PIO 账户那就先注册一个，打开 vscode 点击上图中提到的小房子的图标就会打开 PlatformIO 的管理页面，点击右上角的 PIO Account 图标</p>

<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5uliezdtej302i02c0hn.jpg" alt="" /></p>

<p>此时会跳转到 PIO 账户登录页面，登录按钮下面有一个链接 <strong>create a new one</strong> ，点击一下即可进入注册页面：</p>

<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g5ulnmveigj316i0u0wfn.jpg" alt="" /></p>

<p>输入自己的邮箱，点击注册按钮即可完成注册， PlatformIO 会自动生成一个密码发到你的邮箱，返回到登录页面输入邮箱和密码登录即可。</p>

<h3 id="新建项目">新建项目</h3>

<p>返回到 Home 页面，点击 New Project 按钮开始新建项目，这里项目名称定义为 <strong>c8t6Blink</strong>，一个控制 LED 闪烁的简单例子，Board 就选 <strong>STM32F103C8(20k RAM. 64k Flash)(Generic)</strong> ，然后使用 <strong>Arduino</strong> 框架，最后点击 Finish 即可创建项目：</p>

<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g5um2h72phj316i0u0q4y.jpg" alt="" /></p>

<p>初次创建可能需要时间会长一点，会下载编译需要的一些依赖工具包，以后再创建相同平台项目的时候就很快了。</p>

<h3 id="编写程序">编写程序</h3>

<p>手头上这个最小系统板上的 LED 是 PB0 管脚控制的，硬件设计是低电平 LED 点亮，所以一个简单的闪灯程序如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;Arduino.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define LED_PIN PB0
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// put your setup code here, to run once:
</span><span class="c1"></span>  <span class="n">pinMode</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// put your main code here, to run repeatedly:
</span><span class="c1"></span>  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">LED_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">900</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>点击底部状态栏左边的小对号图标就可以进行编译，编译完成后点击右边向右的箭头图标就可以烧写程序，初次上传烧写需要时间长一些，PIO 需要下载一些相关工具包，以后就是正常上传程序了，完成后就能看到程序正常运行，LED 闪了起来。</p>

<h3 id="调试程序">调试程序</h3>

<p>按下 <strong>F5</strong> 按键即可触发程序调试，本以为会出现类似本篇文章第一张图的样子，结果会出现以下错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">&gt; Executing task: platformio debug &lt;

Error: Please specify <span class="sb">`</span>debug_port<span class="sb">`</span> <span class="k">for</span> environment
终端进程已终止，退出代码: <span class="m">1</span>

终端将被任务重用，按任意键关闭。</code></pre></div>
<p>为什么会出现这个错误？原因很简单，PIO 不知道我们是用什么调试工具进行程序调试，所以需要在项目配置文件 <code>platformio.ini</code> 中指明一下我们使用 stlink 进行调试：</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="k">[env:genericSTM32F103C8]</span>
<span class="na">platform</span> <span class="o">=</span> <span class="s">ststm32</span>
<span class="na">board</span> <span class="o">=</span> <span class="s">genericSTM32F103C8</span>
<span class="na">framework</span> <span class="o">=</span> <span class="s">arduino</span>
<span class="na">debug_tool</span> <span class="o">=</span> <span class="s">stlink</span></code></pre></div>
<p>此时点击 <strong>F5</strong> 就可以正常触发调试了，可以看到启动调试程序默认停到 main 中第一句。</p>

<ul>
<li>顶部会看到调试工具栏，可以实现调试会话的重启、程序启停、执行等操作按钮</li>
<li>可以在代码编辑器行号前面单击添加或删除断点</li>
<li>左侧调试工具区点击 <strong>PERIPHERALS</strong> 栏，可以查看所有外设寄存器配置，方便验证寄存器配置正确与否</li>
<li><strong>MEMORY</strong> 栏可以添加内存地址来查看指定字节的数据，方便验证指针数据</li>
<li><strong>监视</strong> 中可以添加监测变量，随时查看变量变化</li>
<li><strong>变量</strong> 中展示了所有当前断点可检阅的全局、局部以及静态变量</li>
<li><strong>调用堆栈</strong> 中展示了函数的调用层次</li>
<li>调试控制台的最下方可以输入 <strong>adb</strong> 命令，从而实现更强大的调试操作</li>
<li><strong>DISASSEMBLY</strong> 栏可以控制切换汇编窗口方便查看汇编代码</li>
</ul>

<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g5ung40o74j31hc0u0wkt.jpg" alt="" /></p>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之 Windows 和 WindowController</title>
			<link>https://www.smslit.top/2019/04/01/macOS-dev-windows-and-windowcontroller/</link>
			<pubDate>Mon, 01 Apr 2019 08:20:10 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/04/01/macOS-dev-windows-and-windowcontroller/</guid>
			<description>本文带大家一起简单学习如何开发一个基于文档的 Cocoa 应用(document based Cocoa App)，并学习如何使用模态窗口(Modal Windows) 以及 macOS Sierra 支持的标签窗口</description>
			<content type="html"><![CDATA[

<p>本文带大家一起简单学习如何开发一个基于文档的 Cocoa 应用(document based Cocoa App)，并学习如何使用模态窗口(Modal Windows) 以及 macOS Sierra 支持的标签窗口(tabbed interface)。</p>

<h1 id="开发平台">开发平台</h1>

<ul>
<li>macOS 10.14.4</li>
<li>Swift 5</li>
<li>xcode 10.2</li>
</ul>

<h1 id="概述">概述</h1>

<p>所有 macOS 程序要呈现用户界面都是以 Windows 作为容器的，当然除了纯粹的命令行工具和菜单栏小工具。Windows 定义了 App 在屏幕中的活动区域，在这个区域内允许用户进行易于理解的多任务交互操作。macOS 应用最终可分为以下几种：</p>

<ul>
<li><p>单窗口的工具，比如计算器</p>

<figure>
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-single-Window.png" width="210px"/> 
</figure>
</li>

<li><p>单窗口的 library-style 应用，比如照片应用(Photos.app)</p>

<figure>
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-library-Style1.png" width="560px"/> 
</figure>
</li>

<li><p>基于文档的多窗口应用，比如文本编辑应用(TextEdit.app)</p>

<figure>
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-document-based1.png" width="640px"/> 
</figure>
</li>
</ul>

<p>不管属于哪一类的应用，几乎每一个 macOS 应用都是使用 MVC (Model-View-Controller) 构建的，这是 macOS 开发中核心的开发模式。</p>

<p>Cocoa 应用中，一个窗口是 <code>NSWindow</code> 类的一个实例(window 就是 view 的容器)，其与控制器紧密配合工作，而控制器是 <code>NSWIndowController</code> 的一个实例。在一个设计良好的应用中会发现通常窗口和控制器是一一对应的，而 MVC 模式中的第三个组成部分——模型(model)的使用会根据应用的类型和设计而不同。</p>

<p>在本文中我们会创建一个有点像 TextEdit 的应用，是 document based 的，我管它叫 <strong>5kmEditor</strong>，这个名字随便，只要您喜欢啥都行！在我们开发过程中，将会涉及到以下内容：</p>

<ul>
<li>窗口 和 窗口控制器</li>
<li>document 架构</li>
<li>NSTextView</li>
<li>模态窗口</li>
<li>菜单栏和菜单项</li>
</ul>

<h1 id="搞起">搞起</h1>

<p>启动 Xcode，按快捷键 <code>Shift</code> + <code>Command</code> + <code>n</code> ，新建工程，选择 macOS -&gt; Cocoa App，点击 Next：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2012.48.44.png" alt="" /></p>

<p>新出现的窗口中，勾选 <code>Create Document-Based Application</code>，应用的名称随意取，比如 <strong>5kmEditor</strong>，然后 <code>Document Extention</code> 这一项指定文件的扩展名，其决定以后应用保存文件的扩展名，比如十里指定的是 <code>5km</code>，可以不勾选包含测试，点击 Next：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2020.56.55.png" alt="" /></p>

<p>选择合适的目录，点击 <code>Create</code> 创建即可，创建成功后编译运行，你会看到类似下面的窗口：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2020.59.52.png" alt="" /></p>

<p>此时，按快捷键 <code>Command</code> + <code>n</code> 或者菜单栏点击 File -&gt; New，可以创建新的窗口如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-multi-windwos.png" alt="" /></p>

<h1 id="document-based-应用如何工作">Document-Based 应用如何工作</h1>

<p>上面也看到了这类应用的样子，下面花几分钟一起看一下 Document-Based 应用如何工作的。</p>

<h2 id="document-的结构">Document 的结构</h2>

<p>一个 Document 其实就是 <code>NSDocument</code> 的一个实例对象，文档模型 <code>NSDocument</code> 作为模型保存了文档的数据，同时负责文档窗口控制器 <code>NSWindowController</code> 的创建管理，它管理文档数据，负责文档打开时数据读取的管理和文档对象管理的数据保存到文件的处理，而文件有可能是在硬盘也有可能在 iCloud，均支持。</p>

<p>创建关联的 <code>NSWindowController</code> 负责展示文档的内容，内容视图最终相应处理用户对文档操作的各种交互事件。</p>

<p><code>NSDocumentController</code> 是一个单例对象，主要负责文档模型 <code>NSDocument</code> 的管理工作，维护系统中所有的文档模型 <code>NSDocument</code> 列表，控制多个文档窗口的激活切换，同时跟踪当前活动文档对象，最终结构图如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-document-arch.png" alt="" /></p>

<h2 id="禁用-document-的保存和打开">禁用 Document 的保存和打开</h2>

<p>Document-Based 应用的 Documnent 架构支持文件的保存和打开，但是需要定义 <code>Document</code> 类中自己具体实现，本文暂不涉及这部分内容，所以先禁用 Document 的保存和打开。</p>

<p>打开文件 <code>Document.swift</code>，会发现有两个函数是空的：</p>

<ul>
<li><code>data(ofType:)</code>: 用于写文件</li>
<li><code>read(from:ofType:)</code>: 用于读取文件</li>
</ul>

<p>同时还有一个函数是 <code>autosavesInPlace()-&gt;Bool</code>，更改返回值为 <code>false</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">override</span> <span class="kd">class</span> <span class="nc">var</span> <span class="n">autosavesInPlace</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span></code></pre></div>
<p>这样我们首先禁用了自动保存功能，下面我们需要禁用菜单栏 File 中的保存和打开菜单项。在这之前，我们运行程序，点击 File -&gt; Open ，竟然会弹出打开文件的窗口，很神奇，我们并没有实现打开呀，为什么会出现文件打开窗口呢？</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.23.37.png" alt="" /></p>

<p>其实是因为 Open 的菜单项绑定了具体的 Action，Action中实现了这些，所以我们只需要断开菜单项与 Action 的链接就可以禁用掉菜单项，视觉上的表现就是菜单栏相应菜单项会变灰色不可用。</p>

<p>打开 <code>Main.storyboard</code> ，找到 <code>Application Scene</code>，点击菜单栏中 File，选择其中的 <code>Open</code>，右击会看到所有的连接，点击 Sent Action 中连接右侧的 <code>x</code> 号，即可断开连接：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.34.42-1.png" alt="" /></p>

<p>同样的操作，分别将 <code>Save...</code>、<code>Save As...</code> 和 <code>Reverrt to Saved</code> 与相应的 Action 断开连接。</p>

<p>然后删除 <code>Open Recent</code> 菜单项，最后我们重写一下 <code>save(withDelegate:didSave:contexInfo:)</code> 方法，后面我们会用到，主要是添加一个错误🙅‍提醒窗口，打开 <code>Document.swift</code> 文件，在 <code>Document</code> 类中添加重写方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">override</span> <span class="kd">func</span> <span class="nf">save</span><span class="p">(</span><span class="n">withDelegate</span> <span class="n">delegate</span><span class="p">:</span> <span class="nb">Any</span><span class="p">?,</span> <span class="n">didSave</span> <span class="n">didSaveSelector</span><span class="p">:</span> <span class="nb">Selector</span><span class="p">?,</span> <span class="n">contextInfo</span><span class="p">:</span> <span class="n">UnsafeMutableRawPointer</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">userInfo</span> <span class="p">=</span> <span class="p">[</span><span class="n">NSLocalizedDescriptionKey</span><span class="p">:</span> <span class="s">&#34;Sorry, no saving implemented in this post. Click &#39;Do not save&#39; to quit!&#34;</span><span class="p">]</span>
    <span class="kd">let</span> <span class="nv">error</span> <span class="p">=</span> <span class="n">NSError</span><span class="p">(</span><span class="n">domain</span><span class="p">:</span> <span class="n">NSOSStatusErrorDomain</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="n">unimpErr</span><span class="p">,</span> <span class="n">userInfo</span><span class="p">:</span> <span class="n">userInfo</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">alert</span> <span class="p">=</span> <span class="n">NSAlert</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">alert</span><span class="p">.</span><span class="n">runModal</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p>运行程序，此时会看到菜单栏的相应菜单项已经禁用：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.41.27.png" alt="" /></p>

<h1 id="窗口显示">窗口显示</h1>

<p>上面新建文件的时候，我们发现新建文档的窗口完全覆盖了之前的文档窗口，然而这不是我们想要的结果，本节就聊一下怎么合理布局窗口的位置。进行改造前，我们需要新建一个 <code>NSWindowController</code> 的子类，然后添加相应的代码实现我们预期的功能。</p>

<h2 id="新建-nswindowcontroller-的子类">新建 NSWindowController 的子类</h2>

<p>工程导航栏选择 <code>5kmEditor</code>，按下快捷键 <code>Command</code> + <code>n</code>，就会弹出新建文件的导航窗口，选择 macOS -&gt; Source -&gt; Cocoa Class，点击 Next</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-31%2023.58.08.png" alt="" /></p>

<p>取名为 <code>WindowController</code>，选择继承自 <code>NSWindowController</code>，不要勾选 <code>Also Create XIB file for user interface</code>，语言选择 <code>Swift</code> ，点击 Next，之后默认然后点击 Create 即可创建。</p>

<p>下一步需要确保 storyboard 中的 window 的控制器是我们刚定义的 <code>WindowController</code> 的实例，打开 <code>Main.storyboard</code> 点击 <code>Window Controller Scene</code> 中的 <code>Window Controller</code>，按快捷键 <code>Option</code> + <code>Command</code> + <code>3</code> ，在右侧显示的 <code>Identity Inspector</code> 中配置 Custom Class 为 <code>WindowController</code>，也就是刚刚创建的类：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2000.08.04.png" alt="" /></p>

<h2 id="层叠窗口">层叠窗口</h2>

<p>现在我们可以使新建的窗口层叠显示而不是覆盖显示，打开新建的 <code>WindowController.swift</code> 文件，添加以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">required</span> <span class="kd">init</span><span class="p">?(</span><span class="n">coder</span><span class="p">:</span> <span class="n">NSCoder</span><span class="p">)</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">coder</span><span class="p">:</span> <span class="n">coder</span><span class="p">)</span>
    <span class="n">shouldCascadeWindows</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span></code></pre></div>
<p>只需要设置 <code>shouldCascadeWindows</code> 为 true 就可以实现层叠效果，运行程序测试一下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-cascade_windows.png" alt="" /></p>

<h2 id="以标签页显示">以标签页显示</h2>

<p>层叠效果很不错，但我们可以尝试一下其它的方式，比如从 macOS Sierra 开始新增加的 tabbed Windows，简单说就是新建的窗口以标签页显示。</p>

<p>打开 <code>Main.storyboard</code>，选中 <code>Window Controller scene</code> 下的 <code>Window</code> ，然后打开 Inspector 栏的 <code>Attributes Inspector</code> (可以按快捷键 <code>Option</code> + <code>Command</code> + <code>4</code>)，找到 <code>Tabbing Mode</code>，更改它的值为 <code>Preferred</code>:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2006.59.56.png" alt="" /></p>

<p>运行程序，然后按快捷键 <code>Command</code> + <code>n</code> 新建窗口，可以看到新的窗口以标签页的方式显示了：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2007.04.58.png" alt="" /></p>

<p>当我们运行程序的时候，macOS 会根据当前屏幕大小和应用请求窗口的大来决定应用窗口的显示位置和实际的大小，下面我们将学习两种方式控制应用窗口的显示位置和实际大小。</p>

<h2 id="使用-interface-builder-设置窗口显示位置">使用 Interface Builder 设置窗口显示位置</h2>

<p>首先我们需要先使用 Interface Builder 设置窗口的初始位置。</p>

<p>打开 <code>Main.storyboard</code>，选中 <code>Window Controller scene</code> 下的 <code>Window</code> ，然后打开 Inspector 栏的 <code>Size Inspector</code> (可以按快捷键 <code>Option</code> + <code>Command</code> + <code>5</code>)，找到 Initial Position，运行程序后的窗口就是按照这个设置初始位置的：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-31-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2007.28.32.jpg" alt="" /></p>

<p>其中 x 代表窗口到屏幕左边缘的距离，y 代表窗口到屏幕底边的距离，单位是 px，在 macOS 中应用的坐标原点在左下角，这与 iOS 中是不同的（iOS 使用的是 flipped 坐标系，其原点在左上角）。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-Window-position-1.png" alt="" /></p>

<p>我们可以点击上面 Size Inspector 中的窗口位置预览图中的红色 constrains，这会决定 macOS 显示应用窗口位置的设定，点击红色 Constrains 可以打开或关闭相关限制，同时会看到下面两个下拉框得值会改变，比如这里：</p>

<ul>
<li>取消上边和右边的红色限制，此时会看到下面两个下拉框的值分别变成 <code>Fixed From Left</code> 和 <code>Fixed From Bottom</code></li>
<li>设置初始的位置：x -&gt; 200, y -&gt; 200</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2009.45.16.png" alt="" /></p>

<p>此时重新编译运行应用，你会发现不管屏幕多大，只要尺寸允许范围内，应用的窗口会显示在离屏幕左边和底边均为 200 px 的位置。</p>

<p>⚠️: macOS 会记住 app 的窗口显示位置，所以需要先把应用完全退出，然后再编译运行就能看到修改的效果！</p>

<h2 id="代码实现对窗口显示位置的设置">代码实现对窗口显示位置的设置</h2>

<p>代码实现的话，需要在 window 加载之后进行设置，在 WindowsController 中重写的 windowDidLoad 方法中添加相关代码。</p>

<p>这次我们来点特别的，我们设置窗口显示在离屏幕顶边和左边均为 150px 的位置，打开 <code>WindowController.swift</code> 文件，在 <code>WindowController</code> 类中修改 windowDidLoad 方法内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">override</span> <span class="kd">func</span> <span class="nf">windowDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">windowDidLoad</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">window</span> <span class="p">=</span> <span class="n">window</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">screen</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">screen</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">offsetFromLeftOfScreen</span> <span class="p">=</span> <span class="n">CGFloat</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">offsetFromTopOFScreen</span> <span class="p">=</span> <span class="n">CGFloat</span><span class="p">(</span><span class="mi">150</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">screenFrame</span> <span class="p">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">visibleFrame</span>
        <span class="kd">let</span> <span class="nv">offsetFromBottomOfScreen</span> <span class="p">=</span> <span class="n">screenFrame</span><span class="p">.</span><span class="n">maxY</span> <span class="o">-</span> <span class="n">window</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">offsetFromTopOFScreen</span>
        <span class="n">window</span><span class="p">.</span><span class="n">setFrameOrigin</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">offsetFromLeftOfScreen</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">offsetFromBottomOfScreen</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>上面代码主要完成以下工作：</p>

<ul>
<li>获取需要用到的 <code>NSWindow</code> 和 <code>NSScreen</code> 的实例</li>
<li>得到 screen 的 <code>visibleFrame</code></li>
<li>通过离顶边的距离计算得到离底边距离</li>
<li>设置 window 的远点坐标为 (offsetFromLeftOfScreen, offsetFromBottomOfScreen)</li>
</ul>

<p>选中之前显示的应用窗口，<code>Command</code> + <code>q</code> 完全退出应用，然后回到 Xcode 编译运行应用，会看到应用的窗口如期显示在指定的位置：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-positionDemo-1.png" alt="" /></p>

<h1 id="变身超-mini-富文本处理工具">变身超 mini 富文本处理工具</h1>

<p>Cocoa 有很多可以添加到 window 中的牛🐂的功能性 UI 控件，在本节我们将会用到 <code>NSTextView</code>，在这之前，我们需要了解 <code>NSWindow</code> 的 content view。</p>

<h2 id="content-view">content view</h2>

<p><code>contentView</code> 位于 window 中视图层次的根级，在这个视图中我们可以放置所有界面元素。另外，我们还能替换默认的 <code>contentView</code> 为我们自定义的视图，在这里我们就不做相关操作了，以后我们可能会用到！</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2010.58.22.png" alt="" /></p>

<h2 id="添加-text-view">添加 Text View</h2>

<p>打开 <code>Main.storyboard</code> 文件，找到 View Contorller Scene 下的 View Controller，其下的 View 中有个控价 <code>Your document contents here</code> ，将其删除，然后我们添加 Text View:</p>

<ul>
<li>按快捷键 <code>Shift</code> + <code>Command</code> + <code>l</code> 打开 <code>Object Library</code></li>

<li><p>搜索 Text View</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2019.34.32.png" alt="" /></p></li>

<li><p>将 <code>Rich Document Content Text View</code> 拖入 Content View 中</p></li>

<li><p>调整 <code>Rich Document Content Text View</code> 的大小和位置，最终使其四边分别与 <code>contentView</code> 的边缘贴齐</p></li>

<li><p>选中刚添加的 Text View 控件，然后点击底边的 <code>Resolve Auto Layout Issues</code> 按钮，选中 <code>Reset To Suggested Constrains</code></p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.38.53.png" alt="" /></p></li>

<li><p>添加限制之后的样子如下：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.39.14.png" alt="" /></p></li>
</ul>

<p>编译运行，可以看到刚添加的 Text View 了：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.39.25.png" alt="" /></p>

<p>在窗口的 Text View 中可以添加进行文本编辑了，也支持常用的快捷键，比如复制、粘贴、剪切、撤销、重做等。窗口中也出现了一组工具栏，支持字体设置、简单的段落设置等，同时菜单栏的 Format 的菜单项功能也是可用的，还支持查找替换。这一小节我们没有添加任何代码，就完成了一个简单的富文本编辑工具了，是不是炒🐔煎🍳！</p>

<h2 id="撤销和重做">撤销和重做</h2>

<p>在窗口中添加部分文本，已经可以完成基本的富文本编辑功能了，但是此时还不支持撤销和重做，我们需要添加支持。</p>

<ul>
<li>打开 <code>Main.storyboard</code> 文件，依次找到 <code>View Controller</code> -&gt; <code>View</code> -&gt; <code>Scroll View - Text View</code> -&gt; <code>Clip View</code>  -&gt; <code>Text View</code>，选中 <code>Text View</code></li>
<li>按下快捷键 <code>Option</code> + <code>Command</code> + <code>4</code> 打开 Attribute Inspector，勾选 <code>Undo</code> 复选框</li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.45.04.png" alt="" /></p>

<p>此时运行程序，就支持 Undo 和 Redo 了！</p>

<p>在文本框添加文本以后，我们点击窗口关闭按钮，此时会提醒要不要保存文档：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.40.49.png" alt="" /></p>

<p>点击 save 按钮，会弹出一个警告窗口：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-01-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-01%2020.02.36.png" alt="" /></p>

<p>是不是对里面的内容很熟悉，这就是前面添加的 save 方法中的错误信息。</p>

<h1 id="模态窗口-modal-window">模态窗口(Modal Window)</h1>

<p>模态窗口是一种特殊的窗口，一旦显示就会独占用户的所有操作事件，一直到它被关闭，其它窗口才能响应用户的操作。</p>

<p>显示模态窗口有三种方法：</p>

<ul>
<li>以一个普通窗口的形式显示，使用 <code>NSApplication.runModal(for:)</code> 触发显示</li>
<li>以 Modal sheet 的形式显示， 调用 <code>NSWindow.beginSheet(_:completionHandler:)</code> 显示窗口</li>
<li>通过模态会话的形式，本文暂不涉及这种高级的方法</li>
</ul>

<p>其实，文档的保存和打开窗口就是模态窗帘的好例子，就像上面关闭窗口时弹出的提示保存的窗口，它出现在窗口的顶部，这就是 Modal Sheet，在本文也不讲这种模态窗口，下面我们一起实现一个显示字数和段落统计的模态窗口，它是以一个正常窗口形式显示的。</p>

<h2 id="添加一个新的窗口">添加一个新的窗口</h2>

<p>打开 <code>Main.storyboard</code> 文件，按快捷键 <code>Shift</code> + <code>Command</code> + <code>l</code> 打开 Object Library，搜索 Window Controller，拖拽 <code>Window Controller</code> 进入画布，这会生成两个场景：Window Controller Scene 和 View Controller Scene。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2008.46.15.jpg" alt="" /></p>

<p>选中刚添加的 WIndow Controller Scene 中的 Window，按快捷键 <code>Option</code> + <code>Command</code> + <code>5</code>，打开 Size Inspector，调整其宽为 300，高为 150。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2008.54.23.png" alt="" /></p>

<p>继续选中 Window，按快捷键 <code>Option</code> + <code>Command</code> + <code>4</code> 打开 Atrribute Inspector，取消 Close、Resize 和 Minimise 控件复选框的勾选，设置标题为 <code>Word Count</code>。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.02.30.png" alt="" /></p>

<p>窗口 Close 按钮会造成一个 bug：当点击这个按钮后虽然窗口已经关闭，但是应用因为没有调用 <code>stopModal</code> 方法而一直保留在模态状态，这就很尴尬了！</p>

<p>另外，不保留 Minimise 和 Resize 按钮是为了遵循 Apple 的 <a href="https://developer.apple.com/design/human-interface-guidelines/macos/overview/themes/" target="_blank">Human Interface Guidelines (HIG)</a>。</p>

<p>选中新添加的 View Controller Scene 中的 View，按下快捷键 <code>Option</code> + <code>Command</code> + <code>5</code> 打开 Size Inspector，设置宽为 300 高为 150。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.10.18.png" alt="" /></p>

<h2 id="配置-word-count-窗口">配置 Word Count 窗口</h2>

<p><code>Shift</code> + <code>Command</code> + <code>l</code> 打开 Object Library 拖拽 4 个 label 到 View 中。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.18.39.png" alt="" /></p>

<p>改变四个 label 的标题分别为：<strong>Word Count</strong>、<strong>Paragraph Count</strong>、<strong>0</strong> 和 <strong>0</strong>，同时设置它们都是右对齐，调整它们的宽为 120，这里我们不涉及自动布局，可能会出现几个警告，先不管它们。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.37.07.png" alt="" /></p>

<p>从 Object Library 推拽一个 Push Button 到 View 中，更改其标题为 OK，手动调整所有控件布局到合适的位置。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.41.34.png" alt="" /></p>

<h2 id="创建-word-count-的-view-controller-的类">创建 Word Count 的 View Controller 的类</h2>

<p><code>Command</code> + <code>n</code> 会打开一个文件新建的导航窗口，我们选择 macOS -&gt; Source -&gt; Cocoa Class，新出现的窗口中输入类的名称为 <code>WordCountViewController</code>，<strong>Subclass of</strong> 设置为 <code>NSViewController</code>，取消勾选 <code>Also create XIB for user interface</code></p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.49.32.png" alt="" /></p>

<p>点击 Next 创建新的文件。</p>

<p>打开 <code>Main.storyboard</code>，选中新添加的 View Controller，按快捷键 <code>Option</code> + <code>Command</code> + <code>3</code> 打开 Identity Inspector，选择 class 为刚添加的 <code>WordCountViewController</code> 类。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2009.52.17.png" alt="" /></p>

<h2 id="绑定计数-label-与-view-controller">绑定计数 label 与 View Controller</h2>

<p>打开新建的 <code>WordCountViewController.swift</code> 文件，在 WordCountViewCOntroller 中添加属性如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@objc</span> <span class="kr">dynamic</span> <span class="kd">var</span> <span class="nv">wordCount</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kr">@objc</span> <span class="kr">dynamic</span> <span class="kd">var</span> <span class="nv">paragraphCount</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span></code></pre></div>
<p>⚠️：两个属性添加了 <code>@objc dynamic</code> 修饰符是为了有效实现 <code>Cocoa Bindings</code><sup class="footnote-ref" id="fnref:Cocoa-Bindings-U"><a href="#fn:Cocoa-Bindings-U">1</a></sup>，否则绑定无效运行时会报错。</p>

<p>打开 <code>Main.storyboard</code> 选中与 Word Count 的 label 相对应的数字 label，按下快捷键 <code>Option</code> + <code>Command</code> + <code>7</code> 打开 Bindings Inspector:</p>

<ul>
<li>点击 <strong>Value</strong> 左边的小三角，展开 <strong>Value</strong></li>
<li><strong>Bind to</strong> 的下拉框选择 <code>Word Count View Controller</code></li>
<li>勾选 <strong>Bind to</strong></li>
<li><strong>Model Key Path</strong> 输入 <code>wordCount</code></li>
</ul>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.11.47.png" alt="" /></p>

<p>同样的步骤，与 Paragraph Count 的 label 相对应的数字 label 绑定到 <code>paragraphCount</code>:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.17.58.png" alt="" /></p>

<p>下一步设置 Window Controller 的 <strong>Storyboard ID</strong>。</p>

<p>选择 <strong>Word Count Window</strong> 的 <strong>Window Controller</strong>，然后按快捷键 <code>Option</code> + <code>Command</code> + <code>3</code> 打开 Identity Inspector，更改 <strong>Storyboard ID</strong> 的值为 <code>Word Count Window Controller</code>。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.20.24.png" alt="" /></p>

<h2 id="显示和关闭模态窗口">显示和关闭模态窗口</h2>

<p>前面的准备工作做足了，那本节讲讲如何召唤和轰走模态窗口。</p>

<h3 id="出来吧-模态窗口">出来吧，模态窗口</h3>

<p>打开 <strong>ViewController.swift</strong> 文件，在类中添加以下属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBOutlet</span> <span class="kd">var</span> <span class="nv">text</span><span class="p">:</span> <span class="n">NSTextView</span><span class="o">!</span></code></pre></div>
<p>同时添加以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">showWordCountWindow</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">AnyObject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1</span>
    <span class="kd">let</span> <span class="nv">storyboard</span> <span class="p">=</span> <span class="n">NSStoryboard</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&#34;Main&#34;</span><span class="p">,</span> <span class="n">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">wordCountWindowController</span> <span class="p">=</span> <span class="n">storyboard</span><span class="p">.</span><span class="n">instantiateController</span><span class="p">(</span><span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&#34;Word Count Window Controller&#34;</span><span class="p">)</span> <span class="k">as</span><span class="o">!</span> <span class="n">NSWindowController</span>

    <span class="k">if</span> <span class="kd">let</span> <span class="nv">wordCountWindow</span> <span class="p">=</span> <span class="n">wordCountWindowController</span><span class="p">.</span><span class="n">window</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">textStorage</span> <span class="p">=</span> <span class="n">text</span><span class="p">.</span><span class="n">textStorage</span> <span class="p">{</span>

        <span class="c1">// 2</span>
        <span class="kd">let</span> <span class="nv">wordCountViewController</span> <span class="p">=</span> <span class="n">wordCountWindow</span><span class="p">.</span><span class="n">contentViewController</span> <span class="k">as</span><span class="o">!</span> <span class="n">WordCountViewController</span>
        <span class="n">wordCountViewController</span><span class="p">.</span><span class="n">wordCount</span> <span class="p">=</span> <span class="n">textStorage</span><span class="p">.</span><span class="n">words</span><span class="p">.</span><span class="bp">count</span>
        <span class="n">wordCountViewController</span><span class="p">.</span><span class="n">paragraphCount</span> <span class="p">=</span> <span class="n">textStorage</span><span class="p">.</span><span class="n">paragraphs</span><span class="p">.</span><span class="bp">count</span>

        <span class="c1">// 3</span>
        <span class="n">NSApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">runModal</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="n">wordCountWindow</span><span class="p">)</span>
        <span class="c1">// 4</span>
        <span class="n">wordCountWindow</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>打开 <strong>Main.storyboard</strong> 文件，选中添加 Text View 的 View Controller，按住 <code>Ctrl</code> 键，点击 View Controller 按钮，不松手拖动至 Text View 上松手，此时会弹出一个绑定选择框，里面就包含了我们刚添加的 text 属性，点击它，这就完成了 Text View 控件与 text 属性的绑定</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2010.34.58.png" alt="" /></p>

<p>上面添加的方法，这里一步一步的说明一下：</p>

<ol>
<li>使用之前配置的 <strong>Storyboard ID</strong> 实例化一个 <strong>Word Count Window Controller</strong> 对象</li>
<li>从 text view 的 storage 对象中获取字数统计和段落统计，将值设置到 <strong>wordCountViewController</strong> 的两个属性 <code>wordCount</code> 和 <code>paragraphCount</code></li>
<li>模态方式显示 word count 窗口</li>
<li>一旦模态状态结束就关闭模态窗口，这里需要注意，只要模态不结束这一句就不会执行</li>
</ol>

<h3 id="消失吧-模态窗口">消失吧，模态窗口</h3>

<p>这里我们需要添加结束模态的实现，打开文件 <strong>WordCountViewController.swift</strong>，添加以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">dismissWordCountWindow</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="n">NSButton</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSApplication</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">stopModal</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p>下面我们将此方法与上面添加的 OK 按钮进行绑定。</p>

<p>打开 <code>Main.storyboard</code>，选中 OK 按钮，点击它，同时按住 <code>Ctrl</code> 键，拖动鼠标至 <strong>Word Count View Controller</strong> 的按钮上，在弹出的绑定窗口上选择刚添加的方法 <code>dismissWordCountWindow</code> 即可完成绑定。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2011.01.15.png" alt="" /></p>

<h3 id="添加召唤模态的符咒">添加召唤模态的符咒</h3>

<p>这里我们以菜单栏的菜单项的方式触发模态窗口。</p>

<p>打开 <strong>Main.storyboard</strong> 文件，找到 <strong>Main Menu</strong>，点击展开 <strong>Edit</strong>，然后进行以下操作：</p>

<ol>
<li><code>Shift</code> + <code>Command</code> + <code>l</code> 打开 Object Library，搜索 <code>Menu Item</code>，拖动到最下面的位置，添加一个新的菜单项，选中它</li>
<li><code>Option</code> + <code>Command</code> + <code>4</code> 打开它的 <strong>Attribute Inspector</strong>，更改标题为 <strong>Word Count</strong>，同时配置快捷键为 <strong>⌘K</strong></li>
</ol>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2011.20.01.png" alt="" /></p>

<p>下面我们需要为其绑定上面定义的方法 <code>showWordCountWindow</code>，点击菜单项 <strong>Word Count</strong>，同时按住 <code>Ctrl</code> 键，拖动至 <strong>Application Scene</strong> 下的 <strong>First Responder</strong> 上松手，在弹出的列表中找到方法 <code>showWordCountWindow</code>，选择它，这就完成了触发模态的绑定：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2011.30.40-1.png" alt="" /></p>

<h3 id="召唤模态">召唤模态</h3>

<p>编译运行程序，在窗口中输入一些内容，比如：</p>

<blockquote>
<p>望岳</p>

<p>唐代：杜甫</p>

<p>岱宗夫如何？齐鲁青未了。</p>

<p>造化钟神秀，阴阳割昏晓。</p>

<p>荡胸生曾云，决眦入归鸟。</p>

<p>会当凌绝顶，一览众山小。</p>
</blockquote>

<p>菜单栏 Edit -&gt; Word Count (或者按快捷键 <code>Command</code> + <code>k</code>) 就能打开统计字数的模态窗口。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-02%2013.13.18.png" alt="" /></p>

<p>点击 OK 就可以“轰走”模态窗口了。</p>

<h1 id="总结">总结</h1>

<p><a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-04-02-5kmEditor.zip" target="_blank">点我</a>可以下载本文中的工程。本文涉及到了以下内容：</p>

<ul>
<li>MVC 的设计模式</li>
<li>多窗口应用的实现</li>
<li>Interface Builder 和 代码 两种方式控制窗口位置</li>
<li>控件与类属性的绑定，控件 Action 与类方法的绑定</li>
<li>窗口形式的 macOS 的常规开发姿势</li>
<li>如何代码控制显示模态窗口</li>
<li>富文本编辑的简单实现</li>
</ul>

<p>希望对大家学习 macOS 开发有所帮助！感谢您的阅读！</p>

<h1 id="参考">参考</h1>

<p><a href="https://www.raywenderlich.com/613-windows-and-windowcontroller-tutorial-for-macos" target="_blank">Windows and WindowController Tutorial for macOS</a></p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:Cocoa-Bindings-U">Cocoa Bindings 是 UI 开发中一个强大的技术，主要用于数据与 UI 的绑定，可以阅读 <a href="https://www.raywenderlich.com/141297/cocoa-bindings-macos" target="_blank"> Cocoa Bindings on macOS </a> 了解更多相关内容，后面有时间十里会专门写一篇相关的文章与大家一起学习！ <a class="footnote-return" href="#fnref:Cocoa-Bindings-U"><sup>[return]</sup></a></li>
</ol>
</div>
]]></content>
		</item>
		
		<item>
			<title>PlatformIO 是什么</title>
			<link>https://www.smslit.top/2019/03/30/what-is-pio/</link>
			<pubDate>Sat, 30 Mar 2019 17:45:14 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/30/what-is-pio/</guid>
			<description>PlatformIO is an open source ecosystem for IoT development. Cross-platform IDE and unified debugger. Remote unit testing and firmware updates. PlatformIO 是一个用于物联网开发的开源生态系统。它提供跨平台的开发环境和统一的调试器，还支持远程单元测试和固件</description>
			<content type="html"><![CDATA[

<blockquote>
<p>PlatformIO is an open source ecosystem for IoT development.</p>

<p>Cross-platform IDE and unified debugger.</p>

<p>Remote unit testing and firmware updates.</p>
</blockquote>

<p><a href="https://platformio.org" target="_blank">PlatformIO</a> 是一个用于物联网开发的开源生态系统。它提供跨平台的开发环境和统一的调试器，还支持远程单元测试和固件更新&hellip;</p>

<h1 id="platformio-简介">PlatformIO 简介</h1>

<figure class="right">
    <img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-30-platformio-ide-vscode.png"/> 
</figure>


<p>PlatformIO 是独立于平台运行的，实际上它只依赖于 python，然而 python 在 macOS、linux 和 windows 都能完美适配. 也就是说 PlatformIO 的工程从一个电脑很容易迁移到另一个电脑，只需要拷贝再使用 PlatformIO 就能完美打开，不管团队中的成员使用什么操作系统 PlatformIO 可以让工程共享变得异常简单. 除此之外, PlatformIO 不仅可以在笔记本和台式机上运行，同样可以运行在没有显示桌面的服务器。PlatformIO 的核心(PlatformIO Core) 就是一个终端程序, 它能配合您喜欢的多款云 IDE、桌面 IDE 或者 通用代码编辑器构建 PlatformIO 的 IDE，比如 Atom, CLion, Eclipse, Emacs, NetBeans, Qt Creator, Sublime Text, VIM, Visual Studio, VSCode, etc.</p>

<p>目前官方推荐的 IDE 使用方案就是 VSCode + PlatformIO IDE 插件，界面如右图：</p>

<ul>
<li>PIO 统一的调试器，可以零配置的对支持硬件调试的的嵌入式开发板进行调试工作，调试器支持很多的架构和开发平台</li>
<li>跨平台的代码构建系统对系统软件没有额外的依赖: 600+ 嵌入式开发板, 30+ 开发平台, 15+ 框架</li>
<li>C/C++ 智能代码补全，语法检查，快速重构以及代码跳转满足快速专业的开发需求</li>
<li>VSCode 提供多工程和文件管理的支持和统一而流畅的使用体验，并且支持多种色彩主题，总有您喜欢和适合您的</li>
<li>内建的终端支持 PlatformIO Core 命令行工具，并且支持强大的串口调试器</li>
</ul>

<p>尽管 PlatformIO 可以运行在不同的操作系统中，但从开发的角度看更重要的是它支持多少开发板和单片机。概括来说: PlatformIO 支持大约 600+ 个<a href="https://docs.platformio.org/en/latest/boards/index.html" target="_blank">开发板</a>和市面上流行的支持跨平台的 30 个<a href="https://docs.platformio.org/en/latest/platforms/index.html#" target="_blank">开发平台</a>。</p>

<ul>
<li>支持的嵌入式开发板列表: <a href="https://docs.platformio.org/en/latest/boards/index.html" target="_blank">Boards</a></li>
<li>支持的单片机平台和桌面平台: <a href="https://docs.platformio.org/en/latest/platforms/index.html#" target="_blank">Platforms</a></li>
</ul>

<p>同时，PlatformIO 还提供大量的开发库，目前超过了 6000 个，为了方便新手入门开发，他们也同样提供代码例程。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-30-support.png" alt="" /></p>

<h1 id="platformio-解决的问题">PlatformIO 解决的问题</h1>

<ul>
<li>嵌入式开发的世界让很多人望而却步的主要原因是针对某一个单片机或开发板开发环境复杂的配置过程：交叉编译链工具下载、安装和配置，另外还得使用厂商独有的 IDE (有时还不是免费的) ，还有有时还不得不使用 IDE 只支持的 Windows</li>
<li>多个硬件平台 (单片机, 开发板) 需要不同交叉编译链工具和开发环境, 所有相应的开发人员需要花费大量精力在配置新的开发环境上</li>
<li>为了学习如何使用常规的传感器或执行器件等外设，需要花时间查找合适的库和例程</li>
<li>每个团队成员可能会使用不用的操作系统，这就为他们之间共享成果形成阻碍（当然国内现状是公司逼着员工使用统一的操作系统，哈哈🤣）</li>
</ul>

<h1 id="platformio-如何工作">PlatformIO 如何工作</h1>

<p>这里不深入说 PlatformIO 的实现细节, 使用 PlatformIO 时工程的工作流程如下：</p>

<ul>
<li>用户在 “platformio.ini” (工程配置文件) 中指定开发平台（开发板）</li>
<li>根据配置文件中的开发板（一个工程可以配置多个开发板），PlatformIO 会自动下载并安装对应的交叉编译链工具以及调试工具.</li>
<li>用户编写代码，PlatformIO 来保证所有指定开发板的编译、调试和上传工作</li>
</ul>

<h1 id="platformio-需要用户进行的选择">PlatformIO 需要用户进行的选择</h1>

<ul>
<li>决定使用什么系统运行 PlatformIO 来进行单片机开发，需要进行相应系统的安装工作</li>
<li>选择使用什么编辑器进行代码编写，可以是极简通用的代码编辑器，也可以您喜欢的桌面 IDE</li>
<li>专注于代码开发，显著简化使用开发平台和单片机的过程</li>
</ul>

<h1 id="platformio-的相关报道">PlatformIO 的相关报道</h1>

<blockquote>
<p>通常情况下不同的单片机需要不同的开发工具，比如 Arduino 使用的是 <strong>Arduino IDE</strong>，有些高级用户为了更好的进行代码工程管理，也会配置基于 Eclipse 的图形界面的开发环境。有时同步支持不同的单片机比较困难，您可能觉得如果有一个统一的开发工具那该多好呀！ PlatformIO 就是这么一个开源的进行单片机嵌入式开发的生态工具。</p>

<p>PlatformIO 是一个跨平台的代码构建工具和库管理工具，并且支持像 Arduino 和 MBED 这样的平台。他们关心可以跨 macOS、windows 和 linux 三个平台工作的工具链、调试器和开发平台，它支持超过 200 个的开发板和超过 15 种的开发平台以及 10 中开发框架，所以绝大多数流行的开发板都是包含其中的。他们在收集整理开发库上倾注了大量精力，以至于您的工程可以使用上百种开发库。另外，也有很多代码例程提供方便您入门单片机开发。PlatformIO 最初以命令行的形态进行开发，现如今它可以完美配合其它的 IDE 进行使用，比如 Eclipse、Visual Studio，最近他们最新发布了基于 Atom 的 PlatformIO 开发环境。</p>
</blockquote>

<h1 id="platformio-的荣誉">PlatformIO 的荣誉</h1>

<p>PlatformIO 曾提名 <a href="https://www.postscapes.com/internet-of-things-software-guide/" target="_blank"><sup>2015</sup>&frasl;<sub>16</sub> IOT 年度最佳开发软件和工具奖</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之 Swift 的 Codable</title>
			<link>https://www.smslit.top/2019/03/24/macOS-dev-swift-codable/</link>
			<pubDate>Sun, 24 Mar 2019 16:49:16 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/24/macOS-dev-swift-codable/</guid>
			<description>近日研究了一下如何将自定义类型数据持久化，在研究过程中发现 Swift 的 Codable 真的很方便，觉得有必要写一写这个 Codable，在本文一起探讨一下以下三个方</description>
			<content type="html"><![CDATA[

<p>近日研究了一下如何将自定义类型数据持久化，在研究过程中发现 Swift 的 Codable 真的很方便，觉得有必要写一写这个 <strong>Codable</strong>，在本文一起探讨一下以下三个方面：</p>

<ul>
<li>什么是 Swift 的 Codable</li>
<li>怎么使用 Codable</li>
<li>Codable 给我们带来什么便利</li>
</ul>

<h1 id="开发平台">开发平台</h1>

<ul>
<li>macOS 10.14.4</li>
<li>Swift 5</li>
<li>xcode 10.2</li>
</ul>

<h1 id="swift-的-codable">Swift 的 Codable</h1>

<blockquote>
<p>In a nutshell, Encoding is the process of transforming your own custom type, class or struct to external data representation type like JSON or plist or something else &amp; Decoding is the process of transforming external data representation type like JSON or plist to your own custom type, class or struct.</p>
</blockquote>

<h2 id="可以使用的协议">可以使用的协议</h2>

<p>Swift 的标准库中包含了用于自定义类型(结构体、类)与其它表示形式(JSON、Property List 或 二进制)的数据之间相互转换的协议：</p>

<ul>
<li><p><strong>Encodable</strong>: 用于自定义类型向 JSON 或 Property List 的转换，协议包含一个方法</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">encode</span><span class="p">(</span><span class="n">to</span><span class="p">:)</span> </code></pre></div></li>

<li><p><strong>Decodable</strong>: 用于自 JSON 或 Property List 数据向自定义类型的转换，协议包含一个方法</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">init</span><span class="p">(</span><span class="n">from</span><span class="p">:)</span></code></pre></div></li>

<li><p><strong>Codable</strong>: 包含 Encodable 和 Decodable 两方面的转换，其定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">typealias</span> <span class="n">Codable</span> <span class="p">=</span> <span class="n">Decodable</span> <span class="o">&amp;</span> <span class="n">Encodable</span></code></pre></div></li>
</ul>

<p>使用 Codable 协议 的 Encodable 和 Decodable，可以让我们轻松实现自定义数据类型的序列化以及得到相应数据类型的实例对象。按照字面意思，我们后面将数据类型实例向 JSON 或 Property List 转换的过程称为编码，反之，称为解码！</p>

<h2 id="遵循协议的类型">遵循协议的类型</h2>

<p>如果我们想要实现自定义类型或数据模型的编码和解码，必须遵循 Codable 协议！Swift 基本的内建类型已经是 Codable 的了，比如 <code>String</code>、<code>Int</code>、<code>Double</code>、<code>Date</code> 和 <code>Data</code>。另外像 <code>Array</code>、<code>Dictionary</code> 和 <code>Optional</code> 也都是遵循 Codable 协议的，可以进行编码和解码。</p>

<p>如下自定义的结构体 Person 和 Team，遵循 Codable 协议，同时结构体的所有属性要么是标准的 Codable 类型，要么包含 Codable 类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Person</span> <span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">id</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">name</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">age</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">isMale</span><span class="p">:</span> <span class="nb">Bool</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Team</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">master</span><span class="p">:</span> <span class="n">Person</span>
    <span class="kd">var</span> <span class="nv">memebers</span><span class="p">:</span> <span class="p">[</span><span class="n">Person</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>
<h2 id="codable-类型的编解码">Codable 类型的编解码</h2>

<p>对于 Codable 的类型，需要使用相应的编码器对我们的数据进行编码和解码，具体细节可以参考后面的小节，有两种编码器可用：</p>

<ul>
<li><strong>JSON</strong>

<ul>
<li><code>JSONEncoder</code>: 将 Codable 类型数据编码为 JSON 数据</li>
<li><code>JSONDecoder</code>: 将 JSON 数据解码为指定的 Codable 类型数据</li>
</ul></li>
<li><strong>Property List</strong>

<ul>
<li><code>PropertyListEncoder</code>: 将 Codable 类型数据编码为 plist 数据</li>
<li><code>PropertyListDecoder</code>: 将 plist 数据解码为指定的 Codable 类型数据</li>
</ul></li>
</ul>

<h1 id="codable-的使用">Codable 的使用</h1>

<p>下面我们就一起研究一下 Codable 的使用，这里我们只尝试 Codable 类型数据与 JSON 数据的编码解码的实现。</p>

<h2 id="编码和解码">编码和解码</h2>

<h3 id="使用-jsonencoder-编码">使用 <code>JSONEncoder</code> 编码</h3>

<p>非常简单，只需调用 <code>JSONEncoder</code> 的 <code>encode(_:)</code> 方法就能将 Codable 类型转换为 JSON 数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">jack</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&#34;Jack&#34;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">isMale</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">jackData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">jack</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">jackData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>可以看到打印出转换得到的 JSON 字符串数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;age&#34;</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span><span class="nt">&#34;id&#34;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="nt">&#34;isMale&#34;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;Jack&#34;</span><span class="p">}</span></code></pre></div>
<p>是不是很方便，解码同样如此简单！</p>

<h3 id="使用-jsondecoder-解码">使用 <code>JSONDecoder</code> 解码</h3>

<p>只需要调用 <code>JSONDecoder</code> 实例的 <code>decode(_:from:)</code> 方法就能将 JSON 对象转换得到指定类型的实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">jsonString</span> <span class="p">=</span> <span class="s">&#34;&#34;&#34;
</span><span class="s">{
</span><span class="s">    &#34;</span><span class="n">id</span><span class="s">&#34;: 2,
</span><span class="s">    &#34;</span><span class="n">name</span><span class="s">&#34;: &#34;</span><span class="n">lucy</span><span class="s">&#34;,
</span><span class="s">    &#34;</span><span class="n">age</span><span class="s">&#34;: 11,
</span><span class="s">    &#34;</span><span class="n">isMale</span><span class="s">&#34;: false
</span><span class="s">}
</span><span class="s">&#34;&#34;&#34;</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">json</span> <span class="p">=</span> <span class="n">jsonString</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">lucy</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">lucy</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>打印结果，如您所料，将 JSON 字符串成功的解码为了 Person 实例对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">Person</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&#34;lucy&#34;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">isMale</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span></code></pre></div>
<h3 id="codable-使用的基本步骤">Codable 使用的基本步骤</h3>

<p>综上过程，我们可以总结一下，要使用 Swift 的特性其实很简单，分两步：</p>

<ul>
<li>自定义类型遵循 Codable 协议</li>
<li>使用编码器实现自定义类型数据的编码和解码</li>
</ul>

<h2 id="使用-codingkeys-来选择部分属性是-codable-的">使用 CodingKeys 来选择部分属性是 Codable 的</h2>

<p>也许此时此刻您可能会想：</p>

<ul>
<li>如果不想把自定义数据所有的属性编码到 JSON 该怎么办？</li>
<li>如果 JSON 数据中的键名与自定义类型中的属性名不一致怎么办？</li>
</ul>

<p>请放心，您想到的，Apple 同样照顾到了！就是本节要讲的 <code>CodingKeys</code></p>

<blockquote>
<p>Codable types can declare a special nested enumeration named CodingKeys that conforms to the CodingKey protocol. When this enumeration is present, its cases serve as the authoritative list of properties that must be included when instances of a codable type are encoded or decoded. The names of the enumeration cases should match the names you&rsquo;ve given to the corresponding properties in your type.</p>
</blockquote>

<p><code>CodingKeys</code> 是我们在自定义数据类型中定义的枚举，有以下两点要求：</p>

<ul>
<li>枚举元素类型是 String，并且遵循 CodingKey 协议、</li>
<li>枚举元素的名称必须与自定义类型中的属性名称保持一致</li>
</ul>

<p>那么我们回过头来看一下前面的两个问题怎么解决：</p>

<ul>
<li>CodingKeys 中的元素与自定义数据类型中的属性名称对应，只要删除对应属性的枚举元素就可以实现编码时对应属性的忽略，这样就解决了第一个问题，但是要注意，不编码的属性必须赋予默认值</li>
<li>为 CodingKeys 中枚举元素自定义 String 值与 JSON 数据中的键名对应起来，就能解决第二个问题。</li>
</ul>

<p>假如想为 Person 结构体添加一个 <code>description</code> 的属性，同时不想让它参与编码和解码，另外 JSON 数据中的键名是中文的，我们可以重构 Person 类：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Person</span> <span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">id</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">name</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">age</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">isMale</span><span class="p">:</span> <span class="nb">Bool</span>
    <span class="kd">var</span> <span class="nv">description</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&#34;person&#34;</span>
    
    <span class="kd">enum</span> <span class="nc">CodingKeys</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">id</span> <span class="p">=</span> <span class="s">&#34;身份证号&#34;</span>
        <span class="k">case</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&#34;姓名&#34;</span>
        <span class="k">case</span> <span class="n">age</span> <span class="p">=</span> <span class="s">&#34;年龄&#34;</span>
        <span class="k">case</span> <span class="n">isMale</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>我们看一下将自定义数据转换为 JSON 会是怎样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">tim</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&#34;tim&#34;</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">isMale</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">timData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">tim</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">timData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>编码得到的 JSON 数据如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;姓名&#34;</span><span class="p">:</span><span class="s2">&#34;tim&#34;</span><span class="p">,</span><span class="nt">&#34;isMale&#34;</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="nt">&#34;年龄&#34;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="nt">&#34;身份证号&#34;</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span></code></pre></div>
<h2 id="自定义-encode-和-decode">自定义 encode 和 decode</h2>

<p>我们定义一个 Size 结构体、Point 结构体和 Rect 结构体如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Size</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Double</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Point</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Double</span>
    <span class="kd">var</span> <span class="nv">y</span><span class="p">:</span> <span class="nb">Double</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Rect</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">position</span><span class="p">:</span> <span class="n">Point</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="n">Size</span>
<span class="p">}</span></code></pre></div>
<p>我们利用一开始定义的 Rect 结构体声明一个 rect，坐标在原点，宽高都为 2.0，并将其转换为 JSON 数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rect</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">rectData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">rectData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>team 对应的 JSON 字符串如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;position&#34;</span><span class="p">:{</span><span class="nt">&#34;x&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nt">&#34;y&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span><span class="nt">&#34;size&#34;</span><span class="p">:{</span><span class="nt">&#34;width&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="nt">&#34;height&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">}}</span></code></pre></div>
<p>但是呢，十里不想让 JSON 数据中 x 和 y 嵌套在 positon 中，也不想 width 和 height 嵌套在 size 中，而是像下面的样子：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span>
    <span class="nt">&#34;x&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;y&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="nt">&#34;width&#34;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="nt">&#34;height&#34;</span><span class="p">:</span> <span class="mf">2.0</span>
<span class="p">}</span></code></pre></div>
<p>要实现这种需求，我们必须自定义 <code>Encodable</code> 协议的 <code>encode(_:)</code> 方法 和 <code>Decodable</code> 协议的 <code>init(from:)</code> 方法，实现自定义的编码解码逻辑，大体分下面几步：</p>

<ul>
<li>定义 CodingKeys 枚举，元素与目标 JSON 数据的键名对应，定义 x 和 y 而不是 position，定义 width 和 height 而不是 size</li>
<li>删除 Rect 定义中的 Codable</li>
<li>扩展 Rect 遵循 Encodable 协议，并实现 <code>encode(_:)</code> 方法</li>
<li>扩展 Rect 遵循 Decodable 协议，并实现 <code>init(from:)</code> 方法</li>
</ul>

<p>最终 Rect 定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Rect</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">position</span><span class="p">:</span> <span class="n">Point</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="n">Size</span>
    
    <span class="kd">enum</span> <span class="nc">CodingKeys</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">x</span>
        <span class="k">case</span> <span class="n">y</span>
        <span class="k">case</span> <span class="n">width</span>
        <span class="k">case</span> <span class="n">height</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Rect</span><span class="p">:</span> <span class="n">Encodable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="n">encoder</span><span class="p">:</span> <span class="n">Encoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">container</span> <span class="p">=</span> <span class="n">encoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">CodingKeys</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="nc">Rect</span><span class="p">:</span> <span class="n">Decodable</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">from</span> <span class="n">decoder</span><span class="p">:</span> <span class="n">Decoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">CodingKeys</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">x</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">position</span> <span class="p">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">width</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">width</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">height</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">Double</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">height</span><span class="p">)</span>
        <span class="n">size</span> <span class="p">=</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">height</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>测试一下编码实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rect</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">rectData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">rectData</span><span class="p">,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>得到的 JSON 数据的打印结果为：</p>
<div class="highlight"><pre class="chroma"><code class="language-Json" data-lang="Json"><span class="p">{</span><span class="nt">&#34;y&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nt">&#34;x&#34;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nt">&#34;width&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="nt">&#34;height&#34;</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span></code></pre></div>
<p>测试一下解码的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rectString</span> <span class="p">=</span> <span class="s">&#34;&#34;&#34;
</span><span class="s">{
</span><span class="s">    &#34;</span><span class="n">x</span><span class="s">&#34;: 3,
</span><span class="s">    &#34;</span><span class="n">y</span><span class="s">&#34;: 3,
</span><span class="s">    &#34;</span><span class="n">width</span><span class="s">&#34;: 2.5,
</span><span class="s">    &#34;</span><span class="n">height</span><span class="s">&#34;: 2.5
</span><span class="s">}
</span><span class="s">&#34;&#34;&#34;</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">json</span> <span class="p">=</span> <span class="n">rectString</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">newRect</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">Rect</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">json</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">newRect</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>得到的 newRect 实例对象打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">__lldb_expr_21</span><span class="p">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">__lldb_expr_21</span><span class="p">.</span><span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.5</span><span class="p">))</span></code></pre></div>
<h1 id="codable-带来的福利">Codable 带来的福利</h1>

<p>上面说了这么多的 Codable ，到底我们能用它来干什么呢，最主要的两个应用方向就是自定义类型数据持久化和网络通信。</p>

<h2 id="数据持久化">数据持久化</h2>

<p>其中一种常用的数据持久化方式就是属性列表(Property List)，<code>UserDefaults.standard</code> 适合存储轻量级的本地数据，其提供了与默认数据库相交互的编程接口。其实它存储在应用程序的一个plist文件里，路径为应用沙盒Document目录平级的 <code>/Library/Prefereces</code> 里。另外，其只能存储可以序列化的数据类型，比如我们一开始说的那些基本类型，也就是 Codable 的，所以一旦我们自定义的数据类型遵循了 Codable 协议，即可序列化了，那我们的自定义类型的数据可以自由存取了。</p>

<p><strong>注意：</strong></p>

<ul>
<li>使用这种方式一般用于存储应用程序的配置信息</li>
<li>手动调用 <code>synchronize</code> 方法可以立马将数据持久化存储</li>
</ul>

<p>这里只是以这种数据持久化为例，讲一下如何持久化自定义数据类型的数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">rectDemo</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">demoData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">rectDemo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="kr">set</span><span class="p">(</span><span class="n">demoData</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="s">&#34;rect-test&#34;</span><span class="p">)</span>
    <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;saved successfully!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">rectJson</span> <span class="p">=</span> <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="s">&#34;rect-test&#34;</span><span class="p">)</span> <span class="k">as</span><span class="p">?</span> <span class="n">Data</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">newRect</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">Rect</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">rectJson</span><span class="p">)</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">newRect</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>可以看到打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">saved</span> <span class="n">successfully</span><span class="o">!</span>
<span class="n">Rect</span><span class="p">(</span><span class="n">position</span><span class="p">:</span> <span class="n">__lldb_expr_29</span><span class="p">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">size</span><span class="p">:</span> <span class="n">__lldb_expr_29</span><span class="p">.</span><span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">))</span></code></pre></div>
<h2 id="网络通信">网络通信</h2>

<p>HTTP/HTTPS 网络通信中 JSON 是常用的交互数据类型，假如我们编写一个网络接口，当外部请求的时候，我们为其返回一个响应，如果我们定义一个 Codable 的 Response 类型，可以方便生成响应数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">struct</span> <span class="nc">Response</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ststus</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">var</span> <span class="nv">message</span><span class="p">:</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">res</span> <span class="p">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">ststus</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="s">&#34;OK&#34;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">resData</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></code></pre></div>
<h1 id="总结">总结</h1>

<p>Swift 4 开始支持的 Codable 大大简化了对自定义类型数据序列化的实现，相信您会用得到！</p>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之本地消息通知</title>
			<link>https://www.smslit.top/2019/03/17/macOS-dev-local-notification/</link>
			<pubDate>Sun, 17 Mar 2019 11:33:15 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/17/macOS-dev-local-notification/</guid>
			<description>macOS 中的消息推送分为本地消息通知和远程消息通知，本文十里将介绍一下本地消息通知，展示一些常规的使用方法，方便大家了解本地消息推送的实现过程。 开</description>
			<content type="html"><![CDATA[

<p>macOS 中的消息推送分为本地消息通知和远程消息通知，本文十里将介绍一下本地消息通知，展示一些常规的使用方法，方便大家了解本地消息推送的实现过程。</p>

<h1 id="开发平台">开发平台</h1>

<ul>
<li>macOS 10.14.3</li>
<li>swift 4.2.1</li>
<li>xcode 10.1</li>
</ul>

<h1 id="简单介绍">简单介绍</h1>

<p>本地消息通知(Notification)是由 App 请求用户消息中心(User Notifications Center)而推送的，我们的 App 既是消息的提供者又是消息的接受者，一个 App 最多支持 64 个消息通知！</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/sq37y.svg" alt="" /></p>

<h2 id="消息通知组成">消息通知组成</h2>

<p>一个消息通知一般在显示上看由标题(title)、副标题(subtitle)、消息内容、logo和按钮组成。另外还包括提示音的设置和用户信息(用于传递数据)。</p>

<h2 id="消息通知的类型">消息通知的类型</h2>

<p>消息通知主要有三种类型：无、横幅(barner)和提示(alert)</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/gvq8q.png" alt="" /></p>

<p>默认情况下使用 <em>横幅</em> 样式！</p>

<h2 id="通知推送的触发条件">通知推送的触发条件</h2>

<p>消息推送的触发条件有多种方式，消息中心会根据指定的触发条件推送消息：</p>

<ul>
<li>直接推送通知，一般是根据 App 中自身逻辑灵活手动触发</li>
<li>按照指定时间间隔推送通知，可以设置为重复或者不重复</li>
<li>根据指定的日期时间推送通知，可以设置是否重复</li>
<li>根据地理位置推送通知，通常要设置经纬度坐标以及范围(方圆距离)</li>
</ul>

<h2 id="消息通知的处理">消息通知的处理</h2>

<p>本地消息通知通过用户消息通知中心的消息队列进行管理，根据通知的触发条件推送的消息会依次存放到这个消息队列，然后依次通知给 App，而 App 可以通过对消息中心的代理实现代理方法对消息通知行为进行相应处理。</p>

<h2 id="消息通知的管理">消息通知的管理</h2>

<p>消息通知的管理由通知中心完成，包括消息通知的注册、删除、推送以及权限。</p>

<h3 id="消息通知的注册">消息通知的注册</h3>

<p>要想让 App 配置好的通知能够按照预期进行推送，必须要将通知注册到通知中心。</p>

<h3 id="消息通知的推送">消息通知的推送</h3>

<p>通知中心会时刻监听着每个消息通知，一旦满足触发条件就会像消息通知队列中推送消息。</p>

<h3 id="消息通知的删除">消息通知的删除</h3>

<p>有时需要关闭已经注册的消息通知的推送活动，通知中心可以将指定消息通知删除，不再监管。</p>

<h3 id="消息通知的权限">消息通知的权限</h3>

<p>在 macOS 的系统偏好设置中可以设置指定应用的通知权限：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/n1q5z.png" alt="" /></p>

<p>这些通知权限在 App 中可以由通知中心进行管理，通常就是消息弹窗和声音播放两点。</p>

<h2 id="关于实现">关于实现</h2>

<p>上面说了本地消息通知的一些基本概念和简单介绍，那么实现本地消息通知的流程就很清楚了：</p>

<ul>
<li>消息通知的配置，包括触发条件、消息通知中内容</li>
<li>注册消息通知到消息通知中心</li>
<li>实现消息通知中心的代理方法，从而完成对消息的处理</li>
</ul>

<p>目前看 Apple 官方的开发接口有两套：</p>

<ul>
<li>传统的消息通知接口，在 <code>Foundation</code> 框架中实现，SDK 支持明确标记 <code>macOS 10.8–10.14</code> <code>Deprecated</code>，也就是说 10.14 之后便废弃了</li>
<li>最新的消息通知接口，与多个软件平台(iOS、watchOS、tvOS)共用，使用 <code>UserNotifacations</code> 框架，SDK 支持

<ul>
<li>iOS 10.0+</li>
<li>macOS 10.14+</li>
<li>tvOS 10.0+</li>
<li>watchOS 3.0+</li>
</ul></li>
</ul>

<p>不难看出 Apple 的软件开发生态蓝图的宏大，这不在本文讨论范围内！在下面会以一个简单的例子介绍使用两套方法的实现过程，不过会着重讲新的接口！</p>

<h1 id="示例">示例</h1>

<p>下面我们通过两个简单的 Demo 看一下如何实现本地消息通知。两个 Demo 中我们分别设置一个按钮，并分别绑定 各自的 Action，一个 Action 中按照传统的方式实现消息通知，另一个 Action 中按照新的方式实现。这个消息通知具有以下实现：</p>

<ul>
<li>立马推送的</li>
<li>使用系统声音作为提示音，消息推送时播放</li>
<li>通知携带数据在用户信息中</li>
<li>通知设置两个按钮，一个是关闭一个是确定按钮，点击后打印传递的用户信息</li>
</ul>

<h2 id="传统实现方式">传统实现方式</h2>

<ul>
<li>打开 Xcode 新建一个使用 storyboard 的工程，我们就命名为 <code>OldNotificationDemo</code></li>
<li>打开 <code>Main.storyboard</code> ，在 view controller 中添加一个按钮，按钮标题改为 <code>通知</code></li>
<li>为两个按钮绑定 action，在 <code>Main.storyboard</code> 中按下快捷键 <code>Option</code> + <code>Command</code> + 回车键 打开辅助编辑器，按住 <code>ctrl</code> 键的同时鼠标左键拖动按钮到 ViewController.swift 的 ViewController 类中绑定 action 为 <code>oldNotificationAction</code></li>
</ul>

<h3 id="更改通知样式">更改通知样式</h3>

<p>传统接口下，App 默认使用横幅的通知样式，但是横幅的通知只能显示 reply button 和 other button，但是我们想自己定义一个按钮，只能使用提示的样式，所以我们首先更改一下通知样式，需要在 Info.plist 文件中添加一个新的键——<code>NSUserNotificationAlertStyle</code>，值设置为 <code>alert</code>:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/pg2li.png" alt="" /></p>

<h3 id="oldnotificationaction-实现">oldNotificationAction 实现</h3>

<p>下面在 oldNotificationAction 中添加使用传统方法消息通知的实现:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">oldNotificationAction</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">Any</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">userNotification</span> <span class="p">=</span> <span class="n">NSUserNotification</span><span class="p">()</span>
    
    <span class="n">userNotification</span><span class="p">.</span><span class="n">title</span> <span class="p">=</span> <span class="s">&#34;传统方式&#34;</span>
    <span class="n">userNotification</span><span class="p">.</span><span class="n">subtitle</span> <span class="p">=</span> <span class="s">&#34;old&#34;</span>
    <span class="n">userNotification</span><span class="p">.</span><span class="n">informativeText</span> <span class="p">=</span> <span class="s">&#34;我是一个传统的方式&#34;</span>
    
    <span class="n">userNotification</span><span class="p">.</span><span class="n">hasActionButton</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="n">userNotification</span><span class="p">.</span><span class="n">otherButtonTitle</span> <span class="p">=</span> <span class="s">&#34;关闭&#34;</span>
    <span class="n">userNotification</span><span class="p">.</span><span class="n">actionButtonTitle</span> <span class="p">=</span> <span class="s">&#34;显示&#34;</span>
    
    <span class="n">userNotification</span><span class="p">.</span><span class="n">identifier</span> <span class="p">=</span> <span class="s">&#34;OLD_NOTIFICATION_DEMO&#34;</span>
    <span class="n">userNotification</span><span class="p">.</span><span class="n">userInfo</span> <span class="p">=</span> <span class="p">[</span><span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;old&#34;</span><span class="p">]</span>
    
    <span class="n">userNotification</span><span class="p">.</span><span class="n">soundName</span> <span class="p">=</span> <span class="n">NSUserNotificationDefaultSoundName</span>
    
    <span class="n">NSUserNotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">delegate</span> <span class="p">=</span> <span class="kc">self</span>
    <span class="n">NSUserNotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">deliver</span><span class="p">(</span><span class="n">userNotification</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<ul>
<li>上面使用消息通知中心的 <code>deliver</code> 方法直接推送消息，如果要设置其它触发方式的通知需要使用通知中心的 <code>scheduleNotification</code> 方法</li>
<li>将要传递用户数据设置在 <code>userNotification</code> 的 <code>userInfo</code> 中</li>
<li>设置了通知中心的代理为 self，所以要完成剩下的实现，还需要实现代理方法</li>
<li>要显示 action 按钮必须设置 <code>userNotification</code> 的 <code>hasActionButton</code> 为 <code>true</code></li>
</ul>

<h3 id="实现代理方法">实现代理方法</h3>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">extension</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="n">NSUserNotificationCenterDelegate</span> <span class="p">{</span>
    
    <span class="c1">// 当 App 在前台时是否弹出通知</span>
    <span class="kd">func</span> <span class="nf">userNotificationCenter</span><span class="p">(</span><span class="kc">_</span> <span class="n">center</span><span class="p">:</span> <span class="n">NSUserNotificationCenter</span><span class="p">,</span> <span class="n">shouldPresent</span> <span class="n">notification</span><span class="p">:</span> <span class="n">NSUserNotification</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    
    <span class="c1">// 推送消息后的回调</span>
    <span class="kd">func</span> <span class="nf">userNotificationCenter</span><span class="p">(</span><span class="kc">_</span> <span class="n">center</span><span class="p">:</span> <span class="n">NSUserNotificationCenter</span><span class="p">,</span> <span class="n">didDeliver</span> <span class="n">notification</span><span class="p">:</span> <span class="n">NSUserNotification</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">(</span><span class="n">timeIntervalSinceNow</span><span class="p">:</span> <span class="mi">0</span><span class="si">))</span><span class="s"> -&gt; 消息已经推送&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// 用户点击了通知后的回调</span>
    <span class="kd">func</span> <span class="nf">userNotificationCenter</span><span class="p">(</span><span class="kc">_</span> <span class="n">center</span><span class="p">:</span> <span class="n">NSUserNotificationCenter</span><span class="p">,</span> <span class="n">didActivate</span> <span class="n">notification</span><span class="p">:</span> <span class="n">NSUserNotification</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">notification</span><span class="p">.</span><span class="n">activationType</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">actionButtonClicked</span><span class="p">:</span>
            <span class="kd">let</span> <span class="nv">method</span> <span class="p">=</span> <span class="n">notification</span><span class="p">.</span><span class="n">userInfo</span><span class="o">!</span><span class="p">[</span><span class="s">&#34;method&#34;</span><span class="p">]</span> <span class="k">as</span><span class="o">!</span> <span class="nb">String</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;methods -&gt; </span><span class="si">\(</span><span class="n">method</span><span class="si">)</span><span class="s">&#34;</span><span class="p">)</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">contentsClicked</span><span class="p">:</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;clicked&#34;</span><span class="p">)</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">replied</span><span class="p">:</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;replied&#34;</span><span class="p">)</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">additionalActionClicked</span><span class="p">:</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;additional action&#34;</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;action&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
<span class="p">}</span></code></pre></div>
<ul>
<li>代理方法 <code>userNotificationCenter(:shouldPresent:)-&gt;Bool</code> 中如果返回 false，那么 App 的窗口是当前系统桌面显示的窗口，就不会弹出通知也不会播放提示音</li>
<li>通知中心推送消息后会调用 <code>userNotificationCenter(:didDeliver:)</code></li>
<li>当用户操作弹窗时，比如点击弹窗、点击弹窗上的按钮时，<code>userNotificationCenter(:didActivate)</code> 方法就会被调用，在其中要实现对各种操作的处理</li>
</ul>

<h3 id="运行程序">运行程序</h3>

<p>运行程序后点击窗口中按钮，不出意外就会看到通知弹窗，同时控制台会打印推送消息，点击弹窗的按钮或弹窗可以看到控制台打印了相应的信息！</p>

<p>Demo 下载：<a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/jfc5c.zip" target="_blank">OldNotificationDemo</a></p>

<h2 id="最新实现方式">最新实现方式</h2>

<ul>
<li>打开 Xcode 新建一个使用 storyboard 的工程，我们就命名为 <code>NotificationDemo</code></li>
<li>打开 <code>Main.storyboard</code> ，在 view controller 中添加一个按钮，按钮标题改为 <code>通知</code></li>
<li>为两个按钮绑定 action，在 <code>Main.storyboard</code> 中按下快捷键 <code>Option</code> + <code>Command</code> + 回车键 打开辅助编辑器，按住 <code>ctrl</code> 键的同时鼠标左键拖动按钮到 ViewController.swift 的 ViewController 类中绑定 action 为 <code>notificationAction</code></li>
</ul>

<h3 id="关于样式">关于样式</h3>

<p>新的实现方式与传统的实现方式不同的是，在样式为<strong>横幅(barner)</strong>时，将鼠标放置在通知弹窗上可以显示自定义的 action 按钮，所以这里没必要更改样式！</p>

<h3 id="notificationaction-实现">notificationAction 实现</h3>

<p>因为新的方式使用的是 <code>UserNotifications</code> 框架，所以需要先导入模块，在 <code>ViewController.swift</code> 中添加代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">import</span> <span class="nc">UserNotifications</span></code></pre></div>
<p>新的方式通知的实现过程与传统的有很大不同，流程大概是：</p>

<ul>
<li>先创建一个 <code>UNMutableNotificationContent</code> 来设置通知的内容，包括标题、内容、图片、标识符、提示声音以及用户数据</li>
<li>(可选) 创建一个触发器，触发器的类型有很多：

<ul>
<li><code>UNCalendarNotificationTrigger</code>: 通过指定日期和时间进行触发</li>
<li><code>UNTimeIntervalNotificationTrigger</code>: 通过设置指定时间间隔和是否重复来触发</li>
<li><code>UNLocationNotificationTrigger</code>: 通过指定地理坐标及地域范围来触发</li>
</ul></li>
<li>(可选) 创建操作集合，这个操作集合类型为 <code>UNNotificationCategory</code> 对应通知弹窗的按钮，集合中元素为 <code>UNNotificationAction</code> 实例，需要调用通知中心的 <code>setNotificationCategories</code> 方法添加生效。

<ul>
<li>barner样式下直接显示两个操作项按钮</li>
<li>alert 样式下集合下的操作项会显示为 <code>操作</code> 的子项</li>
<li><code>UNNotificationAction</code> 创建时需要指定唯一标识符、显示名称和选项，标识符用于后期区分 action 进行操作处理</li>
<li>集合的唯一标识符与通知内容实例的唯一标识符统一起来时，才能在 barner 样式下显示按钮</li>
</ul></li>
<li>然后通过上面创建好的通知内容实例和触发器创建一个通知请求，它是 <code>UNNotificationRequest</code> 实例，还需要指定一个唯一标识符，另外如果指定的触发器为空，通知中心会立即推送通知</li>
<li>最后指定通知中心的代理实例，一般情况就是类自身即 self，之后调用通知中心实例的 <code>add</code> 方法将通知请求添加到通知中心实例，这个通知中心实例使用系统当前的就可以，调用 <code>UNUserNotificationCenter.current()</code> 即可获得</li>
</ul>

<p>所以根据我们的实现目标，<code>notificationAction</code> 的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">notificationAction</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">Any</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">content</span> <span class="p">=</span> <span class="n">UNMutableNotificationContent</span><span class="p">()</span>
    <span class="n">content</span><span class="p">.</span><span class="n">title</span> <span class="p">=</span> <span class="s">&#34;新的方式&#34;</span>
    <span class="n">content</span><span class="p">.</span><span class="n">body</span> <span class="p">=</span> <span class="s">&#34;我是一个新的方式&#34;</span>
    
    <span class="n">content</span><span class="p">.</span><span class="n">userInfo</span> <span class="p">=</span> <span class="p">[</span><span class="s">&#34;method&#34;</span><span class="p">:</span> <span class="s">&#34;new&#34;</span><span class="p">]</span>
    
    <span class="n">content</span><span class="p">.</span><span class="n">sound</span> <span class="p">=</span> <span class="n">UNNotificationSound</span><span class="p">.</span><span class="k">default</span>
    <span class="n">content</span><span class="p">.</span><span class="n">categoryIdentifier</span> <span class="p">=</span> <span class="s">&#34;NOTIFICATION_DEMO&#34;</span>
    
    <span class="kd">let</span> <span class="nv">acceptAction</span> <span class="p">=</span> <span class="n">UNNotificationAction</span><span class="p">(</span><span class="n">identifier</span><span class="p">:</span> <span class="s">&#34;SHOW_ACTION&#34;</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="s">&#34;显示&#34;</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">))</span>
    <span class="kd">let</span> <span class="nv">declineAction</span> <span class="p">=</span> <span class="n">UNNotificationAction</span><span class="p">(</span><span class="n">identifier</span><span class="p">:</span> <span class="s">&#34;CLOSE_ACTION&#34;</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="s">&#34;关闭&#34;</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">))</span>
    <span class="kd">let</span> <span class="nv">testCategory</span> <span class="p">=</span> <span class="n">UNNotificationCategory</span><span class="p">(</span><span class="n">identifier</span><span class="p">:</span> <span class="s">&#34;NOTIFICATION_DEMO&#34;</span><span class="p">,</span>
                                              <span class="n">actions</span><span class="p">:</span> <span class="p">[</span><span class="n">acceptAction</span><span class="p">,</span> <span class="n">declineAction</span><span class="p">],</span>
                                              <span class="n">intentIdentifiers</span><span class="p">:</span> <span class="p">[],</span>
                                              <span class="n">hiddenPreviewsBodyPlaceholder</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">,</span>
                                              <span class="n">options</span><span class="p">:</span> <span class="p">.</span><span class="n">customDismissAction</span><span class="p">)</span>
    
    <span class="kd">let</span> <span class="nv">request</span> <span class="p">=</span> <span class="n">UNNotificationRequest</span><span class="p">(</span><span class="n">identifier</span><span class="p">:</span> <span class="s">&#34;NOTIFICATION_DEMO_REQUEST&#34;</span><span class="p">,</span>
                                        <span class="n">content</span><span class="p">:</span> <span class="n">content</span><span class="p">,</span>
                                        <span class="n">trigger</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    
    <span class="c1">// Schedule the request with the system.</span>
    <span class="kd">let</span> <span class="nv">notificationCenter</span> <span class="p">=</span> <span class="n">UNUserNotificationCenter</span><span class="p">.</span><span class="n">current</span><span class="p">()</span>
    <span class="n">notificationCenter</span><span class="p">.</span><span class="n">delegate</span> <span class="p">=</span> <span class="kc">self</span>
    <span class="n">notificationCenter</span><span class="p">.</span><span class="n">setNotificationCategories</span><span class="p">([</span><span class="n">testCategory</span><span class="p">])</span>
    <span class="n">notificationCenter</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// Handle any errors.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p><strong>注意：</strong></p>

<p><code>testCategory</code> 和 <code>content</code> 一定要使用一致的标识符，否则通知横幅样式下不会显示 action 按钮</p>

<h3 id="代理方法的实现">代理方法的实现</h3>

<p>直接贴出实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">extension</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="n">UNUserNotificationCenterDelegate</span> <span class="p">{</span>
    
    <span class="c1">// 用户点击弹窗后的回调</span>
    <span class="kd">func</span> <span class="nf">userNotificationCenter</span><span class="p">(</span><span class="kc">_</span> <span class="n">center</span><span class="p">:</span> <span class="n">UNUserNotificationCenter</span><span class="p">,</span> <span class="n">didReceive</span> <span class="n">response</span><span class="p">:</span> <span class="n">UNNotificationResponse</span><span class="p">,</span> <span class="n">withCompletionHandler</span> <span class="n">completionHandler</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">userInfo</span> <span class="p">=</span> <span class="n">response</span><span class="p">.</span><span class="n">notification</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">content</span><span class="p">.</span><span class="n">userInfo</span>
        <span class="k">switch</span> <span class="n">response</span><span class="p">.</span><span class="n">actionIdentifier</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s">&#34;SHOW_ACTION&#34;</span><span class="p">:</span>
            <span class="bp">print</span><span class="p">(</span><span class="n">userInfo</span><span class="p">)</span>
        <span class="k">case</span> <span class="s">&#34;CLOSE_ACTION&#34;</span><span class="p">:</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&#34;Nothing to do&#34;</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="n">completionHandler</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="c1">// 配置通知发起时的行为 alert -&gt; 显示弹窗, sound -&gt; 播放提示音</span>
    <span class="kd">func</span> <span class="nf">userNotificationCenter</span><span class="p">(</span><span class="kc">_</span> <span class="n">center</span><span class="p">:</span> <span class="n">UNUserNotificationCenter</span><span class="p">,</span> <span class="n">willPresent</span> <span class="n">notification</span><span class="p">:</span> <span class="n">UNNotification</span><span class="p">,</span> <span class="n">withCompletionHandler</span> <span class="n">completionHandler</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">UNNotificationPresentationOptions</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">completionHandler</span><span class="p">([.</span><span class="n">alert</span><span class="p">,</span> <span class="p">.</span><span class="n">sound</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<ul>
<li>两个回调中都有一个逃逸闭包参数，是一个完成处理的回调，一定要执行相应的 <code>completionHandler</code></li>
<li><code>userNotificationCenter(:willPresent:withCompletionHandler)</code> 方法中通过 <code>completionHandler</code> 配置通知行为，这里配置既显示弹窗又播放提示音</li>
</ul>

<h3 id="关于消息通知权限">关于消息通知权限</h3>

<p>其实严格来讲，一个 app 在第一次启动的时候要向系统请求设置通知权限的，等在之后的所有启动的时候就不需要请求设置权限了，只需每次读取系统偏好设置中的权限配置来实现相应的通知行为。貌似在 macOS 中不做这个操作，目前也没什么影响，如果想进一步了解权限可以阅读 <a href="https://developer.apple.com/documentation/usernotifications/asking_permission_to_use_notifications" target="_blank">Asking Permission to Use Notifications</a>!</p>

<h3 id="验证实现">验证实现</h3>

<p>运行程序，点击窗口中的按钮就能看到通知了！将鼠标放在通知上，就能显示操作按钮，点击按钮就能在 xcode 控制器窗口看到相应的打印信息了。</p>

<p>Demo 下载：<a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/2019-03-17-NotificationDemo.zip" target="_blank">NotificationDemo</a></p>

<h1 id="总结">总结</h1>

<p>到目前为止，我们尝试了两种方式实现消息通知的推送，如果有其它的实现需求，比如按日期时间推送消息，直接参考阅读 Apple 官方的资料吧！Apple 的各大系统平台接口融合是大势所趋，如果有必要，大家赶快根据新的实现方式替换马上要淘汰的方法吧！</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="https://blog.gaelfoppolo.com/user-notifications-in-macos-66c25ed5c692" target="_blank">User Notifications in macOS</a></li>
<li><a href="https://developer.apple.com/documentation/foundation/nsusernotificationcenter" target="_blank">NSUserNotificationCenter</a></li>
<li><a href="https://developer.apple.com/documentation/usernotifications/unusernotificationcenter" target="_blank">UNUserNotificationCenter</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之 NSTextField 文本的垂直居中</title>
			<link>https://www.smslit.top/2019/03/10/macOS-dev-vertically-centered-textfield/</link>
			<pubDate>Sun, 10 Mar 2019 15:26:20 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/10/macOS-dev-vertically-centered-textfield/</guid>
			<description>在 macOS 开发中不知道您是否为 NSTextField 的垂直居中的问题困扰过呢！从今天这篇文章开始，这个问题将不再是问题，本文将介绍一种可以实现 NSTextField 垂直居中的方法，大概可</description>
			<content type="html"><![CDATA[

<p>在 macOS 开发中不知道您是否为 NSTextField 的垂直居中的问题困扰过呢！从今天这篇文章开始，这个问题将不再是问题，本文将介绍一种可以实现 NSTextField 垂直居中的方法，大概可以满足我们的需求！</p>

<h2 id="开发平台">开发平台</h2>

<ul>
<li>macOS 10.14.3</li>
<li>swift 4.2.1</li>
<li>xcode 10.1</li>
</ul>

<h2 id="准备-demo">准备 Demo</h2>

<p>还是老规矩，以实例出发，理解实现！新建一个 macOS app 的工程，使用 storyboard，这里工程就命名为 TextFieldDemo 吧。创建成功后，打开 <code>Main.storyboard</code> ，往 <code>View Controller</code> 中添加一个 <code>Text Field</code> ，调整其大小贴齐窗口四边，添加必要的布局限制，并将以下内容作为 Text Field 的内容：</p>

<blockquote>
<p>漫威电影宇宙（英语：Marvel Cinematic Universe，简称MCU）是由漫威漫画工作室基于漫威漫画出版物中的角色独立制作的一系列电影所构成的架空世界和共同世界（Earth-199999）。</p>
</blockquote>

<p>就像下面这样(十里这里将窗口调小了一点):</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190310154814.png" alt="" /></p>

<p>运行程序可以看到显示文本是默认向上对齐的:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190310155150.png" alt="" /></p>

<h2 id="实现思路">实现思路</h2>

<p>最终我们要实现 Demo 窗口中的文本垂直居中显示，要想做到这一点，我们得了解一下文本框显示文本的过程。NSTextField 类通过 NSTextFieldCell 类实现用户界面的显示，所以关注点应该放在 NSTextFieldCell 类上，文本是在 text field cell 上的，而 TextField 又是 text field cell 的一个容器，所以只需要调整 text field cell 在 Text Field 中的坐标，如果 y 轴坐标值合适就能实现居中，在 Cocoa 中，控件使用如下坐标系(flipped coordinate)：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190310171441.png" alt="" /></p>

<p>NSTextFieldCell 类继承于 NSCell 类，所以可以通过调整绘制过程中 text field cell 的 frame 坐标数据实现其位置调整，对应这个绘制过程的方法就是 <code>drawingRect(forBounds:)</code>，新坐标的计算公式为：</p>

<p>$$
y_{new} = y_{old} + (Height_{frame} - Height_{text}) \times 0.5
$$</p>

<p>其中：</p>

<ul>
<li>$Height_{frame}$ 是指默认生成的 cell 的 frame</li>
<li>$Height_{text}$ 是文本实际占用的 frame</li>
</ul>

<p>为了更彻底一点，我们也可以调整 frame 的高度与文本实际占用的高度一致：</p>

<p>$$
Height_{frame} = Height_{text}
$$</p>

<p>也许您看了下面的图就明白上面公式的含义了：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190310182541.png" alt="" /></p>

<h2 id="具体实现">具体实现</h2>

<p>根据上面的思路可以有两种实现方式，一种是定义一个 <code>NSTextFielCell</code> 的子类，在子类中重写方法，另一种是扩展的方式重写 <code>NSTextFieldCell</code> 的方法。第二种会影响 app 中所有的 TextField，所以这里采用第一种方式。</p>

<p>在 <code>AppDelegate.swift</code> 文件中定义子类 <code>VerticallyCenteredTextFieldCell</code> 如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">class</span> <span class="nc">VerticallyCenteredTextFieldCell</span><span class="p">:</span> <span class="n">NSTextFieldCell</span> <span class="p">{</span>
    
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">drawingRect</span><span class="p">(</span><span class="n">forBounds</span> <span class="n">theRect</span><span class="p">:</span> <span class="n">NSRect</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">NSRect</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">newRect</span><span class="p">:</span><span class="n">NSRect</span> <span class="p">=</span> <span class="kc">super</span><span class="p">.</span><span class="n">drawingRect</span><span class="p">(</span><span class="n">forBounds</span><span class="p">:</span> <span class="n">theRect</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">textSize</span><span class="p">:</span><span class="n">NSSize</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">cellSize</span><span class="p">(</span><span class="n">forBounds</span><span class="p">:</span> <span class="n">theRect</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">heightDelta</span><span class="p">:</span><span class="n">CGFloat</span> <span class="p">=</span> <span class="n">newRect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">textSize</span><span class="p">.</span><span class="n">height</span>
        <span class="k">if</span> <span class="n">heightDelta</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">newRect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">=</span> <span class="n">textSize</span><span class="p">.</span><span class="n">height</span>
            <span class="n">newRect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">heightDelta</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">newRect</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>然后打开 <code>Main.storyboard</code> 文件，选中之前添加的 Text Field 的 cell ，按快捷键 <code>Option</code> + <code>Command</code> + <code>3</code> 打开 Identity 检查器，在 <code>Custom Class</code> 中为 cell 指定刚定义的子类 <code>VerticallyCenteredTextFieldCell</code>:</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190310183739.png" alt="" /></p>

<p>运行程序就能看到文本实现了居中显示：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190310184822.png" alt="" /></p>

<p>Demo下载：<a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/VerticallyCenteredTextFieldDemo.zip" target="_blank">VerticallyCenteredTextFieldDemo.zip</a></p>
]]></content>
		</item>
		
		<item>
			<title>快快拿走，Xcode 常用快捷键</title>
			<link>https://www.smslit.top/2019/03/07/mac-dev-keyboard-shortcuts/</link>
			<pubDate>Thu, 07 Mar 2019 14:42:16 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/07/mac-dev-keyboard-shortcuts/</guid>
			<description>无论您进行 macOS 开发还是 iOS 开发，大多数情况下都会用到 Xcode，那么本文就分享一下十里整理的常用快捷键，希望对您有所帮助！ 说明 Xocde 的快捷键不会随着</description>
			<content type="html"><![CDATA[

<p>无论您进行 macOS 开发还是 iOS 开发，大多数情况下都会用到 Xcode，那么本文就分享一下十里整理的常用快捷键，希望对您有所帮助！</p>

<h1 id="说明">说明</h1>

<ul>
<li>Xocde 的快捷键不会随着版本更迭而变化太多，但还是要说明一下本文的快捷键均能在 Xcode 10.2 中正常使用</li>
<li>正文中均使用快捷键修饰键的符号表示修饰符：

<ul>
<li>Control ⌃</li>
<li>Option ⌥</li>
<li>Shift ⇧</li>
<li>Command ⌘</li>
<li>Return ↩</li>
</ul></li>
</ul>

<h1 id="窗口操作">窗口操作</h1>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190307154213.jpg" alt="" /></p>

<h1 id="常规">常规</h1>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>⌘,</td>
<td>打开偏好设置</td>
</tr>

<tr>
<td>⇧⌘0</td>
<td>打开帮助窗口</td>
</tr>

<tr>
<td>⇧⌘c</td>
<td>打开调试区域的终端栏</td>
</tr>

<tr>
<td>⌘?</td>
<td>打开帮助搜索</td>
</tr>

<tr>
<td>⌘n</td>
<td>新建文件</td>
</tr>

<tr>
<td>⌘o</td>
<td>打开文件</td>
</tr>

<tr>
<td>⇧⌘a</td>
<td>向工程中添加文件</td>
</tr>
</tbody>
</table>

<h1 id="编译及运行">编译及运行</h1>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>⌘b</td>
<td>编译工程</td>
</tr>

<tr>
<td>⇧⌘b</td>
<td>分析工程</td>
</tr>

<tr>
<td>⌘r</td>
<td>运行工程</td>
</tr>

<tr>
<td>⌘i</td>
<td>打开 Profile</td>
</tr>

<tr>
<td>⌘u</td>
<td>测试工程</td>
</tr>

<tr>
<td>⇧⌘k</td>
<td>清理工程编译中间文件</td>
</tr>

<tr>
<td>⌘k</td>
<td>清空终端打印的信息</td>
</tr>

<tr>
<td>⌘.</td>
<td>停止运行</td>
</tr>
</tbody>
</table>

<h1 id="代码编辑">代码编辑</h1>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>⌃Space</td>
<td>显示补全提示项</td>
</tr>

<tr>
<td>⌃.</td>
<td>下一个补全提示项</td>
</tr>

<tr>
<td>Tab</td>
<td>选中补全提示项</td>
</tr>

<tr>
<td>⌃/</td>
<td>下一个代码 placeholder 项</td>
</tr>

<tr>
<td>⇧⌃/</td>
<td>上一个代码 placeholder 项</td>
</tr>

<tr>
<td>⌘/</td>
<td>注释或取消注释代码</td>
</tr>

<tr>
<td>⌥⌘←</td>
<td>折叠代码（方法或类）</td>
</tr>

<tr>
<td>⌥⌘→</td>
<td>展开折叠代码</td>
</tr>

<tr>
<td>⌃⌘e</td>
<td>编辑修改当前文件中所有出现光标处单词的地方</td>
</tr>
</tbody>
</table>

<h1 id="代码导航">代码导航</h1>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>⌘→</td>
<td>跳转到行尾</td>
</tr>

<tr>
<td>⌘←</td>
<td>跳转到行首</td>
</tr>

<tr>
<td>⌘↑</td>
<td>跳转到文件顶部</td>
</tr>

<tr>
<td>⌘↓</td>
<td>跳转到文件底部</td>
</tr>

<tr>
<td>⌥→</td>
<td>向后跳过一个单词</td>
</tr>

<tr>
<td>⌥←</td>
<td>向前跳过一个单词</td>
</tr>

<tr>
<td>⌘l</td>
<td>跳转到指定行</td>
</tr>

<tr>
<td>⌘f</td>
<td>在文件中查找</td>
</tr>

<tr>
<td>⇧⌘f</td>
<td>在工程中查找</td>
</tr>

<tr>
<td>⌘g</td>
<td>查找下一个</td>
</tr>

<tr>
<td>⇧⌘g</td>
<td>查找上一个</td>
</tr>

<tr>
<td>⌃⌘ + 鼠标左键单击</td>
<td>跳转到定义</td>
</tr>

<tr>
<td>⌥ + 鼠标左键单击</td>
<td>快速帮助</td>
</tr>

<tr>
<td>⌃⌘d</td>
<td>显示光标处关键字的快速帮助</td>
</tr>
</tbody>
</table>

<h1 id="文件导航">文件导航</h1>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>⌃⌘←</td>
<td>前一个打开的文件</td>
</tr>

<tr>
<td>⌃⌘→</td>
<td>后一个打开的文件</td>
</tr>

<tr>
<td>⇧⌘o</td>
<td>快速打开文件</td>
</tr>

<tr>
<td>⌃1</td>
<td>显示与指定代码相关的文件</td>
</tr>

<tr>
<td>⌘n</td>
<td>新建文件</td>
</tr>

<tr>
<td>⌘o</td>
<td>打开文件</td>
</tr>

<tr>
<td>⇧⌘a</td>
<td>向工程中添加文件</td>
</tr>
</tbody>
</table>

<h1 id="调试">调试</h1>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>

<tbody>
<tr>
<td>⌘ \</td>
<td>添加或删除断点</td>
</tr>

<tr>
<td>⌘y</td>
<td>禁用或激活断点</td>
</tr>

<tr>
<td>⌃⌘y</td>
<td>继续执行</td>
</tr>

<tr>
<td>⌃⌘c</td>
<td>继续执行到当前行</td>
</tr>

<tr>
<td>F6</td>
<td>单步跳过</td>
</tr>

<tr>
<td>F7</td>
<td>单步进入</td>
</tr>

<tr>
<td>F8</td>
<td>单步跳出</td>
</tr>
</tbody>
</table>

<h1 id="总结">总结</h1>

<p>为了方便大家收藏，十里为此将上面的快捷键整理为一页 pdf ，方便大家及时查看：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/xcode_shortcuts.pdf" alt="" /></p>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之定时器的使用</title>
			<link>https://www.smslit.top/2019/03/05/macOS-dev-timer/</link>
			<pubDate>Tue, 05 Mar 2019 15:43:00 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/05/macOS-dev-timer/</guid>
			<description>前段时间开发了一款状态栏小工具 时光(Time Go) ，它用到了定时器，近期十里在想大家会不会也有用定时器的需求呢！所以呢，写本文意在分享 macOS 开发中关</description>
			<content type="html"><![CDATA[

<p>前段时间开发了一款状态栏小工具 <a href="https://github.com/smslit/timeGO" target="_blank">时光(Time Go)</a> ，它用到了定时器，近期十里在想大家会不会也有用定时器的需求呢！所以呢，写本文意在分享 macOS 开发中关于定时器的的收获及其使用方法，我们一起进步。</p>

<h1 id="实现平台">实现平台</h1>

<ul>
<li>macOS 10.14.3</li>
<li>swift 4.2.1</li>
<li>xcode 10.1</li>
</ul>

<h1 id="准备环境">准备环境</h1>

<p>为了更好地展示定时器的使用，这里我们使用 playground 测试我们的定时器，可以使用快捷键 <code>Option</code> + <code>Shift</code> + <code>Command</code> + n 新建 playgroud 文件。在文件中我们准备一个 TimerDemo 类用于测试定时器：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">import</span> <span class="nc">Foundation</span>


<span class="kd">class</span> <span class="nc">TimerDemo</span> <span class="p">{</span>
    
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">timeCount</span> <span class="p">=</span> <span class="mi">5</span>
    
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">share</span> <span class="p">=</span> <span class="n">TimerDemo</span><span class="p">()</span>
    
    <span class="c1">// 添加不同定时器使用方法的示例代码</span>
    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;TimerDemo&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="n">TimerDemo</span><span class="p">.</span><span class="n">share</span><span class="p">.</span><span class="n">run</span><span class="p">()</span></code></pre></div>
<p>上面定义了 TimerDemo 类，同时实现了一个 TimerDemo 的单例，方便调用方法展示效果！</p>

<h1 id="定时器的使用">定时器的使用</h1>

<p>网上能搜到有三种实现定时器的方式，因为苹果官方 API 的变化导致部分搜到的信息过时，本文整理的实现方法适用于上述描述的实现平台，近期应该不会过期，哈哈：</p>

<ul>
<li>Timer 类实现</li>
<li>GCD(<a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch" target="_blank">Grand Central Dispatch</a>) 的方式</li>
<li>利用屏幕刷新实现计数定时</li>
</ul>

<p>本人觉得第三种方式不是什么好的方式，所以本文只讲前两种方式。</p>

<h2 id="使用-timer-类">使用 Timer 类</h2>

<p>Timer 类的使用依赖 RunLoop(线程的事件循环，app 运行一定会有一个名为 main 的 RunLoop，主要负责界面控件的显示和交互) ，只有添加到激活状态的 RunLoop 中定时器才能正常工作。</p>

<p>定时器的运行根据次数分两种：单次和循环：</p>

<ul>
<li>单次的定时器，会在指定的时间过后，自动销毁并从 RunLoop 中弹出，而不再影响 RunLoop 的运行</li>
<li>循环的定时器，会根据指定时间间隔触发执行处理任务，需要开发者手动执行 Timer 对象的 <code>invalidate</code> 方法才能销毁并从 RunLoop 中弹出。一般使用循环定时器，不会让其一直执行，满足某种条件或执行指定次数之后，手动调用 invlaidate 方法停止定时器</li>
</ul>

<p>根据定时器的使用方式，可以分三种：</p>

<ul>
<li>使用 <code>Timer(timeInterval:repeats:block:)</code> 或 <code>Timer(timeInterval:target:selector:userInfo:repeats:)</code> 类方法初始化 Timer 对象，将对象手动添加到指定 RunLoop 中执行</li>
<li>使用 <code>Timer(fire:interval:repeats:block:)</code> 或 <code>Timer(fireAt:interval:target:selector:userInfo:repeats:)</code> 类方法初始化 Timer 对象，将对象手动添加到指定 RunLoop 中执行</li>
<li>使用 <code>Timer.scheduledTimer(withTimeInterval:repeats:block:)</code> 和 <code>Timer.scheduledTimer(timeInterval:target:selector:userInfo:repeats:)</code> 类方法，这两个方法都会创建 Timer 对象，并且以默认的运行模式添加到当前的 RunLoop 中</li>
</ul>

<p>下面我们开始尝试上面的三种方式。先在上面定义的 TimerDemo 类中声明一个 timer 属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">private</span> <span class="kd">var</span> <span class="nv">timer</span><span class="p">:</span> <span class="n">Timer</span><span class="p">?</span></code></pre></div>
<h3 id="第一种方式">第一种方式</h3>

<h4 id="timer-timeinterval-repeats-block-类方法"><code>Timer(timeInterval:repeats:block:)</code> 类方法</h4>

<ul>
<li>timeInterval 是定时器的触发时间间隔，单位为秒</li>
<li>repeats 布尔类型，代表是否重复，如果为 true ，定时器是循环定时器，如果为 false ，定时器是单次的</li>
<li>block 为 <code>((timer: Timer?) -&gt; Void)</code> 类型的闭包，其中 timer 是定时器自身</li>
</ul>

<p>我们为 TimerDemo 类定义一个 <code>oneshot1</code> 方法，使用 <code>Timer(timeInterval:repeats:block:)</code> 类方法实现一个单次的定时器，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">// 使用 Timer(timeInterval:repeats:block:) 初始化对象，并将其添加到 main 线程的 RunLoop 中，单次</span>
<span class="kd">func</span> <span class="nf">oneshot1</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer(timeInterval:repeats:block:) 初始化，单次&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">timeInterval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">oneFireHandler</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="o">!</span><span class="p">,</span> <span class="n">forMode</span><span class="p">:</span> <span class="p">.</span><span class="n">common</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>可以看到定时器时间间隔是 1 秒，单次，并且闭包中调用定义的 <code>oneFireHandler</code> 方法，此方法是用来处理我们需要做的定时任务的，比如我们打印一个字符串：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">oneFireHandler</span><span class="p">(</span><span class="kc">_</span> <span class="n">timer</span><span class="p">:</span> <span class="n">Timer</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Void</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: 单次倒计时结束！&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>还需要注意的是，<code>oneshot1</code> 中初始化得到 Timer 对象后，执行 <code>RunLoop.main.add(timer:forMode:)</code> 方法将定时器加入到 RunLoop 中，这一步是必须的，其中 <code>forMode</code> 参数我们使用默认模式(<code>common</code>)，可以防止其它高优先级 mode 的事件影响定时器的运行。打印信息时同时打印了当前时间，主要作为参考看倒计时对不对。下面我们测试一下我们定义的 <code>oneshot1</code> 方法:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">TimerDemo</span><span class="p">.</span><span class="n">share</span><span class="p">.</span><span class="n">oneshot1</span><span class="p">()</span></code></pre></div>
<p>可以看到打印结果，确实是 1 秒的时间间隔，且执行了定时器任务。</p>
<div class="highlight"><pre class="chroma"><code class="language-Bash" data-lang="Bash"><span class="m">2019</span>-03-05 <span class="m">13</span>:51:07 +0000: Timer<span class="o">(</span>timeInterval:repeats:block:<span class="o">)</span> 初始化，单次
<span class="m">2019</span>-03-05 <span class="m">13</span>:51:08 +0000: 单次倒计时结束！</code></pre></div>
<p>上面 <code>oneshot1</code> 和 <code>oneFirehandler(timer:)</code> 的实现可以简化为下面的形式，看您的使用习惯和需求决定使用哪种形式了：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">func</span> <span class="nf">oneshot1</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer(timeInterval:repeats:block:) 初始化，单次&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">timeInterval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: 单次倒计时结束！&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="o">!</span><span class="p">,</span> <span class="n">forMode</span><span class="p">:</span> <span class="p">.</span><span class="n">common</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>我们继续试一下<strong>循环定时器</strong>，先定义一个循环定时器要处理的任务：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">loopFireHandler</span><span class="p">(</span><span class="kc">_</span> <span class="n">timer</span><span class="p">:</span> <span class="n">Timer</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kc">self</span><span class="p">.</span><span class="n">timeCount</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">timer</span><span class="o">!</span><span class="p">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: 循环倒计时结束！&#34;</span><span class="p">)</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">timeCount</span> <span class="p">=</span> <span class="mi">5</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">timeCount</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: 倒计时 </span><span class="si">\(</span><span class="kc">self</span><span class="p">.</span><span class="n">timeCount</span><span class="si">)</span><span class="s"> 秒&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p><code>loopFireHandler</code> 方法中进行倒计时，到 0 时，调用定时器对象的 <code>invalidate</code> 方法释放定时器。另外定时器的实现如下 <code>loop1</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">func</span> <span class="nf">loop1</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer(timeInterval:repeats:block:) 初始化，循环&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">timeInterval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">loopFireHandler</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="o">!</span><span class="p">,</span> <span class="n">forMode</span><span class="p">:</span> <span class="p">.</span><span class="n">common</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>可以看到只是 <code>repeats</code> 参数改为 true，block 中调用 <code>loopFireHandler</code> 方法，下面测试一下 <code>loop1</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">TimerDemo</span><span class="p">.</span><span class="n">share</span><span class="p">.</span><span class="n">loop1</span><span class="p">()</span></code></pre></div>
<p>运行结果如我们所想，实现了 5 秒倒计时：</p>
<div class="highlight"><pre class="chroma"><code class="language-Bash" data-lang="Bash"><span class="m">2019</span>-03-05 <span class="m">14</span>:10:22 +0000: Timer<span class="o">(</span>timeInterval:repeats:block:<span class="o">)</span> 初始化，循环
<span class="m">2019</span>-03-05 <span class="m">14</span>:10:23 +0000: 倒计时 <span class="m">4</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:10:24 +0000: 倒计时 <span class="m">3</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:10:25 +0000: 倒计时 <span class="m">2</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:10:26 +0000: 倒计时 <span class="m">1</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:10:27 +0000: 倒计时 <span class="m">0</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:10:28 +0000: 循环倒计时结束！</code></pre></div>
<h4 id="timer-timeinterval-target-selector-userinfo-repeats-类方法"><code>Timer(timeInterval:target:selector:userInfo:repeats:)</code> 类方法</h4>

<ul>
<li>timeInterval 定时器时间间隔，单位为秒</li>
<li>target 定时器每次循环结束后发送消息的目标对象</li>
<li>selector 指定定时器每次计时结束要执行的方法，必须为 <code>@objc</code> 的函数对象，所以上面定义的 <code>oneFireHandler</code> 和 <code>loopFireHandler</code> 最前面要加 <code>@objc</code> 关键词</li>
<li>userinfo 指定用户信息，可以指定为 nil</li>
<li>repeats 决定要不要循环执行，true 为循环，false 为单次</li>
</ul>

<p>单次和循环的定时器处理，只有方法中的 <code>repeats</code> 参数和指定的处理任务函数不一样，其它都一致，所以后面只展示循环定时器的实现。</p>

<p>使用方法如下 <code>loop2</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">// 使用 Timer(timeInterval:target:selector:userInfo:repeats:) 初始化对象，并将其添加到 main 线程的 RunLoop 中，循环</span>
<span class="kd">func</span> <span class="nf">loop2</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer(timeInterval:target:selector:userInfo:repeats:) 初始化，循环&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">timeInterval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="kc">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">loopFireHandler</span><span class="p">(</span><span class="kc">_</span><span class="p">:)),</span> <span class="n">userInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="o">!</span><span class="p">,</span> <span class="n">forMode</span><span class="p">:</span> <span class="p">.</span><span class="n">common</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>同样需要注意的是，需要将定时器 timer 添加到 RunLoop 中去。调用这个方法 <code>TimerDemo.share.loop2()</code> 即可看到打印结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Bash" data-lang="Bash"><span class="m">2019</span>-03-05 <span class="m">14</span>:21:07 +0000: Timer<span class="o">(</span>timeInterval:target:selector:userInfo:repeats:<span class="o">)</span> 初始化，循环
<span class="m">2019</span>-03-05 <span class="m">14</span>:21:08 +0000: 倒计时 <span class="m">4</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:21:09 +0000: 倒计时 <span class="m">3</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:21:10 +0000: 倒计时 <span class="m">2</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:21:11 +0000: 倒计时 <span class="m">1</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:21:12 +0000: 倒计时 <span class="m">0</span> 秒
<span class="m">2019</span>-03-05 <span class="m">14</span>:21:13 +0000: 循环倒计时结束！</code></pre></div>
<h3 id="第二种方式">第二种方式</h3>

<h4 id="timer-fire-interval-repeats-block-类方法"><code>Timer(fire:interval:repeats:block:)</code> 类方法</h4>

<p>这个方法相较于 <code>Timer(timeInterval:repeats:block:)</code> 只多了一个 <code>fire</code> 参数，这个参数代表的意思是什么时候触发第一次计时结束，类型是 Date 类，可以使用方法 <code>Date(timeIntervalSinceNow:)</code> 方法指定相对于现在的时刻，这个方法参数单位是秒，最终 <code>Timer(fire:interval:repeats:block:)</code> 类方法实现循环定时器的过程如下 <code>loop3</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">//  使用 Timer(fire:interval:repeats:block:) 初始化对象，并将其添加到 main 线程的 RunLoop 中，循环</span>
<span class="kd">func</span> <span class="nf">loop3</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer(fire:interval:repeats:block:) 初始化，添加到 RunLoop，循环&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">fire</span><span class="p">:</span> <span class="n">Date</span><span class="p">(</span><span class="n">timeIntervalSinceNow</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">interval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">loopFireHandler</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="o">!</span><span class="p">,</span> <span class="n">forMode</span><span class="p">:</span> <span class="p">.</span><span class="n">common</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>注意 <code>fire</code> 参数，这里我们设置的是 <code>Date(timeIntervalSinceNow: 0)</code>，也就是现在就触发一次计时结束，此时执行 <code>TimerDemo.share.loop3()</code> 可以看到结果:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">35</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="n">Timer</span><span class="p">(</span><span class="n">fire</span><span class="p">:</span><span class="n">interval</span><span class="p">:</span><span class="n">repeats</span><span class="p">:</span><span class="n">block</span><span class="p">:)</span> <span class="err">初始化，添加到</span> <span class="n">RunLoop</span><span class="err">，循环</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">35</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">4</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">36</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">3</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">37</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">2</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">38</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">1</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">39</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">0</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">30</span><span class="p">:</span><span class="mi">40</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">循环倒计时结束！</span></code></pre></div>
<p>可以看到第一行和第二行的打印时间都是 <code>2019-03-05 14:30:35 +0000</code> 这正匹配我们设置的 fire 参数，我们改一下 fire 参数为 <code>Date(timeIntervalSinceNow: 3)</code>，也就是相对于现在延后 3 秒触发第一次计时结束，执行 <code>TimerDemo.share.loop3()</code> 看一下结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">00</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="n">Timer</span><span class="p">(</span><span class="n">fire</span><span class="p">:</span><span class="n">interval</span><span class="p">:</span><span class="n">repeats</span><span class="p">:</span><span class="n">block</span><span class="p">:)</span> <span class="err">初始化，添加到</span> <span class="n">RunLoop</span><span class="err">，循环</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">03</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">4</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">04</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">3</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">05</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">2</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">06</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">1</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">07</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">倒计时</span> <span class="mi">0</span> <span class="err">秒</span>
<span class="mi">2019</span><span class="o">-</span><span class="mi">03</span><span class="o">-</span><span class="mi">05</span> <span class="mi">14</span><span class="p">:</span><span class="mi">33</span><span class="p">:</span><span class="mi">08</span> <span class="o">+</span><span class="mi">0000</span><span class="p">:</span> <span class="err">循环倒计时结束！</span></code></pre></div>
<p>第二行与第一行的打印时间果然差了 3 秒，这下您应该明白这个 fire 参数的含义了吧！</p>

<h4 id="timer-fireat-interval-target-selector-userinfo-repeats-类方法"><code>Timer(fireAt:interval:target:selector:userInfo:repeats:)</code> 类方法</h4>

<p>这个方法相对于 <code>Timer(timeInterval:target:selector:userInfo:repeats:)</code> 方法多了一个 <code>fireAt</code> 参数，这个参数与上一个类方法的 <code>fire</code> 含义一致，使用就很简单了，定义 <code>loop4</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">//  使用 Timer(fireAt:interval:target:selector:userInfo:repeats:) 初始化对象，并将其添加到 main 线程的 RunLoop 中，循环</span>
<span class="kd">func</span> <span class="nf">loop4</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer(fireAt:interval:target:selector:userInfo:repeats:) 初始化，添加到 RunLoop，循环&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">(</span><span class="n">fireAt</span><span class="p">:</span> <span class="n">Date</span><span class="p">(</span><span class="n">timeIntervalSinceNow</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">interval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="kc">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">loopFireHandler</span><span class="p">(</span><span class="kc">_</span><span class="p">:)),</span> <span class="n">userInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="n">RunLoop</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">timer</span><span class="o">!</span><span class="p">,</span> <span class="n">forMode</span><span class="p">:</span> <span class="p">.</span><span class="n">common</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>这里就不展示执行结果了。</p>

<h3 id="第三种方式">第三种方式</h3>

<h4 id="timer-scheduledtimer-withtimeinterval-repeats-block-类方法"><code>Timer.scheduledTimer(withTimeInterval:repeats:block:)</code> 类方法</h4>

<p>此方法参数与 <code>Timer(timeInterval:repeats:block:)</code> 参数一致，所以实现定时器一定难不倒我们了，但是这里需要注意的是，使用此方法得到的 timer 对象在执行方法的时候已经添加到 RunLoop 中了，所以不需要我们手动添加到 RunLoop 了：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">//  使用 Timer.scheduledTimer(withTimeInterval:repeats:block:) 方法注册运行，循环</span>
<span class="kd">func</span> <span class="nf">loop5</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer.scheduledTimer(withTimeInterval:repeats:block:) 方法，循环&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">.</span><span class="n">scheduledTimer</span><span class="p">(</span><span class="n">withTimeInterval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">loopFireHandler</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span></code></pre></div>
<h4 id="timer-scheduledtimer-timeinterval-target-selector-userinfo-repeats-类方法"><code>Timer.scheduledTimer(timeInterval:target:selector:userInfo:repeats:)</code> 类方法</h4>

<p>此方法如同 <code>Timer.scheduledTimer(withTimeInterval:repeats:block:)</code> 方法，也不需要将方法返回的对象手动添加到 RunLoop 了：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">//  使用 Timer.scheduledTimer(timeInterval:target:selector:userInfo:repeats:) 方法注册运行，循环</span>
<span class="kd">func</span> <span class="nf">loop6</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: Timer.scheduledTimer(withTimeInterval:repeats:block:) 方法，循环&#34;</span><span class="p">)</span>
    <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">.</span><span class="n">scheduledTimer</span><span class="p">(</span><span class="n">timeInterval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="kc">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">:</span> <span class="k">#selector</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">loopFireHandler</span><span class="p">(</span><span class="kc">_</span><span class="p">:)),</span> <span class="n">userInfo</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h3 id="timer-类定时器总结">Timer 类定时器总结</h3>

<p>综上，我们算是了解了 6 中类方法实现定时器，但是这种方式有个问题：因为是运行在 main 线程的的 RunLoop 中，所以可能出现时间延迟的问题，主线程主要处理 UI 控件的交互，如果在其中再有一些运算量大的操作，必定会影响定时器的执行（阻塞），也就是说 Timer 不论是在哪个 RunLoop 中，终究会是受 RunLoop 的影响。下面我们就再了解一个不受 RunLoop 影响的 GCD 方式的定时器。</p>

<h2 id="gcd-方式的-timer">GCD 方式的 Timer</h2>

<p>通过 GCD 方式创建的定时器不会受 RunLoop 的影响，是一种比较底层的实现，所以很高效而且不受窗口控件频繁操作的影响。GCD 方式的定时器类型为 <code>DispatchSourceTimer</code>，其实例对象可以使用 <code>DispatchSource</code> 的 <code>MakeTimerSource</code> 方法分配资源而得到，这个对象有以下常用方法：</p>

<ul>
<li>resume() 开启运行或恢复运行</li>
<li>cancel() 取消定时器</li>
<li>suspend() 挂起定时器，可以使用 resumne() 恢复运行</li>
<li>setEventHandler(handler: (() -&gt; Void)?) 设置定时器任务的处理</li>
<li>setCancelHandler(handler: (() -&gt; Void)?) 设置定时器取消时的处理</li>
<li>schedule(deadline:repeating:leeway:) 配置定时器的时间参数</li>
</ul>

<h3 id="schedule-deadline-repeating-leeway-方法">schedule(deadline:repeating:leeway:) 方法</h3>

<p>这个是 <code>DispatchSourceTimer</code> 对象用来配置时间参数的方法，本节主要介绍一下其参数。</p>

<ul>
<li>deadline 类型为 <code>DispatchTime</code> ，这个时间精度可以达到纳秒级，含义与上面 Timer 类的 <code>Timer(fire:interval:repeats:block:)</code> 方法的 <code>fire</code> 一致，不过类型不一样。<code>DispatchTime</code> 有 now() 方法用来获取现在的时间，可以与 <code>DispatchTimeInterval</code> 对象实现 + 操作，得到一个相对于时刻，<code>DispatchTimeInterval</code> 对象可以通过调用 <code>seconds(_:Int)</code> 方法得到秒，<code>milliseconds(_:Int)</code> 方法得到毫秒，<code>microseconds(_:Int)</code> 方法得到微秒，<code>nanoseconds(_:Int)</code> 方法得到纳秒</li>
<li>repeating 与 Timer 类方法中的 repeat 不是一个意思，这里代表的是定时器时间间隔也就是 <strong>timeInterval</strong>，类型为 <code>DispatchTimeInterval</code>，比如指定一秒可以 <code>DispatchTimeInterval.seconds(1)</code>。这个参数具有默认值，当不指定这个参数的时候，这个参数就会设置为 <code>DispatchTimeInterval.never</code> ，那么<strong>定时器只执行一次</strong>。</li>
<li>leeway 时间容差，是一个定时时间的宽容度，具有一个默认值，所以调用此方法的时候可以不用指定这个参数，如果要指定的话，也是 <code>DispatchTimeInterval</code> 类型</li>
</ul>

<h3 id="使用方法">使用方法</h3>

<p>讲了上面这么多，还是用实际的例子说明，首先在 TimerDemo 类中添加如下属性：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">private</span> <span class="kd">var</span> <span class="nv">gcdTimer</span><span class="p">:</span> <span class="n">DispatchSourceTimer</span><span class="p">?</span></code></pre></div>
<p>单次定时器，如方法 <code>oneshot7</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">// GCD 方式的定时器，单次</span>
<span class="kd">func</span> <span class="nf">oneshot7</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: GCD 方式的定时器，单次&#34;</span><span class="p">)</span>
    <span class="n">gcdTimer</span> <span class="p">=</span> <span class="n">DispatchSource</span><span class="p">.</span><span class="n">makeTimerSource</span><span class="p">()</span>
    <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">setEventHandler</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: 单次倒计时结束！&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">schedule</span><span class="p">(</span><span class="n">deadline</span><span class="p">:</span> <span class="p">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="p">.</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">resume</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p>循环定时器，如方法 <code>loop7</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">// GCD 方式的定时器，循环</span>
<span class="kd">func</span> <span class="nf">loop7</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: GCD 方式的定时器，循环&#34;</span><span class="p">)</span>
    <span class="n">gcdTimer</span> <span class="p">=</span> <span class="n">DispatchSource</span><span class="p">.</span><span class="n">makeTimerSource</span><span class="p">()</span>
    <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">setEventHandler</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="kc">self</span><span class="p">.</span><span class="n">timeCount</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">gcdTimer</span><span class="p">?.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">timeCount</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: 倒计时 </span><span class="si">\(</span><span class="kc">self</span><span class="p">.</span><span class="n">timeCount</span><span class="si">)</span><span class="s"> 秒&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">setCancelHandler</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&#34;</span><span class="si">\(</span><span class="n">Date</span><span class="si">())</span><span class="s">: 倒计时结束！&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">schedule</span><span class="p">(</span><span class="n">deadline</span><span class="p">:</span> <span class="p">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="p">.</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">repeating</span><span class="p">:</span> <span class="p">.</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">resume</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p><strong>注意</strong></p>

<p>如果定时器任务中需要对 UI 控件进行操作，要将那部分操作放在主线程进行也就是用下面的代码包裹：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">async</span> <span class="p">{</span>
    <span class="c1">// UI控件操作</span>
<span class="p">}</span></code></pre></div>
<h2 id="总结">总结</h2>

<p>上述定时器演示的 playgroud 可以通过下面链接查看：</p>

<p><a href="https://gist.github.com/smslit/d62773e68d12816c4efc878395da2365" target="_blank">cocoaTimer.playground</a></p>

<h1 id="两种方式示例对比">两种方式示例对比</h1>

<p>为了凸显 GCD 方式定时器不受 UI 的操作的影响，本小节新建一个名为 TimerDemo 的工程，工程的 Main.storyboard 中添加一个按钮，两个 label 和一个滑块，合理放置位置，比如：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190306002519.png" alt="" /></p>

<p>分别将两个 label 的按钮绑定属性到 ViewController 类，同时为按钮添加一个 action 用来启动两种定时器。两个 label 分别显示 Timer 定时器的倒计时时间和 GCD 方式的定时器的倒计时时间，当启动定时器后，我们频繁滑动滑杆，观察两个定时器的情况，最终实现的 ViewController 类如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="n">NSViewController</span> <span class="p">{</span>

    <span class="kr">@IBOutlet</span> <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">timerLabel1</span><span class="p">:</span> <span class="n">NSTextField</span><span class="o">!</span>
    <span class="kr">@IBOutlet</span> <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">timerLabel2</span><span class="p">:</span> <span class="n">NSTextField</span><span class="o">!</span>
    <span class="kr">@IBOutlet</span> <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">timerButton</span><span class="p">:</span> <span class="n">NSButton</span><span class="o">!</span>
    
    <span class="kd">var</span> <span class="nv">count1</span> <span class="p">=</span> <span class="mi">60</span>
    <span class="kd">var</span> <span class="nv">count2</span> <span class="p">=</span> <span class="mi">60</span>
    <span class="kd">var</span> <span class="nv">timer</span><span class="p">:</span> <span class="n">Timer</span><span class="p">?</span>
    <span class="kd">var</span> <span class="nv">gcdTimer</span><span class="p">:</span> <span class="n">DispatchSourceTimer</span><span class="p">?</span>
    
    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

        <span class="c1">// Do any additional setup after loading the view.</span>
    <span class="p">}</span>

    <span class="kr">override</span> <span class="kd">var</span> <span class="nv">representedObject</span><span class="p">:</span> <span class="nb">Any</span><span class="p">?</span> <span class="p">{</span>
        <span class="kr">didSet</span> <span class="p">{</span>
        <span class="c1">// Update the view, if already loaded.</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">startTimer</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">Any</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">timer</span> <span class="p">=</span> <span class="n">Timer</span><span class="p">.</span><span class="n">scheduledTimer</span><span class="p">(</span><span class="n">withTimeInterval</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
            <span class="k">if</span> <span class="kc">self</span><span class="p">.</span><span class="n">count1</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">timer</span><span class="p">.</span><span class="n">invalidate</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">count1</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">timerLabel1</span><span class="p">.</span><span class="n">stringValue</span> <span class="p">=</span> <span class="s">&#34;timer: </span><span class="si">\(</span><span class="kc">self</span><span class="p">.</span><span class="n">count1</span><span class="si">)</span><span class="s"> 秒&#34;</span>
        <span class="p">}</span>
        
        <span class="n">gcdTimer</span> <span class="p">=</span> <span class="n">DispatchSource</span><span class="p">.</span><span class="n">makeTimerSource</span><span class="p">()</span>
        <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">setEventHandler</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="kc">self</span><span class="p">.</span><span class="n">count2</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="kc">self</span><span class="p">.</span><span class="n">gcdTimer</span><span class="p">?.</span><span class="n">cancel</span><span class="p">()</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">count2</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">async</span> <span class="p">{</span>
                <span class="kc">self</span><span class="p">.</span><span class="n">timerLabel2</span><span class="p">.</span><span class="n">stringValue</span> <span class="p">=</span> <span class="s">&#34;gcdTimer: </span><span class="si">\(</span><span class="kc">self</span><span class="p">.</span><span class="n">count2</span><span class="si">)</span><span class="s"> 秒&#34;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">schedule</span><span class="p">(</span><span class="n">deadline</span><span class="p">:</span> <span class="p">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="p">.</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">repeating</span><span class="p">:</span> <span class="p">.</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">leeway</span><span class="p">:</span> <span class="p">.</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">gcdTimer</span><span class="p">?.</span><span class="n">resume</span><span class="p">()</span>
        
        <span class="kc">self</span><span class="p">.</span><span class="n">timerButton</span><span class="p">.</span><span class="n">isEnabled</span> <span class="p">=</span> <span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>最后运行程序，疯狂滑动滑杆可以看到 GCD 方式的定时器丝毫不受影响，而 Timer 类的定时器受到了阻塞：</p>

<video src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/timer_compare.mp4" width="960px" controls="controls"></video>

<p>示例工程下载：<a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/TimerDemo.zip" target="_blank">TimerDemo</a></p>
]]></content>
		</item>
		
		<item>
			<title>已开源 app 实现检查更新的简单方式</title>
			<link>https://www.smslit.top/2019/03/03/macOS-dev-simple-check-update/</link>
			<pubDate>Sun, 03 Mar 2019 09:38:27 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/03/macOS-dev-simple-check-update/</guid>
			<description>如果您开发的 app 没有上架 app store，那么您肯定会考虑如何保证用户及时收到 app 更新的问题，如果您的项目是开源在某个托管平台的，那么本文就提供一种</description>
			<content type="html"><![CDATA[

<p>如果您开发的 app 没有上架 app store，那么您肯定会考虑如何保证用户及时收到 app 更新的问题，如果您的项目是开源在某个托管平台的，那么本文就提供一种简单的方式助您实现 app 检查更新的功能。</p>

<h1 id="实现平台">实现平台</h1>

<ul>
<li>macOS 10.14.3</li>
<li>swift 4.2.1</li>
<li>xcode 10.1</li>
</ul>

<h1 id="思路">思路</h1>

<p>本文提供的方法，不需要架设服务器，只要在开源平台上托管就可以。所以，这里假设您的 app 都是在托管平台发布，并且代码也是及时推送到托管平台的。</p>

<p>每个 xcode 工程中都有一个 <code>info.plist</code> 文件，使用其中的 <code>CFBundleShortVersionString</code> 键的值作为版本判断依据，app 运行起来本身能获取自己的版本号，通过网络从托管平台获取最新版本源文件中的 <code>info.plist</code> 文件，然后得到最新版本号，与自身的版本号对比，如果不一样就说明有了最新版本（更严格的判断应该是远端文件中获取的版本号新于 app 自身的版本号），然后通过提示框提醒用户有新版本发现，提示框中给出一个按钮，帮助用户跳转到开源工程最新版本的 release 页面即可。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190303111234.png" alt="" /></p>

<p>这里以工程托管在 github 为例，说明几点注意的地方：</p>

<ul>
<li><p>请求的 <code>info.plist</code> 文件链接必须是直接指向原文件的，而不是浏览代码页面对应的链接，网页 github 平台上浏览工程代码，找到 <code>info.plist</code> 文件，然后点击如图位置的 <code>raw</code> 按钮即可得到源文件的直链：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190303111930.png" alt="" /></p></li>

<li><p>跳转最新 release 的页面是根据 tag 名进行跳转的，所以 tag 名称最好与版本号命名规则一致，当然不一致也可以，只要最终能对应上就可以，比如十里的一个开源项目 <a href="https://github.com/smslit/textGO" target="_blank">textGO</a>，对应 tag 的 release 页面链接可以轻易获得：<code>https://github.com/smslit/textGO/releases/tag/v0.3</code> ，规则就是 <code>https://github.com/smslit/textGO/releases/tag/v</code> + 版本号</p></li>

<li><p>第一步网络请求 <code>info.plist</code> 文件使用 GET 请求即可完成，网络请求相关内容可以通过另一篇文章了解：<a href="/2019/01/26/get_post_cocoa/" target="_blank">macOS 开发之实现 HTTP 的 GET 和 POST 请求</a></p></li>
</ul>

<h1 id="示例">示例</h1>

<p>下面以十里的开源项目 <a href="https://github.com/smslit/textGO" target="_blank">textGO</a> 为例说明一下实现。</p>

<h2 id="更新器类">更新器类</h2>

<p>因为十里将项目托管到的是 github 平台，所以封装的更新器类仅适用于 github，如果适配其它平台只需修改两处 url 的处理即可。更新器类为 TextGoUpdater ，在文件 <code>TextGoUpdater.swift</code> 中定义，您可以打开这个<a href="https://github.com/smslit/textGO/blob/master/textGO/TextGoUpdater.swift" target="_blank">文件</a>查看具体实现代码。</p>

<h3 id="属性">属性</h3>

<p>TextGoUpdater 类中定义了两个属性，分别是 <code>user</code>、<code>url</code>。</p>

<ul>
<li><code>user</code> 指的是 github 的账户名</li>
<li><code>url</code> 指的是 <code>info.plist</code> 文件的直链</li>
</ul>

<h3 id="方法">方法</h3>

<ul>
<li><code>init(user:)</code> 初始化方法，初始化过程中根据提供的 github 账户名和工程名推断出 <code>info.plist</code> 文件的直链并赋给 url 属性</li>
<li><code>check(callback:)</code> 触发检查更新的过程，是公共方法。<code>callback</code> 是个逃逸闭包，完成网络请求后在进行数据处理前执行，主要方便调整控件的状态。</li>
<li><code>checkUpdateRequestSuccess(data:response:error:callback:)</code> 封装了网络请求完成后的处理过程，是私有方法。另外使用的两个 <code>tipInfo</code> 方法在 <code>TextGoPublic.swift</code> 文件中定义，用来显示提示框告知用户检测更新的结果。检测到更新以后，会根据类的 user 属性和工程名称以及最新版本号推断出 release 页面链接。</li>
</ul>

<h3 id="使用方法">使用方法</h3>

<p>使用方法很简单，主要分两种：有回调和没有回调。</p>

<h4 id="无回调使用">无回调使用</h4>

<p>可以在文件 <code>AppDelegate.swift</code> 中看到使用方法</p>

<ul>
<li>定义属性 updater</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">updater</span> <span class="p">=</span> <span class="n">TextGoUpdater</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="s">&#34;smslit&#34;</span><span class="p">)</span> <span class="p">{}</span></code></pre></div>
<ul>
<li>在 <code>checkUpdate()</code> 方法中直接调用 updater 实例的 check 方法：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">checkUpdate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">updater</span><span class="p">.</span><span class="n">check</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span></code></pre></div>
<h4 id="有回调使用">有回调使用</h4>

<ul>
<li>定义属性 updater</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kd">let</span> <span class="nv">updater</span> <span class="p">=</span> <span class="n">TextGoUpdater</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="s">&#34;smslit&#34;</span><span class="p">)</span> <span class="p">{}</span></code></pre></div>
<ul>
<li>在 <code>checkUpdate()</code> 方法中直接调用 updater 实例的 check 方法：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="kr">@objc</span> <span class="kd">func</span> <span class="nf">checkUpdate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">updater</span><span class="p">.</span><span class="n">check</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 实现对界面控件的调整</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h2 id="执行效果">执行效果</h2>

<p>textGO 是一个菜单栏小工具，通过点击<code>检查更新</code>菜单项触发更新的检查，为了更好的展示效果，以视频展示，同时修改版本号来查看有更新和没更新两种情况的效果。</p>

<video src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/check_update_simple.mp4" width="960px" controls="controls"></video>

<h1 id="总结">总结</h1>

<p>本文更新器的实现思路比较简单，只是提供了检查更新的功能，不过一般情况下这就足够了，其实这种方法也能适用于托管平台的私有项目，可以在平台中共享出某个可以提供版本号的文件，得到它的直链就可以，思路一样，想办法更改两处链接就能实现。最后，祝您成功！</p>
]]></content>
		</item>
		
		<item>
			<title>macOS 开发之本地化工具 bartycrouch 4 使用教程</title>
			<link>https://www.smslit.top/2019/03/01/macOS-dev-bartycrouch4-tutorial/</link>
			<pubDate>Fri, 01 Mar 2019 08:59:33 +0800</pubDate>
			
			<guid>https://www.smslit.top/2019/03/01/macOS-dev-bartycrouch4-tutorial/</guid>
			<description>前些日子写了三篇关于 macOS app 本地化的文章，在文章中用到了一个名为 bartycrouch 的工具，当时十里安装的 bartycrouch 版本是 v3.13.3，昨天升级了 bartycrouch 现在是 v4.0.0 ，发现使用方</description>
			<content type="html"><![CDATA[

<p>前些日子写了三篇关于 macOS app 本地化的文章，在文章中用到了一个名为 bartycrouch 的工具，当时十里安装的 bartycrouch 版本是 v3.13.3，昨天升级了 bartycrouch 现在是 v4.0.0 ，发现使用方法变化还挺大，所以赶快在前面三篇文章中标注了一下版本使用问题，本文简单介绍一下 bartycrouch 4 的使用。</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190301092140.png" alt="" /></p>

<h2 id="开发平台">开发平台</h2>

<ul>
<li>macOS 10.14.3</li>
<li>swift 4.2.1</li>
<li>xcode 10.1</li>
</ul>

<h2 id="bartycrouch-准备">bartycrouch 准备</h2>

<blockquote>
<p>BartyCrouch incrementally updates your Strings files from your Code and from Interface Builder files. &ldquo;Incrementally&rdquo; means that BartyCrouch will by default keep both your already translated values and even your altered comments. Additionally you can also use BartyCrouch for machine translating from one language to 60+ other languages. Using BartyCrouch is as easy as running a few simple commands from the command line what can even be automated using a build script within your project.</p>
</blockquote>

<p><a href="https://github.com/Flinesoft/BartyCrouch" target="_blank">BartyCrouch</a></p>

<p>bartycrouch 可以依据 interfaces 文件( xib 文件) 和代码(swift 、m、h 文件)来增量更新 strings 文件。在这里 <strong>增量</strong> 是指 bartycrouch 会默认保留已经翻译的值及改变了的注释。另外您也可使用 bartycrouch 借助微软的服务从一种语言机器翻译成超过 60+ 种语言。在命令行调用几个简单的命令您就可以轻而易举的使用 bartycrouch，另外您也可以在 xcode 的工程配置中添加运行脚本自动化使用 bartycrouch 完成您期望的任务。</p>

<h3 id="依赖">依赖</h3>

<ul>
<li>Xcode 10.1+</li>
<li>Swift 4.2+</li>
<li>Xcode Command Line Tools (详见：<a href="http://stackoverflow.com/a/9329325/3451975" target="_blank">点我</a>)</li>
</ul>

<h3 id="安装方法">安装方法</h3>

<p><details>
<summary>使用 <a href="https://brew.sh/" target="_blank">Homebrew</a> 安装</summary></p>

<p>通过下面的命令可以很容易安装 bartycrouch:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">brew install bartycrouch</code></pre></div>
<p>另外可以通过下面的命令更新 bartycrouch，保证一直使用最新保本:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">brew upgrade bartycrouch</code></pre></div>
<p></details></p>

<p><details>
<summary>通过 <a href="https://github.com/yonaskolb/Mint" target="_blank">Mint</a> 安装</summary></p>

<p>通过以下命令就可以安装 bartycrouch（目前通过这种方式会出现缺少动态库的问题，估计很快就会修复了，所以建议使用 homebrew 安装的方式）:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">mint install Flinesoft/BartyCrouch</code></pre></div>
<p></details></p>

<h2 id="bartycrouch-使用">bartycrouch 使用</h2>

<p>这里提醒一下，如果您直接用一个现有的工程尝试这个工具的话，以防万一请先用 git <em>提交</em> 一下您的代码，尽量保证安全，另外这里强烈建议如果研究明白怎么用了后使用为 xcode <a href="#创建编译脚本">创建编译脚本</a> 的方式使用 bartycrouch。</p>

<p>在命令行下，先执行一下 <code>bartycrouch -h</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-Bash" data-lang="Bash">$ bartycrouch -h

Usage: bartycrouch &lt;command&gt; <span class="o">[</span>options<span class="o">]</span>

Incrementally update <span class="p">&amp;</span> translate your Strings files from code or interface files.

Commands:
  init            Creates the default configuration file <span class="p">&amp;</span> creates a build script <span class="k">if</span> Xcode project found
  update          Update your .strings file contents with the configured tasks <span class="o">(</span>default: interfaces, code, normalize<span class="o">)</span>
  lint            Lints your .strings file contents
  <span class="nb">help</span>            Prints <span class="nb">help</span> information
  version         Prints the current version of this app</code></pre></div>
<ul>
<li><code>help</code>: 打印帮助信息，也就是上面，<code>bartycrouch -h</code> 等同于 <code>bartycrouch help</code></li>
<li><code>version</code>: 打印当前 bartycrouch 的版本号</li>
</ul>

<p>下面以 bartycrouch 正常的使用流程分别讲一下 <code>init</code> <code>update</code> 和 <code>lint</code> 三个命令。</p>

<h3 id="init-命令">init 命令</h3>

<p>这个命令用于生成针对 Xcode 工程的 bartycrouch 配置文件。进入到 xcode 的根目录，执行以下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-Bash" data-lang="Bash">bartycrouch init</code></pre></div>
<p>工程根目录下会出现名为 <code>.bartycrouch.toml</code> 的文件。</p>

<p><details><summary><code>.bartycrouch.toml</code> 默认内容</summary></p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">update</span><span class="p">]</span>
<span class="nx">tasks</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;interfaces&#34;</span><span class="p">,</span> <span class="s2">&#34;code&#34;</span><span class="p">,</span> <span class="s2">&#34;transform&#34;</span><span class="p">,</span> <span class="s2">&#34;normalize&#34;</span><span class="p">]</span>

<span class="p">[</span><span class="nx">update</span><span class="p">.</span><span class="nx">interfaces</span><span class="p">]</span>
<span class="nx">path</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">defaultToBase</span> <span class="p">=</span> <span class="kc">false</span>
<span class="nx">ignoreEmptyStrings</span> <span class="p">=</span> <span class="kc">false</span>
<span class="nx">unstripped</span> <span class="p">=</span> <span class="kc">false</span>

<span class="p">[</span><span class="nx">update</span><span class="p">.</span><span class="nx">code</span><span class="p">]</span>
<span class="nx">codePath</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">localizablePath</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">defaultToKeys</span> <span class="p">=</span> <span class="kc">false</span>
<span class="nx">additive</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">unstripped</span> <span class="p">=</span> <span class="kc">false</span>

<span class="p">[</span><span class="nx">update</span><span class="p">.</span><span class="nx">transform</span><span class="p">]</span>
<span class="nx">codePath</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">localizablePath</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">transformer</span> <span class="p">=</span> <span class="s2">&#34;foundation&#34;</span>
<span class="nx">supportedLanguageEnumPath</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">typeName</span> <span class="p">=</span> <span class="s2">&#34;BartyCrouch&#34;</span>
<span class="nx">translateMethodName</span> <span class="p">=</span> <span class="s2">&#34;translate&#34;</span>

<span class="p">[</span><span class="nx">update</span><span class="p">.</span><span class="nx">normalize</span><span class="p">]</span>
<span class="nx">path</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">sourceLocale</span> <span class="p">=</span> <span class="s2">&#34;en&#34;</span>
<span class="nx">harmonizeWithSource</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">sortByKeys</span> <span class="p">=</span> <span class="kc">true</span>

<span class="p">[</span><span class="nx">lint</span><span class="p">]</span>
<span class="nx">path</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">duplicateKeys</span> <span class="p">=</span> <span class="kc">true</span>
<span class="nx">emptyValues</span> <span class="p">=</span> <span class="kc">true</span></code></pre></div>
<p></details></p>

<p>在这个配置文件中包含了另外两个命令( update 和 lint )的相关配置，这是 bartycrouch 的默认配置，应该可以在绝大多数工程中使用，但是这里需要注意以下几点：</p>

<ul>
<li><code>[update]</code> 的值就代表了，执行 <code>bartycrouch update</code> 时要完成的任务，不想执行某个任务可以直接删除，比如不执行 <code>code</code> 任务，可以写成：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">update</span><span class="p">]</span>
<span class="nx">tasks</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;interfaces&#34;</span><span class="p">,</span> <span class="s2">&#34;transform&#34;</span><span class="p">,</span> <span class="s2">&#34;normalize&#34;</span><span class="p">]</span></code></pre></div>
<ul>
<li><p>每个任务子项中都包含了对应的配置信息，可依据工程需要进行调整，具体含义可以参考后面任务的介绍</p></li>

<li><p>尽可能为包含关键字的 <code>path</code> 键提供具体的路径名称 (例如：<code>codePath</code> 设置为包含 swift 代码文件的目录)</p></li>

<li><p>如果您的工程是纯 swift 实现并且使用了 update 命令的的 <a href="#transform-任务"><code>tranform</code> 任务</a>，可以删除 <code>code</code> 任务</p></li>

<li><p>如果您正在使用支持 <code>structured-swift4</code> 模板的 <a href="https://github.com/SwiftGen/SwiftGen#strings" target="_blank">SwiftGen</a> ，您需要将 <code>[update.transform]</code> 的 <code>transformer</code> 从 <code>foundation</code> 改为 <code>swiftgenStructured</code></p></li>

<li><p>如果您要使用 <code>transform</code> 任务，需要在工程中创建一个新文件，命名为 <code>BartyCrouch.swift</code>，内容如下：</p></li>
</ul>

<p><details><summary><code>BartyCrouch.swift</code> 代码</summary></p>
<div class="highlight"><pre class="chroma"><code class="language-Swift" data-lang="Swift"><span class="c1">//</span>
<span class="c1">//  This file is required in order for the `transform` task of the translation helper tool BartyCrouch to work.</span>
<span class="c1">//  See here for more details: https://github.com/Flinesoft/BartyCrouch</span>
<span class="c1">//</span>

<span class="kd">import</span> <span class="nc">Foundation</span>

<span class="kd">enum</span> <span class="nc">BartyCrouch</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="nc">SupportedLanguage</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="c1">// </span><span class="cs">TODO:</span><span class="c1"> remove unsupported languages from the following cases list &amp; add any missing languages</span>
        <span class="k">case</span> <span class="n">arabic</span> <span class="p">=</span> <span class="s">&#34;ar&#34;</span>
        <span class="k">case</span> <span class="n">chineseSimplified</span> <span class="p">=</span> <span class="s">&#34;zh-Hans&#34;</span>
        <span class="k">case</span> <span class="n">chineseTraditional</span> <span class="p">=</span> <span class="s">&#34;zh-Hant&#34;</span>
        <span class="k">case</span> <span class="n">english</span> <span class="p">=</span> <span class="s">&#34;en&#34;</span>
        <span class="k">case</span> <span class="n">french</span> <span class="p">=</span> <span class="s">&#34;fr&#34;</span>
        <span class="k">case</span> <span class="n">german</span> <span class="p">=</span> <span class="s">&#34;de&#34;</span>
        <span class="k">case</span> <span class="n">hindi</span> <span class="p">=</span> <span class="s">&#34;hi&#34;</span>
        <span class="k">case</span> <span class="n">italian</span> <span class="p">=</span> <span class="s">&#34;it&#34;</span>
        <span class="k">case</span> <span class="n">japanese</span> <span class="p">=</span> <span class="s">&#34;ja&#34;</span>
        <span class="k">case</span> <span class="n">korean</span> <span class="p">=</span> <span class="s">&#34;ko&#34;</span>
        <span class="k">case</span> <span class="n">malay</span> <span class="p">=</span> <span class="s">&#34;ms&#34;</span>
        <span class="k">case</span> <span class="n">portuguese</span> <span class="p">=</span> <span class="s">&#34;pt-BR&#34;</span>
        <span class="k">case</span> <span class="n">russian</span> <span class="p">=</span> <span class="s">&#34;ru&#34;</span>
        <span class="k">case</span> <span class="n">spanish</span> <span class="p">=</span> <span class="s">&#34;es&#34;</span>
        <span class="k">case</span> <span class="n">turkish</span> <span class="p">=</span> <span class="s">&#34;tr&#34;</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">translate</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">translations</span><span class="p">:</span> <span class="p">[</span><span class="n">SupportedLanguage</span><span class="p">:</span> <span class="nb">String</span><span class="p">],</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">typeName</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">describing</span><span class="p">:</span> <span class="n">BartyCrouch</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">methodName</span> <span class="p">=</span> <span class="kc">#function</span>

        <span class="bp">print</span><span class="p">(</span>
            <span class="s">&#34;Warning: [BartyCrouch]&#34;</span><span class="p">,</span>
            <span class="s">&#34;Untransformed </span><span class="si">\(</span><span class="n">typeName</span><span class="si">)</span><span class="s">.</span><span class="si">\(</span><span class="n">methodName</span><span class="si">)</span><span class="s"> method call found with key &#39;</span><span class="si">\(</span><span class="n">key</span><span class="si">)</span><span class="s">&#39; and base translations &#39;</span><span class="si">\(</span><span class="n">translations</span><span class="si">)</span><span class="s">&#39;.&#34;</span><span class="p">,</span>
            <span class="s">&#34;Please ensure that BartyCrouch is installed and configured correctly.&#34;</span>
        <span class="p">)</span>

        <span class="c1">// fall back in case something goes wrong with BartyCrouch transformation</span>
        <span class="k">return</span> <span class="s">&#34;BC: TRANSFORMATION FAILED!&#34;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p></details></p>

<ul>
<li><p>如果您的第一语言不是英语, 您需要将 <code>normalize</code> 任务的 <code>sourceLocale</code> 改为您的第一语言，值参考上面代码中的枚举 <code>SupportedLanguage</code> 的元素</p></li>

<li><p>如果您想使用 bartycrouch 的翻译功能，需要将如下的配置添加到 <code>.bartycrouch.toml</code> 中，并且将 <code>translate</code> 添加到任务列表中，其中您需要将 <code>secret</code> 的值替换成您的 <a href="https://docs.microsoft.com/en-us/azure/cognitive-services/translator/translator-text-how-to-signup#authentication-key" target="_blank">Microsoft Translator Text API Subscription Key</a>:</p></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">update</span><span class="p">.</span><span class="nx">translate</span><span class="p">]</span>
<span class="nx">path</span> <span class="p">=</span> <span class="s2">&#34;.&#34;</span>
<span class="nx">secret</span> <span class="p">=</span> <span class="s2">&#34;&lt;#Subscription Key#&gt;&#34;</span>
<span class="nx">sourceLocale</span> <span class="p">=</span> <span class="s2">&#34;en&#34;</span></code></pre></div>
<h3 id="update-命令">update 命令</h3>

<p>update 命令可以执行以下几个任务：</p>

<ul>
<li><code>interfaces</code>: 从 Storyboards &amp; XIBs 更新 <code>.strings</code> 文件</li>
<li><code>code</code>: 根据代码中的 <code>NSLocalizedString</code> 调用更新 <code>Localizable.strings</code></li>
<li><code>transform</code>: 仅支持 swift 文件，可以替换特定方法的调用替换为可以提供多种语言翻译的单行方式</li>
<li><code>translate</code>: 从指定语言翻译成多种语言并替换结果到 strings 文件中</li>
<li><code>normalize</code>: 格式化 <code>.strings</code> 文件内容：排序或者清楚多余内容</li>
</ul>

<p>上面已经提到过的，可以通过 <code>.bartycrouch.toml</code> 的 <code>task</code> 配置要执行的任务：</p>
<div class="highlight"><pre class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">update</span><span class="p">]</span>
<span class="nx">tasks</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;interfaces&#34;</span><span class="p">,</span> <span class="s2">&#34;code&#34;</span><span class="p">,</span> <span class="s2">&#34;transform&#34;</span><span class="p">,</span> <span class="s2">&#34;normalize&#34;</span><span class="p">]</span></code></pre></div>
<h4 id="任务配置项介绍">任务配置项介绍</h4>

<p><details><summary><code>interfaces</code> 配置项含义</summary></p>

<ul>
<li><code>path</code>: 查找 Storyboards &amp; XIB 文件的路径</li>
<li><code>defaultToBase</code>: 添加 Base translation 作为新键的值</li>
<li><code>ignoreEmptyStrings</code>: 不添加 views 中是空值的项</li>
<li><code>unstripped</code>: 保留 Strings 文件开始和结尾的空白字符串</li>
</ul>

<p></details></p>

<p><details><summary><code>code</code> 配置项含义</summary></p>

<ul>
<li><code>codePath</code>: 查找 Swift 代码文件的路径</li>
<li><code>localizablePath</code>: 包含 <code>Localizable.strings</code> 文件的目录的父目录</li>
<li><code>defaultsToKeys</code>: 为新键添加与新键名称一致的值</li>
<li><code>additive</code>: 不清除未在代码中发现的键</li>
<li><code>customFunction</code>: 替代 <code>NSLocalizedString</code> 的函数名称</li>
<li><code>customLocalizableName</code>: 替代 <code>Localizable.strings</code> 的文件的名称</li>
<li><code>unstripped</code>: 保留 Strings 文件开始和结尾的空白字符串</li>
</ul>

<p></details></p>

<p><details><summary><code>transform</code> 配置项含义</summary></p>

<ul>
<li><code>codePath</code>: 查找 Swift 代码文件的路径</li>
<li><code>localizablePath</code>:  包含 <code>Localizable.strings</code> 文件的目录的父目录</li>
<li><code>transformer</code>: 指定转换的模式: 若调用 <code>NSLocalizedString</code> 接口，值就设成 <code>foundation</code>; 若调用 <code>L10n</code> 形式的接口，值就设成 <code>swiftgenStructured</code></li>
<li><code>supportedLanguageEnumPath</code>: 包含 <code>SupportedLanguage</code> 枚举定义的 swift 文件的路径</li>
<li><code>typeName</code>: 包含 <code>SupportedLanguage</code> 枚举和翻译方法的类型名称</li>
<li><code>translateMethodName</code>: 翻译方法的名称</li>
<li><code>customLocalizableName</code>: 替代 <code>Localizable.strings</code> 的文件的名称</li>
</ul>

<p></details></p>

<p><details><summary><code>translate</code>  配置项含义</summary></p>

<ul>
<li><code>path</code>: 查找 <code>.strings</code> 文件的路径</li>
<li><code>secret</code>: 您的 <a href="https://docs.microsoft.com/en-us/azure/cognitive-services/translator/translator-text-how-to-signup#authentication-key" target="_blank">Microsoft Translator Text API Subscription Key</a>.</li>
<li><code>sourceLocale</code>: 指定从哪种语言翻译成其他语言</li>
</ul>

<p></details></p>

<p><details><summary><code>normalize</code>  配置项含义</summary></p>

<ul>
<li><code>path</code>: 查找 <code>.strings</code> 文件的路径</li>
<li><code>sourceLocale</code>: 指定依照哪种语言对其他语言的 string 文件进行格式化</li>
<li><code>harmonizeWithSource</code>: 同步键值对的源语言</li>
<li><code>sortByKeys</code>: 按照字母顺序对键进行排序</li>
</ul>

<p></details></p>

<h4 id="transform-任务">transform 任务</h4>

<p>如果配置文件中配置了 <code>transform</code> 任务(详见 <a href="#init-命令">init 命令</a>)并且已经在 xcode 中<a href="#创建编译脚本">创建编译脚本</a>, 在开发中您可以使用下面简化的流程编写本地化代码:</p>

<ul>
<li>您可以使用 <code>BartyCrouch.translate</code> 替代 <code>NSLocalizedString</code> 指定键、翻译方法和注释，例如:</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kc">self</span><span class="p">.</span><span class="n">title</span> <span class="p">=</span> <span class="n">BartyCrouch</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="s">&#34;onboarding.first-page.header-title&#34;</span><span class="p">,</span>  <span class="n">translations</span><span class="p">:</span> <span class="p">[.</span><span class="n">english</span><span class="p">:</span> <span class="s">&#34;Welcome!&#34;</span><span class="p">])</span></code></pre></div>
<ul>
<li><p>编译应用的时候, BartyCrouch 会自动向所有的 <code>Localizable.strings</code> 文件中添加您指定的键，并且为指定语言的键添加指定语言翻译结果</p></li>

<li><p>同时 BartyCrouch 会自动依据配置中指定的 <code>transformer</code> 替换上面 <code>BartyCrouch.translate</code> 的调用为对应的方法</p>

<ul>
<li><p>当 <code>transformer</code> 设置为 <code>foundation</code>, 上面 <code>BartyCrouch.translate</code> 的调用会替换为如下的结果:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kc">self</span><span class="p">.</span><span class="n">title</span> <span class="p">=</span> <span class="n">NSLocalizedString</span><span class="p">(</span><span class="s">&#34;onboarding.first-page.header-title&#34;</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">)</span></code></pre></div></li>

<li><p>当 <code>transformer</code> 设置为 <code>swiftgenStructured</code>, 上面 <code>BartyCrouch.translate</code> 的调用会替换为如下的结果:</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kc">self</span><span class="p">.</span><span class="n">title</span> <span class="p">=</span> <span class="n">L10n</span><span class="p">.</span><span class="n">Onboarding</span><span class="p">.</span><span class="n">FirstPage</span><span class="p">.</span><span class="n">headerTitle</span></code></pre></div></li>
</ul></li>
</ul>

<h5 id="使用-transform-的优点">使用 <code>transform</code> 的优点:</h5>

<ul>
<li>不用为了添加翻译的键值而不断的切换不同语言的 Strings 文件</li>
<li>一旦使用了 SwiftGen, 不需要手动替换 <code>NSLocalizedString</code> 为 <code>L10n</code> 的调用了</li>
<li>与机器翻译配合使得只需在代码中使用一行代码就可以实现所有语言的翻译和值的替换</li>
</ul>

<h5 id="使用-transform-的缺点">使用 <code>transform</code> 的缺点:</h5>

<ul>
<li>只支持 swift 代码而不支持 Objective-C</li>
<li>在下次编译之前，xcode 会有一些错误提示，但是一编译就会没有了错误提示</li>
<li>由于 <a href="https://github.com/apple/swift-syntax" target="_blank">SwiftSyntax</a> 当前<a href="https://www.jpsim.com/evaluating-swiftsyntax-for-use-in-swiftlint/" target="_blank">运行不是特别快</a>所以看上去不如 <code>code</code> 任务快速. (但是这个会随着时间改善！)</li>
</ul>

<h3 id="lint-命令">lint 命令</h3>

<p>lint 命令可以检查 <code>.strings</code> 文件，主要有下面两个检查项:</p>

<ul>
<li><code>duplicateKeys</code>: 查找同一个文件中重复的键值对</li>
<li><code>emptyValues</code>: 查找空值的键值对</li>
</ul>

<h3 id="创建编译脚本">创建编译脚本</h3>

<p>为了让 xcode 可以使用 bartycrouch 来更新和检查您的 <code>.strings</code> 文件，您可以添加一个编译脚本实现。</p>

<p>按照下图所示步骤添加脚本：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190301131243.jpg" alt="" /></p>

<p><details><summary>脚本内容(点我查看)</summary></p>
<div class="highlight"><pre class="chroma"><code class="language-Bash" data-lang="Bash"><span class="k">if</span> which bartycrouch &gt; /dev/null<span class="p">;</span> <span class="k">then</span>
    bartycrouch update -x
    bartycrouch lint -x
<span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&#34;warning: BartyCrouch not installed, download it from https://github.com/Flinesoft/BartyCrouch&#34;</span>
<span class="k">fi</span></code></pre></div>
<p></details></p>

<p>下一步确保这个运行脚本在 <code>Compiling Sources</code> 和 <code>SwiftGen</code>(如果使用了的话) 之前运行，比如在 <code>Target Dependencies</code> 后面，像下图这样：</p>

<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/img/20190301131815.png" alt="" /></p>

<p>现在每次运行工程，都会自动的更新和检查 <code>.strings</code> 文件，而不用手动处理了。另外如果工程的成员如果没有安装 bartycrouch 的脚本会产生警告：</p>

<blockquote>
<p>warning: BartyCrouch not installed, download it from <a href="https://github.com/Flinesoft/BartyCrouch" target="_blank">https://github.com/Flinesoft/BartyCrouch</a></p>
</blockquote>

<p>另外补充的是，lint 和 update 有以下三个参数可用：</p>

<ul>
<li><strong><code>-v</code>, <code>--verbose</code></strong>: 打印更多的执行信息</li>
<li><strong><code>-x</code>, <code>--xcode-output</code></strong>: 以 xcode 兼容的形式呈现错误和提醒，在 xcode 中的运行脚本中添加以后，一旦检查出错误或警告会在 xcode 的 issue 导航栏中呈现</li>
<li><strong><code>-w</code>, <code>--fail-on-warnings</code></strong>: 遇到警告的时候返回对应代码</li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
