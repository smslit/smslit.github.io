<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c"><meta itemprop="name" content="排序算法知多少">
<meta itemprop="description" content="大学里学的第一门编程语言是 c&#43;&#43;，c&#43;&#43; 的课程中接触的第一种排序算法是冒泡排序，这已经过去八年，很惭愧的是到目前只了解冒泡排序和插入排序两种，作为一名合格的程序猿也应该了解了解其它的排序算法吧！所以开本文记录整理网上所谓的十大排序算法。
">
<meta itemprop="datePublished" content="2018-11-07T15:37:05+08:00" />
<meta itemprop="dateModified" content="2018-11-13T15:00:05+08:00" />
<meta itemprop="wordCount" content="3896">



<meta itemprop="keywords" content="algorithm,python," />
<meta property="og:title" content="排序算法知多少" />
<meta property="og:description" content="大学里学的第一门编程语言是 c&#43;&#43;，c&#43;&#43; 的课程中接触的第一种排序算法是冒泡排序，这已经过去八年，很惭愧的是到目前只了解冒泡排序和插入排序两种，作为一名合格的程序猿也应该了解了解其它的排序算法吧！所以开本文记录整理网上所谓的十大排序算法。
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.smslit.top/2018/11/07/algorithm-sort/" />
<meta property="article:published_time" content="2018-11-07T15:37:05+08:00" />
<meta property="article:modified_time" content="2018-11-13T15:00:05+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="排序算法知多少"/>
<meta name="twitter:description" content="大学里学的第一门编程语言是 c&#43;&#43;，c&#43;&#43; 的课程中接触的第一种排序算法是冒泡排序，这已经过去八年，很惭愧的是到目前只了解冒泡排序和插入排序两种，作为一名合格的程序猿也应该了解了解其它的排序算法吧！所以开本文记录整理网上所谓的十大排序算法。
"/>
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>排序算法知多少</title>
	<link rel="stylesheet" href="https://www.smslit.top/css/style.min.3ad1e3b1b66be9d0a7a1ec736d1c871706f6fed2351dce21060fdde57a9cd3fa.css" integrity="sha256-OtHjsbZr6dCnoexzbRyHFwb2/tI1Hc4hBg/d5Xqc0/o=">
	
	<link rel="stylesheet" href="https://www.smslit.top/css/valine.css">
	<link rel="stylesheet" href="https://www.smslit.top/css/reward.css">
	<link rel="stylesheet" href="https://www.smslit.top/css/asciinema.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://www.smslit.top">SMSLIT</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://www.smslit.top/post/">Posts</a>
				<a href="https://www.smslit.top/tags/">Tags</a>
				<a href="https://www.smslit.top/about/">Me</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="目录"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="http://weibo.com/u/2684217817" target="_blank" rel="noopener me" title="Weibo"><svg width="24px" height="24px" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg"  fill="none" fill-rule="evenodd" class="feather feather-mail">
    <g transform="translate(0.000000, 2.000000)" fill="#000000" fill-rule="nonzero" id="形状">
        <path d="M23.7,8.59152679 C23.6,8.94964029 23.25,9.20543566 22.9,9.25659472 C22.55,9.30775379 22.2,9.10311751 22,8.745004 C21.9,8.54036772 21.85,8.28457235 21.95,8.02877698 C22.45,6.44284573 22.1,4.70343724 21,3.4756195 C19.9,2.24780175 18.3,1.68505194 16.7,2.04316547 C16.45,2.09432453 16.2,2.04316547 16,1.88968825 C15.8,1.73621103 15.65,1.53157475 15.6,1.27577938 C15.5,0.764188657 15.8,0.252597914 16.3,0.150279784 C18.45,-0.310151871 20.75,0.354916067 22.35,2.14548362 C23.95,3.98721024 24.35,6.44284573 23.7,8.59152679 Z M17.35,5.06155077 C17.15,5.11270983 16.95,5.06155077 16.75,4.95923261 C16.55,4.85691446 16.45,4.65227818 16.4,4.44764189 C16.3,3.98721024 16.6,3.57793765 17,3.4756195 C18.1,3.21982412 19.2,3.62909671 19.95,4.44764189 C20.7,5.31734614 20.9,6.4940048 20.6,7.56834532 C20.55,7.77298161 20.4,7.92645882 20.2,8.02877698 C20,8.13109513 19.8,8.13109513 19.6,8.07993604 C19.2,7.92645882 18.95,7.46602717 19.1,7.0567546 C19.25,6.54516388 19.15,5.93125501 18.8,5.52198242 C18.4,5.11270983 17.85,4.95923261 17.35,5.06155077 Z M18.05,9.66586731 C19.45,10.126299 20.95,11.1494804 20.95,13.0423661 C20.95,16.1119105 16.6,20 10.1,20 C5.1,20 1.13686838e-13,17.5443645 1.13686838e-13,13.4516387 C1.13686838e-13,11.3029576 1.30000001,8.84732213 3.6,6.54516386 C6.6,3.42446043 10.15,2.04316547 11.45,3.37330137 C12.05,3.98721024 12.1,5.0103917 11.7,6.23820942 C11.5,6.8521183 12.25,6.4940048 12.25,6.4940048 C14.7,5.41966427 16.85,5.3685052 17.6,6.54516386 C18,7.15907273 17.95,8.02877698 17.6,9.00079935 C17.45,9.46123101 17.7,9.56354916 18.05,9.66586731 Z M10.1,18.5163869 C14.05,18.1071143 17.1,15.6003197 16.85,12.940048 C16.6,10.2797762 13.15,8.43804957 9.19999999,8.84732213 C5.25,9.25659472 2.19999998,11.7633893 2.44999999,14.4236611 C2.7,17.0839329 6.09999998,18.9256595 10.1,18.5163869 Z M10.5,10.8936851 C12.45,11.4052758 13.45,13.2981615 12.65,15.1398881 C11.85,17.0327738 9.49999999,18.0047962 7.54999999,17.3908873 C5.64999998,16.7769784 4.84999999,14.8329336 5.65000001,13.0935252 C6.45,11.3541167 8.60000002,10.3820943 10.5,10.8936851 Z M9.04999999,15.3445244 C9.45,14.7306155 9.24999998,13.9632294 8.59999999,13.7074341 C7.99999999,13.4516387 7.2,13.7074341 6.79999999,14.3213429 C6.39999998,14.9352518 6.6,15.6514788 7.2,15.9584333 C7.84999999,16.2653877 8.65000001,16.0095923 9.04999999,15.3445244 Z" fill="currentColor"></path>
    </g>
</svg></a><a href="https://www.zhihu.com/people/smslit/activities" target="_blank" rel="noopener me" title="Zhihu"><svg width="24px" height="24px" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" fill="none" fill-rule="evenodd" class="feather feather-mail">
    <path d="M12.1197571,11.3394973 C11.2394396,11.2471275 8.50587146,11.3394973 8.50587146,11.3394973 L8.50587146,5.8004836 L12.5830381,5.8004836 C12.5830381,5.8004836 12.5367176,3.95412048 11.7490411,3.95412048 L5.12356308,3.95412048 L6.23550841,1 C6.23550841,1 4.56753979,1.09236985 3.96524661,2.15395489 C3.36295344,3.21553992 1.46333165,8.52386857 1.46333165,8.52386857 C1.46333165,8.52386857 2.11199596,8.80082682 3.17759547,8.0161496 C4.2432456,7.2314976 4.6138603,5.84665591 4.6138603,5.84665591 L6.5598026,5.75428606 L6.60612311,11.3856444 C6.60612311,11.3856444 3.22394129,11.3394973 2.52895647,11.3856444 C1.83397166,11.4317915 1.46330634,13.2781799 1.46330634,13.2781799 L6.60619904,13.2781799 C6.60619904,13.2781799 6.14281677,16.4169392 4.8455894,18.6787523 C3.50191497,20.9405149 1,22.7406553 1,22.7406553 C1,22.7406553 2.80693015,23.4791854 4.56761573,22.4636971 C6.32822537,21.4020364 7.62555398,16.8323387 7.62555398,16.8323387 L11.7491424,21.9559781 C11.7491424,21.9559781 12.1197824,19.5096018 11.7028219,18.8172188 C11.2394396,18.1248358 8.83019096,15.3553541 8.83019096,15.3553541 L7.76454082,16.2784726 L8.50584615,13.2319823 L12.9999986,13.2319823 C13.0000745,13.2320328 13.0000745,11.4318672 12.1197571,11.3394973 Z M14.0447646,4 L14,20.8940959 L15.6119399,20.8940959 L16.1940015,23 L19.014927,20.8940959 L23,20.8940959 L23,4 L14.0448624,4 L14.0447646,4 Z M21,18.2118088 L19.2203194,18.2118088 L16.9745545,20 L16.4660842,18.2118088 L16,18.2118088 L16,6 L21,6 L21,18.2118088 Z" id="形状" fill="currentColor" fill-rule="nonzero"></path>    
</svg></a><a href="mailto:5km@smslit.cn" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="https://github.com/smslit" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="菜单"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://www.smslit.top/post/">Posts</a></li>
			<li><a href="https://www.smslit.top/tags/">Tags</a></li>
			<li><a href="https://www.smslit.top/about/">Me</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Nov 7, 2018</span></div>
				<h1>排序算法知多少</h1>
			</header>
			<div class="content">
				<p>大学里学的第一门编程语言是 c++，c++ 的课程中接触的第一种排序算法是<strong>冒泡排序</strong>，这已经过去八年，很惭愧的是到目前只了解<strong>冒泡排序</strong>和<strong>插入排序</strong>两种，作为一名合格的程序猿也应该了解了解其它的排序算法吧！所以开本文记录整理网上所谓的<strong>十大排序算法</strong>。</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/2018111115418975029904.gif" alt="2018111115418975029904.gif"></p>
<h1 id="排序算法概述">排序算法概述</h1>
<p>网上常见的排序算法有十种：<a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>、<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>、<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a>、<a href="https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a>。</p>
<h2 id="排序算法分类">排序算法分类</h2>
<p>上面十大排序算法按照<strong>非线性时间比较类排序</strong>^[<strong>非线性时间比较类排序</strong>: 通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 $O(n\log n)$ ，因此称为非线性时间比较类排序。]和<strong>线性时间非比较类排序</strong>^[<strong>线性时间非比较类排序</strong>: 不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。]进行分类：</p>
<p>![](<a href="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/blog/img/Surface">https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/blog/img/Surface</a> Pro 4 – <a href="mailto:1@2x.png">1@2x.png</a>)</p>
<h2 id="排序算法对比">排序算法对比</h2>
<p>从<strong>时间复杂度</strong>^[<strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。]、<strong>空间复杂度</strong>^[<strong>空间复杂度</strong>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。]和 <strong>稳定性</strong>^[<strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。]三方面对比十种排序方法如下：</p>
<style>
table th:first-of-type {
    width:75px;
}
table th:last-of-type {
    width:75px;
}
</style>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>时间复杂度(最好)</th>
<th>空间复杂度(平均)</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n\log_2 n)$</td>
<td>$O(n^2)$</td>
<td>$O(n\log_2 n)$</td>
<td>$O(n\log_2 n)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n^{1.3})$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\log_2 n)$</td>
<td>$O(n\log_2 n)$</td>
<td>$O(n\log_2 n)$</td>
<td>$O(1)$</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(n\log_2 n)$</td>
<td>$O(n\log_2 n)$</td>
<td>$O(n\log_2 n)$</td>
<td>$O(n)$</td>
<td>稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(n+k)$</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n\cdot k)$</td>
<td>$O(n \cdot k)$</td>
<td>$O(n \cdot k)$</td>
<td>$O(n+k)$</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h1 id="冒泡排序">冒泡排序</h1>
<p><code>2018年11月08日</code></p>
<p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作重复地进行直到没有元素需要交换，即排序完成。这个算法进行时越小的元素会经交换慢慢“浮”到数列的顶端，故得“冒泡之名。</p>
<h2 id="冒泡排序步骤">冒泡排序步骤</h2>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</li>
</ol>
<p>为了方便理解，以数组 <code>[12, 3, 45, 65, 54, 34, 78, 9 ,10, 23]</code> 排序为例，排序过程如以下动图：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/2018111115418975029904.gif" alt="2018111115418975029904.gif"></p>
<h2 id="冒泡排序示例代码">冒泡排序示例代码</h2>
<p>python3 实现冒泡算法封装成函数如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">numlist</span><span class="p">):</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">numlist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">numlist</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numlist</span>
</code></pre></div><p>进行测试，简单测试代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">9</span> <span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorting... {l}&#39;</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorted  -&gt; {l}&#39;</span><span class="p">)</span>
</code></pre></div><p>运行脚本，一切OK：</p>
<div class="highlight"><pre class="chroma"><code class="language-Shell" data-lang="Shell">$ python3 bubble.py
sorting... <span class="o">[</span>12, 3, 45, 65, 54, 34, 78, 9, 10, 23<span class="o">]</span>
sorted  -&gt; <span class="o">[</span>3, 9, 10, 12, 23, 34, 45, 54, 65, 78<span class="o">]</span>
</code></pre></div><h1 id="快速排序">快速排序</h1>
<p><code>2018年11月09日</code></p>
<p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序
$n$ 个项目要 $O(n\log n)$（大O符号）次比较。在最坏状况下则需要 $O(n^2)$ 次比较，但这种状况并不常见。事实上，快速排序 $\Theta (n\log n)$ 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>
<h2 id="快速排序步骤">快速排序步骤</h2>
<p>快排采用和归并排序相同的分而治之的思想，将待排序数组分成左右两个子数组，对两部分子数组独立排序。当子数组均有序时，整个数组也就有序了^[<a href="http://www.litreily.top/2018/07/07/quick-sort/#%E5%BF%AB%E6%8E%92%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><strong>Python实现快排及其可视化——快排基本原理</strong></a>]。</p>
<ol>
<li>将原始数组 <code>data</code> 随机打乱，以消除对输入的依赖（本步可选）</li>
<li>选择数组的某个元素作切分元素 <code>v</code>，比如首个元素 <code>data[0]</code></li>
<li>切分数组
<ul>
<li>从左往右找到第一个大于切分元素v的元素 <code>data[i]</code></li>
<li>从右到左找到第一个小于切分元素v的元素 <code>data[j]</code></li>
<li>交换 <code>data[i]</code> 与 <code>data[j]</code></li>
<li>重复以上三步直到 <code>i &gt;= j</code></li>
<li>交换 <code>data[j]</code> 与切分元素 <code>data[0]</code></li>
</ul>
</li>
<li>递归调用，对切分后的左侧子数组进行排序</li>
<li>递归调用，对切分后的右侧子数组进行排序</li>
</ol>
<p>为了方便理解，以数组 <code>[12, 3, 45, 65, 54, 34, 78, 9 ,10, 23]</code> 排序为例，排序过程如以下动图:</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20181111154194773939997.gif" alt="20181111154194773939997.gif"></p>
<h2 id="快速排序示例代码">快速排序示例代码</h2>
<p>python3 实现快速排序封装成函数如下(代码中选择最后一个元素作切分元素 <code>v</code>)：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python">    <span class="k">if</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
        <span class="n">quicksort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">quicksort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span>
    <span class="k">return</span>

<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">hi</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
</code></pre></div><p>测试实现的快速排序算法：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">9</span> <span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorting... {l}&#39;</span><span class="p">)</span>
    <span class="n">quicksort</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorted:    {l}&#39;</span><span class="p">)</span>
</code></pre></div><p>测试一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-Shell" data-lang="Shell">$ python3 quick.py
sorting... <span class="o">[</span>12, 3, 45, 65, 54, 34, 78, 9, 10, 23<span class="o">]</span>
sorted:    <span class="o">[</span>3, 9, 10, 12, 23, 34, 45, 54, 65, 78<span class="o">]</span>
</code></pre></div><h1 id="插入排序">插入排序</h1>
<p><code>2018年11月10日</code></p>
<p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 <strong>in-place</strong> 排序（即只需用到 $O(1)$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h2 id="插入排序步骤">插入排序步骤</h2>
<p>一般来说，插入排序都采用 <strong>in-place</strong> 在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p>为了方便理解，以数组 <code>[12, 3, 45, 65, 54, 34, 78, 9 ,10, 23]</code> 排序为例，排序过程如以下动图：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20181111154194998895578.gif" alt="20181111154194998895578.gif"></p>
<h2 id="插入排序示例代码">插入排序示例代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre></div><p>测试一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">9</span> <span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorting... {l}&#39;</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">insert_sort</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorted:    {l}&#39;</span><span class="p">)</span>
</code></pre></div><p>结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Shell" data-lang="Shell">$ python3 insert.py
sorting... <span class="o">[</span>12, 3, 45, 65, 54, 34, 78, 9, 10, 23<span class="o">]</span>
sorted:    <span class="o">[</span>3, 9, 10, 12, 23, 34, 45, 54, 65, 78<span class="o">]</span>
</code></pre></div><h1 id="希尔排序">希尔排序</h1>
<p><code>2018年11月11日</code></p>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序按其设计者<a href="https://zh.wikipedia.org/w/index.php?title=%E5%94%90%E7%BA%B3%E5%BE%B7.%E5%B8%8C%E5%B0%94&amp;action=edit&amp;redlink=1">希尔（Donald Shell）</a>的名字命名，该算法由1959年公布。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ol>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。</p>
<p>Donald Shell最初建议步长选择为 $\frac{n}{2}$ 并且对步长取半直到步长达到1。虽然这样取可以比 $\mathcal {O} (n^{2})$ 类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了^[已知的最好步长序列是由 Sedgewick 提出的 <code>(1, 5, 19, 41, 109,...)</code>，该序列的项来自 $9\times 4^{i}-9\times 2^{i}+1 $ 和 $2^{{i+2}}\times (2^{{i+2}}-3)+1$ 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。——<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#%E6%AD%A5%E9%95%BF%E5%BA%8F%E5%88%97"><strong>希尔排序</strong></a> @ <a href="https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5"><strong>维基百科</strong></a> ]。</p>
<h2 id="希尔排序步骤">希尔排序步骤</h2>
<p>这里步长选择为 $\frac{n}{2}$ 并且对步长取半直到步长达到1的序列：</p>
<p>序列个数为 $n$，初始化步长 $stepsize = n$。</p>
<ol>
<li>取新步长为 $\frac{stepsize}{2}$，如果 $stepsize &lt; 1$ 算法结束</li>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出按照新步长 $stepsize$ 的下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到按新步长的下一位置</li>
<li>重复步骤 4，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置</li>
<li>重复步骤 3~6，直到按照新步长 $stepsize$ 的插入排序结束</li>
<li>重复 1～7步骤</li>
</ol>
<p>为了方便理解，以数组 <code>[12, 3, 45, 65, 54, 34, 78, 9 ,10, 23]</code> 排序为例，排序过程如以下动图：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20181112154195404360778.gif" alt="20181112154195404360778.gif"></p>
<h2 id="希尔排序示例代码">希尔排序示例代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="n">numlist</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">numlist</span><span class="p">)</span>
    <span class="c1"># 初始步长</span>
    <span class="n">stepsize</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">stepsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stepsize</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="c1"># 每个步长进行插入排序</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">numlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="c1"># 插入排序</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">stepsize</span> <span class="ow">and</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">stepsize</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">:</span>
                <span class="n">numlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">stepsize</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="n">stepsize</span>
            <span class="n">numlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="c1"># 得到新的步长</span>
        <span class="n">stepsize</span> <span class="o">=</span> <span class="n">stepsize</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">numlist</span>
</code></pre></div><p>测试一下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">9</span> <span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorting... {l}&#39;</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">shell_sort</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorted:    {l}&#39;</span><span class="p">)</span>
</code></pre></div><p>结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Shell" data-lang="Shell">$ python3 shell.py
sorting... <span class="o">[</span>12, 3, 45, 65, 54, 34, 78, 9, 10, 23<span class="o">]</span>
sorted:    <span class="o">[</span>3, 9, 10, 12, 23, 34, 45, 54, 65, 78<span class="o">]</span>
</code></pre></div><h1 id="选择排序">选择排序</h1>
<p><code>2018年11月12日</code></p>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 $n$ 个元素的表进行排序总共进行至多 $n-1$ 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h2 id="选择排序步骤">选择排序步骤</h2>
<ol>
<li>选择未排序的序的首元素作为作为比对元素</li>
<li>往后进行比较，找到最小的元素与首位的元素互换位置</li>
<li>重复 1～2 步一直到只剩一个序列</li>
</ol>
<p>为了方便理解，这里以对序列 <code>[12, 3, 45, 65, 54, 34, 78, 9 ,10, 23]</code> 排序为例展示排序过程动画如下：</p>
<p><img src="https://pichome-1254392422.cos.ap-chengdu.myqcloud.com/20181112154200663696412.gif" alt="20181112154200663696412.gif"></p>
<h2 id="选择排序示例代码">选择排序示例代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="n">numlist</span><span class="p">):</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">numlist</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">numlist</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">numlist</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">min_index</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">numlist</span><span class="p">[</span><span class="n">min_index</span><span class="p">],</span> <span class="n">numlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numlist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">numlist</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numlist</span>
</code></pre></div><p>测试一下封装的算法：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">54</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">9</span> <span class="p">,</span><span class="mi">10</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorting... {l}&#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;sorrted    {select_sort(l)}&#39;</span><span class="p">)</span>
</code></pre></div><p>测试结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-Shell" data-lang="Shell">$ python3 <span class="k">select</span>.py
sorting... <span class="o">[</span>12, 3, 45, 65, 54, 34, 78, 9, 10, 23<span class="o">]</span>
sorrted    <span class="o">[</span>3, 9, 10, 12, 23, 34, 45, 54, 65, 78<span class="o">]</span>
</code></pre></div><h1 id="堆排序">堆排序</h1>
<h1 id="归并排序">归并排序</h1>
<h1 id="计数排序">计数排序</h1>
<h1 id="基数排序">基数排序</h1>
<h1 id="桶排序">桶排序</h1>
<p><strong>未完待续。。。</strong></p>
			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://www.smslit.top/tags/algorithm">algorithm</a></span><span class="tag"><a href="https://www.smslit.top/tags/python">python</a></span>
				</p>
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
					3896 字
				</p>
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
					2018-11-07 15:37 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc">
			<div class="toc-title">目录</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#排序算法分类">排序算法分类</a></li>
    <li><a href="#排序算法对比">排序算法对比</a></li>
  </ul>

  <ul>
    <li><a href="#冒泡排序步骤">冒泡排序步骤</a></li>
    <li><a href="#冒泡排序示例代码">冒泡排序示例代码</a></li>
  </ul>

  <ul>
    <li><a href="#快速排序步骤">快速排序步骤</a></li>
    <li><a href="#快速排序示例代码">快速排序示例代码</a></li>
  </ul>

  <ul>
    <li><a href="#插入排序步骤">插入排序步骤</a></li>
    <li><a href="#插入排序示例代码">插入排序示例代码</a></li>
  </ul>

  <ul>
    <li><a href="#希尔排序步骤">希尔排序步骤</a></li>
    <li><a href="#希尔排序示例代码">希尔排序示例代码</a></li>
  </ul>

  <ul>
    <li><a href="#选择排序步骤">选择排序步骤</a></li>
    <li><a href="#选择排序示例代码">选择排序示例代码</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="next-post" href="https://www.smslit.top/2018/11/12/matplotlib-animation/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;下一篇</span><br><span>使用 matplotlib 的 animation 让数据动起来</span>
			</a>
			<a class="prev-post" href="https://www.smslit.top/2018/11/02/python-dev-in-windows/">
				<span class="post-nav-label">上一篇&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>windows 下 python 开发利器 vscode 的锻造</span>
			</a>
		</div>
		<div id="comments" class="thin">
		<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">打赏作者</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/assets/pay/wechatpay.png">
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/assets/pay/alipay.png">
      </label>
  </div>
</div>


<span id="/2018/11/07/algorithm-sort/" class="leancloud_visitors" data-flag-title="排序算法知多少">
  <span class="post-meta-item-text">访问量 </span>
  <span class="leancloud-visitors-count"></span>
  <p></p>
</span>
<div id="vcomments"></div>
<script src="/js/valine-data.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript">
  new Valine({
      el: '#vcomments' ,
      appId: 'IlJ4XQsE83q10RN3Maoglx2x-gzGzoHsz',
      appKey: 'OxVuAMUYBTbDMO9vO2IqTsMR',
      notify:  false , 
      verify:  false , 
      avatar:'', 
      placeholder: '说点什么吧...(提醒：填写邮箱，若有人回复您，您将及时收到提醒邮件！)',
      visitor:  true ,
      emojiCDN: '',
      emojiMaps: getEmojiMaps()
  });
</script>
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://www.smslit.top">5km</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://www.smslit.top/post/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://www.smslit.top/js/main.min.35ccbf1cdceb91e4c64c06b5d009d6e2977fafe56beda7762febd4e67528d2ac.js" integrity="sha256-Ncy/HNzrkeTGTAa10AnW4pd/r+Vr7ad2L+vU5nUo0qw="></script>

	
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: {equationNumbers: {autoNumber: "AMS"}},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>

</html>
